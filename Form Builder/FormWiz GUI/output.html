<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Example Form</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="generate.css">
    <link rel="stylesheet" href="generate2.css">
    <style>
        .entry-container { border: 2px solid #2980b9 !important; border-radius: 12px; padding: 20px; margin: 10px 0; background-color: #f8f9ff; box-shadow: 0 4px 8px rgba(41, 128, 185, 0.15); transition: all 0.3s ease; display: block; width: 100%; box-sizing: border-box; }
        .address-field { margin: 8px 0; }
        .address-input, .address-select { width: 100%; max-width: 400px; padding: 12px 16px; border: 1px solid #e1e5e9 !important; border-radius: 8px; font-size: 16px; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background-color: #ffffff !important; transition: all 0.2s ease; box-sizing: border-box; text-align: center; }
        .address-input:focus, .address-select:focus { outline: none; box-shadow: 0 0 0 3px rgba(41, 128, 185, 0.1); }
        .address-input::placeholder { color: #6c757d; opacity: 1; }
        .address-select { cursor: pointer; background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e"); background-repeat: no-repeat; background-position: right 12px center; background-size: 16px; padding-right: 40px; appearance: none; text-align: center; }
        .address-field:first-child { margin-top: 0; }
        .address-field:last-child { margin-bottom: 0; }
    </style>
</head>
<body>
<header>
    <img src="logo.png" alt="FormWiz Logo" width="130" height="80" onclick="location.href='index.html';">
    <nav>
        <a href="index.html">Home
            <span class="nav-chevron"><svg viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 1L5 5L9 1" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
        </a>
        <div class="nav-dropdown-wrapper" id="forms-dropdown-wrapper">
            <a href="#" id="forms-nav-link">Forms
                <span class="nav-chevron forms-chevron"><svg viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 1L5 5L9 1" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
            </a>
            <div class="dropdown-menu" id="forms-dropdown-menu">
                <a href="../Pages/forms.html">My Forms</a>
                <a href="../Pages/FreeForm.html">Free Form</a>
                <a href="../Pages/Family.html">Family</a>
                <a href="../Pages/Property.html">Property</a>
                <a href="../Pages/Immigration.html">Immigration</a>
                <a href="../Pages/smallclaims.html">Small Claims</a>
                <a href="../Pages/Other.html">Other</a>
            </div>
        </div>
        <a href="../Pages/about.html">About Us
            <span class="nav-chevron"><svg viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 1L5 5L9 1" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
        </a>
        <a href="../Pages/contact.html">Contact Us
            <span class="nav-chevron"><svg viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 1L5 5L9 1" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
        </a>
        <a href="../Pages/FAQ.html">FAQ
            <span class="nav-chevron"><svg viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 1L5 5L9 1" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
        </a>
    </nav>
    <div class="header-actions">
        <a href="../Pages/account.html" class="sign-in-btn" id="sign-in-btn">Sign In</a>
        <a href="#" class="sign-in-btn" id="logout-btn" style="display:none;">Log Out</a>
        <a href="#" id="cart-icon-link" style="margin-left: -10px; display: inline-flex; align-items: center; text-decoration: none; position: relative;">
            <span class="cart-circle">
                <svg id="cart-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="10" cy="21" r="1.5"/>
                    <circle cx="18" cy="21" r="1.5"/>
                    <path d="M2.5 4H5l2.68 13.39a2 2 0 0 0 2 1.61h7.72a2 2 0 0 0 2-1.61L21.5 7H6.16"/>
                </svg>
                <span id="cart-count-badge" style="display: none; position: absolute; top: -8px; right: -8px; width: 24px; height: 24px; background: #e74c3c; color: #fff; border-radius: 50%; font-size: 1em; font-weight: bold; display: flex; align-items: center; justify-content: center; box-shadow: 0 1px 4px rgba(44,62,80,0.13); z-index: 2; text-align: center;"></span>
            </span>
        </a>
    </div>
</header>

    <!-- Sliding Cart Menu -->
    <div class="cart-overlay" id="cart-overlay">
        <div class="cart-side-menu" id="cart-side-menu">
            <div class="cart-header">
                <h2>🛒 Cart</h2>
                <button class="cart-close-btn" id="cart-close-btn">&times;</button>
            </div>
            <div class="cart-content" id="cart-content">
                <div class="cart-icon-large">🛒</div>
                <div class="cart-message" id="cart-message">Create an account to start shopping!</div>
                <div class="cart-description" id="cart-description">
                    To add forms to your cart and make purchases, you\'ll need to create a FormWiz account. 
                    Sign up now to access our complete library of legal forms and start simplifying your paperwork.
                </div>
                <a href="../Pages/account.html" class="cart-signup-btn" id="cart-signup-btn">Sign Up</a>
                <div class="cart-items-list" id="cart-items-list" style="display:none;"></div>
                <button class="cart-checkout-btn" id="cart-checkout-btn" style="display:none;margin-top:24px;background:#2980b9;color:#fff;padding:15px 40px;font-size:1.1em;font-weight:700;border:none;border-radius:8px;cursor:pointer;">Checkout</button>
            </div>
        </div>
    </div>

<div id="pdfPreview" style="display:none;">
    <iframe id="pdfFrame" style="display:none"></iframe>
</div>
<input type="text" id="current_date" name="current_date" placeholder="current_date" style="display:none">

<!-- Firebase includes -->
<script src="https://js.stripe.com/v3/"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

<script>
// Firebase Configuration
const firebaseConfig = {
    apiKey: "AIzaSyDS-tSSn7fdLBgwzfHQ_1MPG1w8S_4qb04",
    authDomain: "formwiz-3f4fd.firebaseapp.com",
    projectId: "formwiz-3f4fd",
    storageBucket: "formwiz-3f4fd.firebasestorage.app",
    messagingSenderId: "404259212529",
    appId: "1:404259212529:web:15a33bce82383b21cfed50",
    measurementId: "G-P07YEN0HPD"
};

// Initialize Firebase
if (typeof firebase !== "undefined" && !firebase.apps.length) {
    firebase.initializeApp(firebaseConfig);
}
const auth = firebase.auth();

// Auth state management
if (typeof firebase !== "undefined" && firebase.apps.length > 0) {
    auth.onAuthStateChanged(function(user) {
        isUserLoggedIn = !!user;
        userId = user ? user.uid : null;
        updateAuthButtons(user);
        updateCartCountBadge();
    });
} else {
    // Fallback for when Firebase is not available
    console.log("Firebase not available, using fallback authentication");
}

// Function to update button display based on auth state
function updateAuthButtons(user) {
    const signInBtn = document.getElementById("sign-in-btn");
    const logoutBtn = document.getElementById("logout-btn");
    
    if (user) {
        if (signInBtn) signInBtn.style.display = "none";
        if (logoutBtn) logoutBtn.style.display = "inline-block";
    } else {
        if (signInBtn) signInBtn.style.display = "inline-block";
        if (logoutBtn) logoutBtn.style.display = "none";
    }
}

// Update cart count badge in header
function updateCartCountBadge() {
    const cartCountElement = document.getElementById("cart-count-badge");
    if (cartCountElement) {
        let count = 0;
        
        // Try to get count from getCartCount function first
        if (typeof getCartCount === "function") {
            count = getCartCount();
        } else {
            // Fallback to localStorage
            try {
                const cartData = localStorage.getItem("formwiz_cart");
                if (cartData) {
                    const cart = JSON.parse(cartData);
                    count = Array.isArray(cart) ? cart.length : 0;
                }
            } catch (e) {
                count = 0;
            }
        }
        
        // Always update the text content, even if count is 0
        cartCountElement.textContent = count;
        
        if (count > 0) {
            cartCountElement.style.display = "flex";
        } else {
            cartCountElement.style.display = "none";
        }
    }
}

// Initialize cart count badge on page load
document.addEventListener("DOMContentLoaded", function() {
    updateCartCountBadge();
    // Update cart count every 5 seconds
    setInterval(updateCartCountBadge, 5000);
});
</script>

<div style="width: 80%; max-width: 800px; margin: 20px auto; padding: 15px; border: 1px solid #ddd; border-radius: 8px; background-color: #f9f9f9; display: none;">
    <h3 style="text-align: center; margin-bottom: 15px; color: #2c3e50;">Your Information</h3>
    <div style="display: flex; gap: 15px; margin-bottom: 15px;">
        <div style="flex: 1;">
            <label for="user_firstname" style="display: block; margin-bottom: 5px; font-weight: bold;">First Name</label>
            <input type="text" form="customForm" id="user_firstname" name="user_firstname" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div style="flex: 1;">
            <label for="user_lastname" style="display: block; margin-bottom: 5px; font-weight: bold;">Last Name</label>
            <input type="text" form="customForm" id="user_lastname" name="user_lastname" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
    </div>
    <div style="margin-bottom: 15px;">
        <label for="user_email" style="display: block; margin-bottom: 5px; font-weight: bold;">Email Address</label>
        <input type="email" form="customForm" id="user_email" name="user_email" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
    </div>
    <div style="margin-bottom: 15px;">
        <label for="user_phone" style="display: block; margin-bottom: 5px; font-weight: bold;">Phone Number</label>
        <input type="tel" form="customForm" id="user_phone" name="user_phone" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
    </div>
    <div style="margin-bottom: 15px;">
        <label for="user_street" style="display: block; margin-bottom: 5px; font-weight: bold;">Street Address</label>
        <input type="text" form="customForm" id="user_street" name="user_street" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
    </div>
    <div style="display: flex; gap: 15px; margin-bottom: 15px;">
        <div style="flex: 2;">
            <label for="user_city" style="display: block; margin-bottom: 5px; font-weight: bold;">City</label>
            <input type="text" form="customForm" id="user_city" name="user_city" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div style="flex: 1;">
            <label for="user_state" style="display: block; margin-bottom: 5px; font-weight: bold;">State</label>
            <input type="text" form="customForm" id="user_state" name="user_state" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div style="flex: 1;">
            <label for="user_zip" style="display: block; margin-bottom: 5px; font-weight: bold;">ZIP</label>
            <input type="text" form="customForm" id="user_zip" name="user_zip" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
    </div>
</div>
<div id="questions">
    <div id="result"></div>
    <section>
    <div id="box">
        <form id="customForm" onsubmit="return showThankYouMessage(event);">
        <!-- Hidden fields for URL parameters -->
        <input type="hidden" id="form_zip" name="form_zip" value="">
        <input type="hidden" id="form_county" name="form_county" value="">
        <input type="hidden" id="form_defendant" name="form_defendant" value="">
        <input type="hidden" id="form_ID" name="form_ID" value=""><div class="stepper-progress-bar" id="stepperProgressBar"><div class="stepper-step" data-step="1"><div class="stepper-circle">1</div><div class="stepper-label">Section 1</div></div></div><div id="section1" class="section active"><center><h1 class="section-title">Section 1</h1><div id="question-container-1" class="question-container"><label><h3>Hungry?</h3></label><select id="hungry" name="hungry"
                      onchange="dropdownMirror(this, 'hungry'); updateHiddenLogic('hungry', this.value); updateLinkedFields(); clearInactiveLinkedFields()">
                       <option value="" disabled selected>Select an option</option><option value="Yes">Yes</option><option value="No">No</option></select><br>
              <div id="dropdowntext_hungry"></div>
              <input type="text" id="hungry_dropdown" name="hungry_dropdown"
                   readonly style="display:none;"></div><div id="question-container-2" class="question-container hidden"><label><h3>Enter info</h3></label><div id="labelContainer2"></div><div class="entry-container" style="border-radius: 12px; padding: 20px; margin: 10px auto; background-color: rgb(248, 249, 255); box-shadow: rgba(41, 128, 185, 0.15) 0px 4px 8px; transition: 0.3s; display: inline-block; width: auto; min-width: 450px; max-width: 100%; box-sizing: border-box; border: 2px solid rgb(41, 128, 185) !important;"><div class="address-field"><input type="text" id="enter_info_name_1" name="enter_info_name_1" placeholder="Name" class="address-input"></div></div><br></div><div id="question-container-3" class="question-container hidden"><label><h3>Why</h3></label><div class="text-input-container"><input type="text" id="why" name="why" placeholder=""></div></div><br><br><div class="navigation-buttons"><button type="submit" class="next-button">Submit</button></div></div><div id="hidden_pdf_fields">
<input type="hidden" id="user_firstname_hidden" name="user_firstname_hidden">
<input type="hidden" id="user_lastname_hidden"  name="user_lastname_hidden">
<input type="hidden" id="user_fullname"         name="user_fullname">
<input type="hidden" id="user_email_hidden"     name="user_email_hidden">
<input type="hidden" id="user_phone_hidden"     name="user_phone_hidden">
<input type="hidden" id="user_street_hidden"    name="user_street_hidden">
<input type="hidden" id="user_city_hidden"      name="user_city_hidden">
<input type="hidden" id="user_state_hidden"     name="user_state_hidden">
<input type="hidden" id="user_zip_hidden"       name="user_zip_hidden">
</div><input type="checkbox" id="example_form_default_checkbox" name="example_form_default_checkbox" checked style="display: none;"></form>
<div id="thankYouMessage" class="thank-you-message" style="display: none;">Thank you for completing the survey<br><br><button onclick="downloadAllPdfs()" style="font-size: 1.2em;">Download PDF</button><br><br><div id="checklistDisplay" style="margin: 20px 0; padding: 20px; background: #f8faff; border: 2px solid #2980b9; border-radius: 10px; display: none;"><h3 style="color: #2c3e50; margin-bottom: 15px;">📋 Your Personalized Checklist</h3><div id="checklistItems"></div></div><button onclick="showCartModal()" style="font-size: 1.2em;">Continue</button><br><br><button onclick="goBackToForm()" style="font-size: 1.2em;">Back</button><br><br><button onclick="window.location.href='../Pages/forms.html'" style="font-size: 1.2em;">Exit Survey</button></div>
</div>
</section>
</div>
<div class="pro-footer">
        <div class="pro-footer-col address-col">
            <div class="pro-footer-logo">
                <img src="logo.png" alt="FormWiz Logo" style="max-width:120px;max-height:80px;">
            </div>
            <div class="pro-footer-title">FormWiz</div>
            <div class="pro-footer-contact">
                <a href="tel:18884108370">1-888-410-8370</a> &nbsp; 
                <a href="mailto:info@rdr-gp.com">info@rdr-gp.com</a>
            </div>
        </div>
        <div class="pro-footer-col nav-col">
            <div class="pro-footer-title">Navigation</div>
            <a href="../Pages/index.html">Home</a>
            <a href="../Pages/FreeForm.html">Forms</a>
            <a href="../Pages/FAQ.html">FAQ</a>
            <a href="../Pages/about.html">About Us</a>
            <a href="../Pages/contact.html">Contact Us</a>
        </div>
        <div class="pro-footer-col company-col">
            <div class="pro-footer-title company-title">About FormWiz</div>
            <div class="pro-footer-desc">FormWiz consists of a group of proven professionals with over 70 years of combined technical, operational and administrative service experience within the non-profit, private, and public sectors. We simplify legal paperwork for everyone.</div>
        </div>
    </div>
    <footer>
        &copy; 2024 FormWiz. All rights reserved.
    </footer>
  <style>
  .alert-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(44, 62, 80, 0.45);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    backdrop-filter: blur(3px);
  }
  
  .alert-popup {
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(44,62,80,0.18);
    padding: 32px 28px 24px 28px;
    max-width: 480px;
    width: 90%;
    text-align: center;
    position: relative;
    animation: modalPopIn 0.35s cubic-bezier(.4,1.4,.6,1);
  }
  
  @keyframes modalPopIn {
    0% { transform: scale(0.85); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
  }
  
  
  .alert-message {
    margin-bottom: 28px;
    font-size: 1.08rem;
    line-height: 1.5;
    color: #2c3e50;
    font-weight: 600;
    padding: 20px;
    border: 2px solid #2980b9;
    border-radius: 10px;
    background: #e6f4ff;
    box-shadow: inset 0 2px 8px rgba(41, 128, 185, 0.1);
  }
  
  .alert-buttons {
    display: flex;
    gap: 18px;
    justify-content: center;
  }
  
  .alert-btn {
    padding: 8px 22px;
    border-radius: 6px;
    border: none;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s, color 0.2s;
    min-width: 100px;
  }
  
  .alert-btn-continue {
    background: linear-gradient(90deg, #4f8cff 0%, #38d39f 100%);
    color: #fff;
  }
  
  .alert-btn-continue:hover {
    background: linear-gradient(90deg, #38d39f 0%, #4f8cff 100%);
  }
  </style>
  
  <div id="alertOverlay" class="alert-overlay">
    <div class="alert-popup">
      <div id="alertMessage" class="alert-message"></div>
      <div class="alert-buttons">
        <button class="alert-btn alert-btn-continue" onclick="closeAlert()">Continue</button>
      </div>
    </div>
  </div>
  
<script>
window.formId = '';

/*───────────────────────────────*
 * return the true checkbox prefix
 *───────────────────────────────*/
function getCbPrefix (qId){
    if (questionSlugMap[qId]) return questionSlugMap[qId] + '_';
    if (questionNameIds[qId]) return questionNameIds[qId] + '_';
    return 'answer' + qId + '_';
}

/*───────────────────────────────*
 * buildCheckboxName(questionId, rawNameId, labelText)
 *───────────────────────────────*/
function buildCheckboxName (questionId, rawNameId, labelText){
    let namePart = (rawNameId || '').trim();
    if (!namePart){
        namePart = labelText.replace(/\W+/g, '_').toLowerCase();
    }
    // Return the name part directly without adding question prefix
    return namePart;
}

      let isUserLoggedIn = false;
      let userId = null;
      const urlParams = new URLSearchParams(window.location.search);
      const formId = urlParams.get("formId") || window.formId || 'default';
    var questionSlugMap       = {"1":"hungry","2":"enter_info","3":"why"};
var questionNameIds = {"1":"hungry","3":"why"};
var jumpLogics = [];
var conditionalPDFs = [];
var pdfLogicPDFs = [];
var alertLogics = [];
var checklistLogics = [];
var checklistItems = [];
var conditionalAlerts = [];
var labelMap = {"length":0};
var amountMap = {"length":0};
var labelNodeIdsMap = {};
var unifiedFieldsMap = {"2":[{"type":"label","label":"Name","nodeId":"enter_info_name","order":1}]};
var linkedDropdowns = [];
var hiddenLogicConfigs = [];
var linkedFields = [{"linkedFieldId":"test","fields":["enter_info_name","why"]}];
var isHandlingLink = false;
// Function to get URL parameters
function getUrlParameter(name) {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get(name);
}

// Function to populate hidden fields from URL parameters
function populateHiddenFieldsFromUrl() {
    const zipCode = getUrlParameter("zipCode");
    const county = getUrlParameter("county");
    const defendant = getUrlParameter("defendant");
    const formId = getUrlParameter("formId");
    
    if (zipCode) {
        const zipField = document.getElementById("form_zip");
        if (zipField) zipField.value = zipCode;
    }
    
    if (county) {
        const countyField = document.getElementById("form_county");
        if (countyField) countyField.value = county;
    }
    
    if (defendant) {
        const defendantField = document.getElementById("form_defendant");
        if (defendantField) defendantField.value = defendant;
    }
    
    if (formId) {
        const formIdField = document.getElementById("form_ID");
        if (formIdField) formIdField.value = formId;
    }
    
}

// Auto-populate on page load
document.addEventListener("DOMContentLoaded", function() {
    populateHiddenFieldsFromUrl();
    setupLinkedFields();
});

// Function to check paragraph limit and create hidden checkbox
function checkParagraphLimit(textareaId, paragraphLimit) {
    if (!paragraphLimit || paragraphLimit === "null") return;
    
    const textarea = document.getElementById(textareaId);
    if (!textarea) return;
    
    const currentLength = textarea.value.length;
    const checkboxId = textareaId + "_overlimit";
    let checkbox = document.getElementById(checkboxId);
    
    if (currentLength > paragraphLimit) {
        // Create checkbox if it doesn't exist
        if (!checkbox) {
            checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.id = checkboxId;
            checkbox.name = checkboxId;
            checkbox.style.display = "none"; // Hidden checkbox
            checkbox.checked = true;
            
            // Insert after the textarea
            textarea.parentNode.insertBefore(checkbox, textarea.nextSibling);
            
        } else {
            // Check the existing checkbox
            checkbox.checked = true;
        }
    } else {
        // Remove checkbox if it exists and we're under the limit
        if (checkbox) {
            checkbox.remove();
        }
    }
}
var sectionStack = [];
var currentSectionNumber = 1;
var pdfFileName = "";
var pdfOutputFileName = "example.html";
var stripePriceId = "";
var additionalPdfFileNames = [];
var allPdfFileNames = ["example.html", ];
var hiddenCheckboxCalculations = [];
var hiddenTextCalculations = [];


(function(){
 var thisQ=document.getElementById("question-container-2");
 function updateVisibility(){
  var anyMatch=false;
  (function(){
    var cPrevType="dropdown";
    var cPrevAns="no";
    var cPrevQNum="1";
    if(cPrevType==="checkbox"){
      var cbPrefix = getCbPrefix(cPrevQNum);
      var cbs=document.querySelectorAll('input[id^="'+cbPrefix+'"]');
      var checkedVals=[];
      for(var cc=0; cc<cbs.length; cc++){ if(cbs[cc].checked) checkedVals.push(cbs[cc].value.trim().toLowerCase());}
      if(checkedVals.indexOf(cPrevAns)!==-1){ anyMatch=true;}
    } else {
      var el2=document.getElementById(questionNameIds[cPrevQNum]) || document.getElementById("answer"+cPrevQNum);
      if(el2){ var val2= el2.value.trim().toLowerCase(); if(val2===cPrevAns){ anyMatch=true;} }
    }
  })();
 if(anyMatch){ thisQ.classList.remove("hidden"); } else { thisQ.classList.add("hidden"); }
}
 (function(){
   var selectQuestion = "1";
   var el3= document.getElementById(questionNameIds[selectQuestion]) || document.getElementById("answer"+selectQuestion);
   if(el3){ el3.addEventListener("change", function(){ updateVisibility();});}
 })();
 updateVisibility();
})();

(function(){
 var thisQ=document.getElementById("question-container-3");
 function updateVisibility(){
  var anyMatch=false;
  (function(){
    var cPrevType="dropdown";
    var cPrevAns="yes";
    var cPrevQNum="1";
    if(cPrevType==="checkbox"){
      var cbPrefix = getCbPrefix(cPrevQNum);
      var cbs=document.querySelectorAll('input[id^="'+cbPrefix+'"]');
      var checkedVals=[];
      for(var cc=0; cc<cbs.length; cc++){ if(cbs[cc].checked) checkedVals.push(cbs[cc].value.trim().toLowerCase());}
      if(checkedVals.indexOf(cPrevAns)!==-1){ anyMatch=true;}
    } else {
      var el2=document.getElementById(questionNameIds[cPrevQNum]) || document.getElementById("answer"+cPrevQNum);
      if(el2){ var val2= el2.value.trim().toLowerCase(); if(val2===cPrevAns){ anyMatch=true;} }
    }
  })();
 if(anyMatch){ thisQ.classList.remove("hidden"); } else { thisQ.classList.add("hidden"); }
}
 (function(){
   var selectQuestion = "1";
   var el3= document.getElementById(questionNameIds[selectQuestion]) || document.getElementById("answer"+selectQuestion);
   if(el3){ el3.addEventListener("change", function(){ updateVisibility();});}
 })();
 updateVisibility();
})();


// Alert Logic Functions
// Track page load time to prevent alerts in first 3 seconds
const pageLoadTime = Date.now();
const ALERT_DELAY_MS = 3000; // 3 seconds

function showAlert(message) {
    // Check if 3 seconds have passed since page load
    const currentTime = Date.now();
    const timeSinceLoad = currentTime - pageLoadTime;
    
    if (timeSinceLoad < ALERT_DELAY_MS) {
        // If less than 3 seconds have passed, don't show the alert
        console.log('Alert blocked: Page loaded less than 3 seconds ago');
        return;
    }
    
    const alertOverlay = document.getElementById('alertOverlay');
    const alertMessage = document.getElementById('alertMessage');
    
    if (alertOverlay && alertMessage) {
        // Check if this is a validation popup (HTML content) or regular alert (text)
        if (message.includes('<div')) {
            // This is HTML content (validation popup)
            alertMessage.innerHTML = message;
        } else {
            // This is a regular text alert
            alertMessage.textContent = message;
        }
        alertOverlay.style.display = 'flex';
    }
}

function closeAlert() {
    const alertOverlay = document.getElementById('alertOverlay');
    if (alertOverlay) {
        alertOverlay.style.display = 'none';
    }
}


// Show validation popup when user tries to proceed without answering all questions
function showValidationPopup() {
    const validationMessage = 
        '<div style="text-align: center;">' +
            '<div style="font-size: 2em; margin-bottom: 15px;">⚠️</div>' +
            '<div style="font-weight: 700; margin-bottom: 10px; color: #e74c3c;">Please Complete All Questions</div>' +
            '<div>You need to fill in all the questions on this page before you can proceed to the next section.</div>' +
        '</div>';
    showAlert(validationMessage);
}

// Helper function to deduplicate PDFs based on pdfName
function deduplicatePdfs(pdfArray) {
  const seen = new Set();
  const deduplicated = [];
  
  for (const pdf of pdfArray) {
    const key = pdf.pdfName || pdf.formId || pdf.title;
    if (!seen.has(key)) {
      seen.add(key);
      deduplicated.push(pdf);
    } else {
      console.log('🛒 [CART DEBUG] Skipping duplicate PDF:', key);
    }
  }
  
  return deduplicated;
}

// Always-available Cart Modal (global)
window.showCartModal = function () {
  console.log('🛒 [CART DEBUG] showCartModal called');
  
  // Calculate all PDFs that will be added to cart
  const allPdfsToAdd = [];
  
  // Add main form
  const mainFormPriceId = window.stripePriceId || stripePriceId || '123';
  allPdfsToAdd.push({
    formId: (window.pdfOutputFileName || 'sc500.pdf').replace(/.pdf$/i, '').toLowerCase(),
    title: window.pdfFileName || 'Form',
    priceId: mainFormPriceId,
    pdfName: window.pdfFileName || ''
  });
  
  // Add conditional PDFs based on current form state
  if (Array.isArray(window.pdfLogicPDFs) && window.pdfLogicPDFs.length > 0) {
    console.log('🛒 [CART DEBUG] Found', window.pdfLogicPDFs.length, 'PDF logic items');
    
    for (const pdfLogic of window.pdfLogicPDFs) {
      if (!pdfLogic || !pdfLogic.pdfName || !pdfLogic.stripePriceId) continue;
      
      let matched = false;
      const conds = Array.isArray(pdfLogic.conditions) ? pdfLogic.conditions : [];
      for (const c of conds) {
        const prevId = c?.prevQuestion;
        const expect = (c?.prevAnswer ?? '').toString().toLowerCase();
        if (!prevId) continue;
        
        const el = document.getElementById((window.questionNameIds || {})[prevId]) ||
                   document.getElementById('answer' + prevId);
        if (!el) continue;
        
        let val = '';
        if (el.type === 'checkbox') { val = el.checked ? (el.value || 'true') : ''; }
        else                        { val = el.value || ''; }
        
        if (val.toString().toLowerCase() === expect) {
          matched = true;
          console.log('🛒 [CART DEBUG] PDF logic matched:', pdfLogic.pdfDisplayName, 'for question', prevId, '=', expect);
        }
      }
      
      if (matched) {
        allPdfsToAdd.push({
          formId: pdfLogic.pdfName.replace(/.pdf$/i, '').toLowerCase(),
          title: pdfLogic.pdfDisplayName || pdfLogic.pdfName.replace(/.pdf$/i, ''),
          priceId: pdfLogic.stripePriceId,
          pdfName: pdfLogic.pdfName
        });
      }
    }
  }
  
  // Deduplicate PDFs to prevent multiple requests for the same PDF
  const originalCount = allPdfsToAdd.length;
  const deduplicatedPdfs = deduplicatePdfs(allPdfsToAdd);
  console.log('🛒 [CART DEBUG] Deduplication: Original count:', originalCount, 'After deduplication:', deduplicatedPdfs.length);
  
  console.log('🛒 [CART DEBUG] Total PDFs to add:', deduplicatedPdfs.length, deduplicatedPdfs);

  // Fetch prices for all PDFs
  async function fetchAllPrices() {
    const prices = [];
    for (const pdf of deduplicatedPdfs) {
      try {
        const r = await fetch('/stripe-price/' + pdf.priceId);
        if (r.ok) {
          const data = await r.json();
          const price = data && data.unit_amount != null ? (data.unit_amount / 100).toFixed(2) : '0.00';
          prices.push(parseFloat(price));
          console.log('🛒 [CART DEBUG] Price for', pdf.title, ':', price);
        } else {
          prices.push(0);
        }
      } catch (e) {
        console.error('🛒 [CART DEBUG] Error fetching price for', pdf.title, ':', e);
        prices.push(0);
      }
    }
    return prices;
  }

  fetchAllPrices().then((prices) => {
    const totalPrice = prices.reduce((sum, price) => sum + price, 0);
    const priceDisplay = totalPrice > 0 ? '$' + totalPrice.toFixed(2) : '...';
    
    console.log('🛒 [CART DEBUG] Total price:', priceDisplay);
    
    const modal = document.createElement('div');
    modal.id = 'cart-modal';
    modal.style.cssText = 'position:fixed;inset:0;background:rgba(44,62,80,.45);display:flex;align-items:center;justify-content:center;z-index:99999;';
    modal.innerHTML = `
      <div style="background:#fff;border-radius:12px;box-shadow:0 8px 32px rgba(44,62,80,.18);padding:32px 28px 24px;max-width:470px;width:90%;text-align:center;position:relative;">
        <h2>Checkout</h2>
        <p>Your form has been completed! Add it to your cart to download.</p>
        <p style="font-size:0.9em;color:#666;margin:10px 0;">${deduplicatedPdfs.length} PDF(s) will be added to cart</p>
        <button id="addToCartBtn" style="background:linear-gradient(90deg,#4f8cff 0%,#38d39f 100%);color:#fff;border:none;border-radius:6px;padding:10px 28px;font-size:1.1em;font-weight:600;cursor:pointer;">
          Add to Cart - ${priceDisplay}
        </button>
        <br><br>
        <button id="viewCartBtn" style="background:#e0e7ef;color:#2c3e50;border:none;border-radius:6px;padding:8px 22px;font-size:1em;font-weight:600;cursor:pointer;">
          View Cart
        </button>
        <br><br>
        <button id="cancelCartBtn" style="background:#e74c3c;color:#fff;border:none;border-radius:6px;padding:8px 22px;font-size:1em;font-weight:600;cursor:pointer;">
          Cancel
        </button>
      </div>
    `;
    document.body.appendChild(modal);

    document.getElementById('cancelCartBtn').onclick = () => modal.remove();
    document.getElementById('viewCartBtn').onclick   = () => { modal.remove(); window.location.href = '../Pages/cart.html'; };
    document.getElementById('addToCartBtn').onclick   = () => {
      console.log('🛒 [CART DEBUG] Add to cart button clicked');
      window.addFormToCart(mainFormPriceId);
      modal.remove();
    };
  });
};

// --- Cart helpers (new) ---
function clearCartState() {
  try { localStorage.removeItem('formwiz_cart'); } catch {}
  // expire cookie immediately
  document.cookie = 'formwiz_cart=;path=/;max-age=0';
}

function writeCartCookie(cart) {
  try { document.cookie = 'formwiz_cart=' + encodeURIComponent(JSON.stringify(cart)) + ';path=/;max-age=2592000'; } catch {}
}

function getUrlParam(name) {
  const u = new URLSearchParams(window.location.search);
  return u.get(name) || '';
}

// Add to cart helper (global, no Firebase required)
window.addFormToCart = function (priceId) {
  console.log('🛒 [CART DEBUG] addFormToCart called with priceId:', priceId);
  
  // 1) Fresh start each submission (prevents dupes/stale items across re-submits)
  clearCartState();

  // 2) Collect form data
  const form = document.getElementById('customForm');
  const formData = {};
  if (form) {
    for (const el of form.elements) {
      if (!el.name || el.disabled) continue;
      if (!['INPUT','TEXTAREA','SELECT'].includes(el.tagName)) continue;
      if (['hidden','button','submit','reset'].includes(el.type)) continue;
      formData[el.name] = (el.type === 'checkbox' || el.type === 'radio') ? !!el.checked : el.value;
    }
  }

  console.log('🛒 [CART DEBUG] Form data collected:', Object.keys(formData).length, 'fields');

  // 3) Uniform metadata for every cart line
  const originalFormId = (window.pdfOutputFileName || 'sc500.pdf').replace(/.pdf$/i, '').toLowerCase();
  const formTitle      = window.pdfFileName || (typeof pdfFileName !== 'undefined' ? pdfFileName : 'Form');
  const countyName     = getUrlParam('county');
  const defendantName  = getUrlParam('defendantName');
  const portfolioId    = getUrlParam('portfolioId');
  const nowTs          = Date.now();

  // 4) Compute all PDF-logic matches (OR logic across conditions)
  const pdfLogicItems = [];
  console.log('🛒 [CART DEBUG] Computing PDF logic items...');
  
  try {
    if (Array.isArray(window.pdfLogicPDFs) && window.pdfLogicPDFs.length > 0) {
      console.log('🛒 [CART DEBUG] Found', window.pdfLogicPDFs.length, 'PDF logic items to check');
      
      for (const pdfLogic of window.pdfLogicPDFs) {
        if (!pdfLogic || !pdfLogic.pdfName || !pdfLogic.stripePriceId) {
          console.log('🛒 [CART DEBUG] Skipping invalid PDF logic:', pdfLogic);
          continue;
        }
        
        console.log('🛒 [CART DEBUG] Checking PDF logic for:', pdfLogic.pdfDisplayName || pdfLogic.pdfName);

        let matched = false;
        const conds = Array.isArray(pdfLogic.conditions) ? pdfLogic.conditions : [];
        for (const c of conds) {
          const prevId = c?.prevQuestion;
          const expect = (c?.prevAnswer ?? '').toString().toLowerCase();
          if (!prevId) continue;

          const el = document.getElementById((window.questionNameIds || {})[prevId]) ||
                     document.getElementById('answer' + prevId);
          if (!el) {
            console.log('🛒 [CART DEBUG] Element not found for question', prevId);
            continue;
          }

          let val = '';
          if (el.type === 'checkbox') { val = el.checked ? (el.value || 'true') : ''; }
          else                        { val = el.value || ''; }

          console.log('🛒 [CART DEBUG] Question', prevId, 'value:', val, 'expected:', expect);

          if (val.toString().toLowerCase() === expect) {
            matched = true; // any condition match includes the PDF
            console.log('🛒 [CART DEBUG] ✅ PDF logic matched for:', pdfLogic.pdfDisplayName);
          }
        }

        if (matched) {
          // Create a proper display name for the PDF logic item
          let displayTitle;
          
          // If there's a custom PDF display name from the PDF logic, use it
          if (pdfLogic.pdfDisplayName && pdfLogic.pdfDisplayName.trim() !== '') {
            displayTitle = pdfLogic.pdfDisplayName.trim();
          } else {
            // Create a title based on the main form name + PDF name
            const mainFormName = window.pdfFileName || 'Form';
            const pdfBaseName = pdfLogic.pdfName.replace(/.pdf$/i, '').toUpperCase();
            displayTitle = mainFormName + ' ' + pdfBaseName;
          }
          
          const item = {
            formId: pdfLogic.pdfName.replace(/.pdf$/i, '').toLowerCase(),
            title: displayTitle,
            priceId: pdfLogic.stripePriceId,
            pdfName: pdfLogic.pdfName,
            originalFormId: originalFormId,
            portfolioId: portfolioId,
            formData: formData,
            countyName: countyName,
            defendantName: defendantName,
            timestamp: nowTs
          };
          pdfLogicItems.push(item);
          console.log('🛒 [CART DEBUG] Added PDF logic item:', item.title, 'with priceId:', item.priceId, 'portfolioId:', item.portfolioId);
        } else {
          console.log('🛒 [CART DEBUG] ❌ PDF logic not matched for:', pdfLogic.pdfDisplayName);
        }
      }
    } else {
      console.log('🛒 [CART DEBUG] No PDF logic items found');
    }
    
    // Deduplicate PDF logic items to prevent multiple requests for the same PDF
    const originalPdfLogicCount = pdfLogicItems.length;
    const deduplicatedPdfLogicItems = deduplicatePdfs(pdfLogicItems);
    console.log('🛒 [CART DEBUG] PDF Logic Deduplication: Original count:', originalPdfLogicCount, 'After deduplication:', deduplicatedPdfLogicItems.length);
    
    console.log('🛒 [CART DEBUG] Final PDF logic items:', deduplicatedPdfLogicItems.length, deduplicatedPdfLogicItems);
  } catch (e) {
    console.warn('[PDF LOGIC] error computing matches:', e);
  }

  // 5) Preferred path: site cart manager
  if (typeof window.addToCart === 'function') {
    console.log('🛒 [CART DEBUG] Firebase addToCart function available');
    
    // Create a batch of all items to add
    const allItems = [];
    
    // Add main item
    const mainItem = {
      formId: originalFormId,
      title: formTitle,
      priceId: priceId,
      formData: { ...formData, originalFormId, portfolioId, pdfName: (window.pdfFileName || '') },
      countyName: countyName,
      defendantName: defendantName
    };
    allItems.push(mainItem);
    console.log('🛒 [CART DEBUG] Main item:', mainItem.title, 'with priceId:', mainItem.priceId);
    
    // Add all matched PDF logic items
    for (const item of deduplicatedPdfLogicItems) {
      const pdfItem = {
        formId: item.formId.toLowerCase(),
        title: item.title,
        priceId: item.priceId,
        formData: { ...item.formData, originalFormId: item.originalFormId, portfolioId: item.portfolioId, pdfName: item.pdfName },
        countyName: item.countyName,
        defendantName: item.defendantName
      };
      allItems.push(pdfItem);
      console.log('🛒 [CART DEBUG] PDF logic item:', pdfItem.title, 'with priceId:', pdfItem.priceId);
    }
    
    console.log('🛒 [CART DEBUG] Total items to add to Firebase:', allItems.length, allItems);
    
    // Add all items to cart with a small delay between each to prevent race conditions
    let addedCount = 0;
    allItems.forEach((item, index) => {
      setTimeout(() => {
        console.log('🛒 [CART DEBUG] Adding item', index + 1, 'of', allItems.length, ':', item.title);
        
        // Ensure formData includes portfolio ID for proper grouping
        const enhancedFormData = {
          ...item.formData,
          originalFormId: item.originalFormId,
          portfolioId: item.portfolioId,
          pdfName: item.pdfName
        };
        
        window.addToCart(
          item.formId, item.title, item.priceId, enhancedFormData,
          item.countyName, item.defendantName, item.pdfName
        );
        addedCount++;
        
        // Check if all items have been added
        if (addedCount === allItems.length) {
          console.log('🛒 [CART DEBUG] All', allItems.length, 'items added to Firebase cart successfully');
          const itemList = allItems.map(item => {
            let itemInfo = '- ' + item.title + ' (' + item.formId + ') - PriceId: ' + item.priceId + ' - PortfolioId: ' + (item.portfolioId || 'N/A');
            if (item.defendantName && item.defendantName.trim() !== '') {
              itemInfo += ' - Defendant: ' + item.defendantName;
            }
            return itemInfo;
          }).join('\n');
          console.log('✅ Cart Debug: Successfully added ' + allItems.length + ' items to cart:\n' + itemList);
          
          // Show debugging alert with cart data
          const debugInfo = 'Cart Debug: Successfully added ' + allItems.length + ' items to cart:\n\n' + itemList;
          alert(debugInfo);
          
          // Show cart page requested alert
          alert('Cart page requested');
        }
      }, index * 200); // 200ms delay between each item
    });

    // Don't redirect automatically - let the alert handle it
    return;
  }

  // 6) Fallback: localStorage + cookie (fresh array due to clearCartState)
  console.log('🛒 [CART DEBUG] Firebase not available, using fallback localStorage/cookie');
  
  const cart = [];
  const mainCartItem = {
    formId: originalFormId, title: formTitle, priceId,
    pdfName: (window.pdfFileName || ''),
    originalFormId, portfolioId, formData, countyName, defendantName, timestamp: nowTs
  };
  cart.push(mainCartItem);
  console.log('🛒 [CART DEBUG] Main cart item:', mainCartItem.title, 'with priceId:', mainCartItem.priceId);
  
  for (const item of deduplicatedPdfLogicItems) {
    cart.push(item);
    console.log('🛒 [CART DEBUG] PDF logic cart item:', item.title, 'with priceId:', item.priceId);
  }

  console.log('🛒 [CART DEBUG] Total items in fallback cart:', cart.length, cart);

  try { localStorage.setItem('formwiz_cart', JSON.stringify(cart)); } catch {}
  writeCartCookie(cart);

  const itemList = cart.map(item => {
    let itemInfo = '- ' + item.title + ' (' + item.formId + ') - PriceId: ' + item.priceId + ' - PortfolioId: ' + (item.portfolioId || 'N/A');
    if (item.defendantName && item.defendantName.trim() !== '') {
      itemInfo += ' - Defendant: ' + item.defendantName;
    }
    return itemInfo;
  }).join('\n');
  console.log('✅ Cart Debug: Added ' + cart.length + ' items to local storage:\n' + itemList);
  
  // Show debugging alert with cart data
  const debugInfo = 'Cart Debug: Added ' + cart.length + ' items to local storage:\n\n' + itemList;
  alert(debugInfo);
  
  // Show cart page requested alert
  alert('Cart page requested');
};


// Fallback cart count function (global, no Firebase required)
window.getCartCount = function() {
  try {
    const cartData = localStorage.getItem('formwiz_cart');
    if (cartData) {
      const cart = JSON.parse(cartData);
      return Array.isArray(cart) ? cart.length : 0;
    }
  } catch (e) {
    console.error('Error getting cart count:', e);
  }
  return 0;
};

// Checklist Variables (always defined)
let userChecklist = [];
let staticChecklistItems = [];

  
  
  function sanitizeQuestionText (str){
    return String(str)
       .toLowerCase()
        .replace(/\W+/g, "_")   // ← double "\" so the HTML gets "\W"
        .replace(/^_+|_+$/g, "");
}

// Phone number formatter function
function formatPhoneNumber(value) {
  if (!value) return value;
  
  const phoneNumber = value.replace(/\D/g, '');
  const phoneNumberLength = phoneNumber.length;
  
  if (phoneNumberLength < 4) {
    return phoneNumberLength > 0 ? '(' + phoneNumber : '';
  } else if (phoneNumberLength < 7) {
    return '(' + phoneNumber.substring(0, 3) + ') ' + phoneNumber.substring(3);
  } else {
    return '(' + phoneNumber.substring(0, 3) + ') ' + 
           phoneNumber.substring(3, 6) + '-' + 
           phoneNumber.substring(6, 10);
  }
}

// Initialize all phone inputs on the page
document.addEventListener('DOMContentLoaded', function() {
  const phoneInputs = document.querySelectorAll('.phone-input');
  
  phoneInputs.forEach(phoneInput => {
    // Format existing value if any
    if (phoneInput.value) {
      phoneInput.value = formatPhoneNumber(phoneInput.value);
    }
    
    // Set up event listener for input
    phoneInput.addEventListener('input', function(e) {
      const input = e.target;
      const value = input.value.replace(/\D/g, '').substring(0, 10); // Strip non-digits and limit to 10 digits
      input.value = formatPhoneNumber(value);
    });
  });
});


function toggleAmountField(amountFieldId, show) {
    const amountField = document.getElementById(amountFieldId);
    if (amountField) {
        amountField.style.display = show ? 'block' : 'none';
        if (!show) amountField.value = '';
    }
}

/*──────────────────────────────────────────────────────────────*
 * Handle "Mark only one" selection functionality
 *──────────────────────────────────────────────────────────────*/
function handleMarkOnlyOneSelection(selectedInput, questionId) {
    if (!selectedInput.checked) return;
    
    // Find all radio buttons in this question group
    const container = document.querySelector('.checkbox-group-' + questionId);
    if (!container) return;
    
    const allInputs = container.querySelectorAll('input[type="radio"]');
    allInputs.forEach(input => {
        if (input !== selectedInput) {
            input.checked = false;
            // Update styling for unchecked inputs
            updateCheckboxStyle(input);
        }
    });
    
    // Update styling for the selected input
    updateCheckboxStyle(selectedInput);
}

/*──────────────────────────────────────────────────────────────*
 * Handle "None of the above" checkbox functionality
 *──────────────────────────────────────────────────────────────*/
function toggleNoneOption(checkbox, questionId) {
    if (!checkbox.checked) return;

    // Find the "None of the above" checkbox using more robust selectors
    const cbPrefix = getCbPrefix(questionId);
    const noneCheckbox = document.querySelector('input[id="' + cbPrefix + 'none"]') || 
                         document.querySelector('input[id^="' + cbPrefix + '"][id$="_none"]');
                         
    if (noneCheckbox && noneCheckbox.checked) {
        // Uncheck the "None of the above" option when any other option is checked
        noneCheckbox.checked = false;
    }
}

function handleNoneOfTheAboveToggle(noneCheckbox, questionId) {
    if (!noneCheckbox.checked) return;
    
    // When "None of the above" is checked, uncheck all other options
    const container = document.querySelector('.checkbox-group-' + questionId);
    if (!container) return;
    
    const allCheckboxes = container.querySelectorAll('input[type="checkbox"]');
    allCheckboxes.forEach(checkbox => {
        // Skip the "None" checkbox itself
        const isNoneCheckbox = checkbox.id.endsWith('_none') || checkbox.id.endsWith('none');
        if (checkbox !== noneCheckbox && !isNoneCheckbox) {
            checkbox.checked = false;
            
            // If this checkbox has an amount field, hide it
            const amountId = checkbox.id + '_amount';
            toggleAmountField(amountId, false);
        }
    });
    
    // Update styling for all checkboxes
    allCheckboxes.forEach(checkbox => {
        updateCheckboxStyle(checkbox);
    });
}

/*──────────────────────────────────────────────────────────────*
 * Update checkbox styling for beautiful blue border
 *──────────────────────────────────────────────────────────────*/
function updateCheckboxStyle(checkbox) {
    const container = document.getElementById('checkbox-container-' + checkbox.id);
    if (container) {
        if (checkbox.checked) {
            container.classList.add('checked');
        } else {
            container.classList.remove('checked');
        }
    }
}

/*──────────────────────────────────────────────────────────────*
 * Form validation functions
 *──────────────────────────────────────────────────────────────*/
function validateAndProceed(sectionNumber) {
    if (validateCurrentSection(sectionNumber)) {
        handleNext(sectionNumber);
    } else {
        // Show validation popup when validation fails
        showValidationPopup();
    }
}

// Show validation popup when user tries to proceed without answering all questions
function showValidationPopup() {
    const validationMessage = 
        '<div style="text-align: center;">' +
            '<div style="font-size: 2em; margin-bottom: 15px;">⚠️</div>' +
            '<div style="font-weight: 700; margin-bottom: 10px; color: #e74c3c;">Please Complete All Questions</div>' +
            '<div>You need to fill in all the questions on this page before you can proceed to the next section.</div>' +
        '</div>';
    showAlert(validationMessage);
}

// Global function to trigger visibility updates for dependent questions
function triggerVisibilityUpdates() {
    
    // Find all question containers and trigger their visibility logic
    const questionContainers = document.querySelectorAll('[id^="question-container-"]');
    
    questionContainers.forEach(container => {
        const questionId = container.id.replace('question-container-', '');
        
        // Try to find and call the updateVisibility function for this question
        // The conditional logic creates functions in the global scope, so we need to call them
        try {
            // Look for the updateVisibility function that was created for this question
            // The function is created in a closure, so we need to trigger it via the event listeners
        const questionElement = document.getElementById(questionNameIds[questionId]) || 
                              document.getElementById('answer' + questionId);
        
        if (questionElement) {
                console.log('🔧 [VISIBILITY DEBUG] Found question element for', questionId, ':', questionElement.id);
            // Trigger change event to update visibility
            const event = new Event('change', { bubbles: true });
            questionElement.dispatchEvent(event);
                console.log('🔧 [VISIBILITY DEBUG] Dispatched change event for', questionId);
            } else {
                console.log('🔧 [VISIBILITY DEBUG] No question element found for', questionId);
            }
        } catch (error) {
            console.log('🔧 [VISIBILITY DEBUG] Error processing question', questionId, ':', error);
        }
    });
}

// Fallback function to manually check and update visibility without relying on generated scripts
function triggerVisibilityUpdatesFallback() {
    console.log('🔧 [VISIBILITY FALLBACK DEBUG] triggerVisibilityUpdatesFallback() called');
    
    // Find all question containers
    const questionContainers = document.querySelectorAll('[id^="question-container-"]');
    console.log('🔧 [VISIBILITY FALLBACK DEBUG] Found', questionContainers.length, 'question containers');
    
    questionContainers.forEach(container => {
        const questionId = container.id.replace('question-container-', '');
        console.log('🔧 [VISIBILITY FALLBACK DEBUG] Processing question container:', questionId);
        
        // Check if this question has conditional logic by looking for data attributes or other indicators
        // For now, we'll manually check common conditional logic patterns
        
        // Check if this question should be visible based on other question values
        // This is a simplified version of the conditional logic
        let shouldBeVisible = true;
        
        // Look for any dropdown or input that might control this question's visibility
        const allInputs = document.querySelectorAll('input, select, textarea');
        allInputs.forEach(input => {
            if (input.id && input.id !== container.id) {
                // Check if this input's value should affect the visibility of the current question
                // This is a simplified check - in a real implementation, you'd need to parse the actual conditional logic
                if (input.value && input.value.trim() !== '') {
                    console.log('🔧 [VISIBILITY FALLBACK DEBUG] Found input with value:', input.id, '=', input.value);
                    // For now, we'll just log this - the actual conditional logic would be more complex
                }
            }
        });
        
        // For debugging, let's just make sure all questions are visible initially
        // In a real implementation, you'd implement the actual conditional logic here
        if (shouldBeVisible) {
            container.classList.remove('hidden');
            console.log('🔧 [VISIBILITY FALLBACK DEBUG] Made question', questionId, 'visible');
        } else {
            container.classList.add('hidden');
            console.log('🔧 [VISIBILITY FALLBACK DEBUG] Made question', questionId, 'hidden');
        }
    });
}

function validateCurrentSection(sectionNumber) {
    const section = document.getElementById('section' + sectionNumber);
    if (!section) return true;
    
    // Only validate visible questions (not hidden ones)
    const questions = section.querySelectorAll('.question-container:not(.hidden)');
    let isValid = true;
    
    questions.forEach(question => {
        const questionId = question.id.replace('question-container-', '');
        const questionType = getQuestionTypeFromContainer(question);
        
        if (!validateQuestion(question, questionType, questionId)) {
            isValid = false;
        }
    });
    
    // Update next button state
    const nextButton = document.getElementById('next-button-' + sectionNumber);
    if (nextButton) {
        nextButton.disabled = !isValid;
    }
    
    return isValid;
}

function getQuestionTypeFromContainer(questionContainer) {
    // Check for different input types to determine question type
    if (questionContainer.querySelector('input[type="checkbox"]')) {
        return 'checkbox';
    } else if (questionContainer.querySelector('select')) {
        return 'dropdown';
    } else if (questionContainer.querySelector('input[type="text"]')) {
        return 'text';
    } else if (questionContainer.querySelector('input[type="email"]')) {
        return 'email';
    } else if (questionContainer.querySelector('input[type="tel"]')) {
        return 'phone';
    } else if (questionContainer.querySelector('input[type="number"]')) {
        return 'number';
    } else if (questionContainer.querySelector('input[type="date"]')) {
        return 'date';
    } else if (questionContainer.querySelector('textarea')) {
        return 'bigParagraph';
    }
    return 'text'; // default
}

function validateQuestion(questionContainer, questionType, questionId) {
    let isValid = true;
    
    switch (questionType) {
        case 'checkbox':
            isValid = validateCheckboxQuestion(questionContainer);
            break;
        case 'dropdown':
            isValid = validateDropdownQuestion(questionContainer);
            break;
        case 'text':
        case 'email':
        case 'phone':
        case 'number':
        case 'date':
        case 'bigParagraph':
            isValid = validateTextQuestion(questionContainer);
            break;
        default:
            isValid = true;
    }
    
    // Add visual feedback
    if (!isValid) {
        questionContainer.classList.add('form-field-required');
        showValidationError(questionContainer, 'This field is required.');
    } else {
        questionContainer.classList.remove('form-field-required');
        hideValidationError(questionContainer);
    }
    
    return isValid;
}

function validateCheckboxQuestion(questionContainer) {
    const checkboxes = questionContainer.querySelectorAll('input[type="checkbox"]');
    const checkedBoxes = Array.from(checkboxes).filter(cb => cb.checked);
    return checkedBoxes.length > 0;
}

function validateDropdownQuestion(questionContainer) {
    const select = questionContainer.querySelector('select');
    if (!select) return true;
    
    // Check if the dropdown has a value and it's not the default empty/disabled option
    const isValid = select.value && select.value.trim() !== '' && select.value !== 'Select an option';
    return isValid;
}

function validateTextQuestion(questionContainer) {
    const inputs = questionContainer.querySelectorAll('input[type="text"], input[type="email"], input[type="tel"], input[type="number"], input[type="date"], textarea');
    if (inputs.length === 0) return true;
    
    for (let input of inputs) {
        if (!input.value || input.value.trim() === '') {
            return false;
        }
    }
    return true;
}

function showValidationError(container, message) {
    let errorDiv = container.querySelector('.validation-error');
    if (!errorDiv) {
        errorDiv = document.createElement('div');
        errorDiv.className = 'validation-error';
        container.appendChild(errorDiv);
    }
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
}

function hideValidationError(container) {
    const errorDiv = container.querySelector('.validation-error');
    if (errorDiv) {
        errorDiv.style.display = 'none';
    }
}

// Add validation listeners to all form fields
function addValidationListeners() {
    const currentSection = document.querySelector('.section.active');
    if (!currentSection) return;
    
    const sectionNumber = currentSection.id.replace('section', '');
    const formFields = currentSection.querySelectorAll('input, select, textarea');
    
    formFields.forEach(field => {
        // Remove existing listeners to prevent duplicates
        field.removeEventListener('change', field._validationHandler);
        field.removeEventListener('input', field._validationHandler);
        
        // Create new handler
        field._validationHandler = () => validateCurrentSection(sectionNumber);
        
        // Add listeners
        field.addEventListener('change', field._validationHandler);
        field.addEventListener('input', field._validationHandler);
    });
    
    // Initial validation
    validateCurrentSection(sectionNumber);
}

// Initialize validation when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    addValidationListeners();
    
    // Trigger visibility updates on DOM load to show dependent questions
    setTimeout(() => {
        if (typeof triggerVisibilityUpdates === 'function') {
            triggerVisibilityUpdates();
        }
    }, 300);
    
    // Re-add listeners when sections change
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                if (mutation.target.classList.contains('section')) {
                    setTimeout(addValidationListeners, 100);
                }
            }
        });
    });
    
    observer.observe(document.body, {
        attributes: true,
        subtree: true
    });
});

function showTextboxLabels(questionId, count){
    const container = document.getElementById("labelContainer" + questionId);
    if(!container) return;

    container.innerHTML = "";
    
    // Try to get unified fields first, fallback to old arrays
    const qBlock = document.querySelector('#question-container-' + questionId)?.closest('.question-block') || 
                   document.querySelector('[id*="' + questionId + '"]')?.closest('.question-block');
    
    let allFieldsInOrder = [];
    
    if (qBlock) {
        const unifiedFields = Array.from(qBlock.querySelectorAll('#unifiedFields' + questionId + ' .unified-field'));
        
        if (unifiedFields.length > 0) {
            // Use unified container data
            const allElements = [];
            
            unifiedFields.forEach((el) => {
                const fieldType = el.getAttribute('data-type');
                const fieldOrder = parseInt(el.getAttribute('data-order'));
                const labelTextEl = el.querySelector('#labelText' + questionId + '_' + fieldOrder);
                const nodeIdTextEl = el.querySelector('#nodeIdText' + questionId + '_' + fieldOrder);
                
                if (labelTextEl && nodeIdTextEl) {
                    allElements.push({
                        type: fieldType,
                        label: labelTextEl.textContent.trim(),
                        nodeId: nodeIdTextEl.textContent.trim(),
                        order: fieldOrder
                    });
                }
            });
            
            // Sort by data-order attribute (creation order)
            allElements.sort((a, b) => a.order - b.order);
            allFieldsInOrder = allElements;
        }
    }
    
    // Fallback to unified fields map or old arrays if no unified fields found
    if (allFieldsInOrder.length === 0) {
        // Try unified fields map first
        if (window.unifiedFieldsMap && window.unifiedFieldsMap[questionId]) {
            allFieldsInOrder = window.unifiedFieldsMap[questionId];
        } else {
            // Fallback to old arrays
            const theseLabels = labelMap[questionId] || [];
            const theseAmounts = amountMap[questionId] || [];
            
            allFieldsInOrder = [
                ...theseLabels.map((lbl, index) => ({
                    type: 'label',
                    label: lbl,
                    nodeId: (window.labelNodeIdsMap && window.labelNodeIdsMap[questionId] ? window.labelNodeIdsMap[questionId] : [])[index] || "",
                    order: index
                })),
                ...theseAmounts.map((amt, index) => ({
                    type: 'amount',
                    label: amt,
                    nodeId: "",
                    order: index
                }))
            ];
        }
    }

    /* get and sanitise the question's visible text exactly once */
    const questionH3   = document
        .getElementById("question-container-" + questionId)
        ?.querySelector("h3")?.textContent || ("answer" + questionId);
    const qSafe = sanitizeQuestionText(questionH3);

    // Generate hidden checkboxes for the selected count
    generateHiddenCheckboxes(questionId, qSafe, count);

    // Define location field names for visual separation
    const locationFields = ['Street', 'City', 'State', 'Zip'];

    for(let j = 1; j <= count; j++){
        let lastWasLocation = false;
        let firstField = true;
        
        // Create entry container div
        const entryContainer = document.createElement('div');
        entryContainer.className = 'entry-container';
        entryContainer.style.cssText = 'border: 2px solid #2980b9 !important; border-radius: 12px; padding: 20px; margin: 20px auto; background-color: #f8f9ff; box-shadow: 0 4px 8px rgba(41, 128, 185, 0.15); transition: all 0.3s ease; display: inline-block; width: auto; min-width: 450px; max-width: 100%; box-sizing: border-box;';
        
        // Process all fields in creation order
        for(let fieldIndex = 0; fieldIndex < allFieldsInOrder.length; fieldIndex++){
            const field = allFieldsInOrder[fieldIndex];
            const isLocationField = locationFields.includes(field.label);
            
            // Add <br> before first location field in each count
            if (isLocationField && !lastWasLocation && !firstField) {
                const br = document.createElement('br');
                entryContainer.appendChild(br);
            }
            
            if (field.type === 'label') {
                const fieldId = field.nodeId + "_" + j;
                if (field.label === 'State') {
                    // Use dropdown for State field
                    const dropdownDiv = document.createElement('div');
                    dropdownDiv.innerHTML = createStateDropdown(fieldId, j);
                    entryContainer.appendChild(dropdownDiv.firstElementChild);
                } else {
                    // Use regular input for other fields
                    const inputDiv = document.createElement('div');
                    inputDiv.innerHTML = createAddressInput(fieldId, field.label, j);
                    entryContainer.appendChild(inputDiv.firstElementChild);
                }
            } else if (field.type === 'amount') {
                const fieldId = field.nodeId + "_" + j;
                const inputDiv = document.createElement('div');
                inputDiv.innerHTML = createAddressInput(fieldId, field.label, j, 'number');
                entryContainer.appendChild(inputDiv.firstElementChild);
                
                // Add a <br> after the Zip input only if there are more fields after it
                const remainingFields = allFieldsInOrder.slice(fieldIndex + 1);
                if (remainingFields.length > 0) {
                  const brElement = document.createElement('br');
                  entryContainer.appendChild(brElement);
                }
            }
            
            lastWasLocation = isLocationField;
            firstField = false;
        }
        
        // Append the entry container to the main container
        container.appendChild(entryContainer);
        
        // Add 1 <br> tag after each entry for better visual separation
        const br = document.createElement('br');
        container.appendChild(br);
    }
    attachCalculationListeners();   // keep this
    
    // Update linked fields after creating new textboxes
    updateLinkedFields();
    
    // Attach autosave listeners to newly generated textbox inputs
    const newInputs = container.querySelectorAll('input[type="text"], input[type="number"]');
    newInputs.forEach(input => {
        input.addEventListener('input', function() {
            // Add a small delay to ensure the value is properly set before saving
            setTimeout(() => {
                if (typeof isUserLoggedIn !== 'undefined' && isUserLoggedIn) {
                    if (typeof saveAnswers === 'function') {
                        saveAnswers();
                    }
                } else {
                    if (typeof saveAnswersToLocalStorage === 'function') {
                        saveAnswersToLocalStorage();
                    }
                }
            }, 100); // 100ms delay to ensure value is set
        });
        input.addEventListener('change', function() {
            // Add a small delay to ensure the value is properly set before saving
            setTimeout(() => {
                if (typeof isUserLoggedIn !== 'undefined' && isUserLoggedIn) {
                    if (typeof saveAnswers === 'function') {
                        saveAnswers();
                    }
                } else {
                    if (typeof saveAnswersToLocalStorage === 'function') {
                        saveAnswersToLocalStorage();
                    }
                }
            }, 100); // 100ms delay to ensure value is set
        });
    });
}

// Generate hidden checkboxes for numbered dropdown questions
function generateHiddenCheckboxes(questionId, questionSafe, selectedCount) {
    // Get the dropdown element to find the range
    const dropdown = document.getElementById("answer" + questionId);
    if (!dropdown) return;
    
    // Find the maximum possible value from the dropdown options
    let maxRange = 0;
    for (let i = 0; i < dropdown.options.length; i++) {
        const optionValue = parseInt(dropdown.options[i].value);
        if (!isNaN(optionValue) && optionValue > maxRange) {
            maxRange = optionValue;
        }
    }
    
    // Remove any existing hidden checkboxes for this question
    const existingCheckboxes = document.querySelectorAll('input[type="checkbox"][id^="' + questionSafe + '_"]');
    existingCheckboxes.forEach(checkbox => checkbox.remove());
    
    // Generate hidden checkboxes for the full range
    for (let i = 1; i <= maxRange; i++) {
        const checkboxId = questionSafe + "_" + i;
        const checkboxName = questionSafe + "_" + i;
        
        // Create hidden checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = checkboxId;
        checkbox.name = checkboxName;
        checkbox.style.display = 'none'; // Hidden
        checkbox.checked = i <= selectedCount; // Check if this number is within the selected range
        
        // Add to the form (find the form element or add to body)
        const form = document.querySelector('form') || document.body;
        form.appendChild(checkbox);
    }
}

// Update hidden checkboxes when dropdown selection changes
function updateHiddenCheckboxes(questionId, selectedCount) {
    // Get the question's safe name
    const questionH3 = document
        .getElementById("question-container-" + questionId)
        ?.querySelector("h3")?.textContent || ("answer" + questionId);
    const qSafe = sanitizeQuestionText(questionH3);
    
    // Get the dropdown element to find the range
    const dropdown = document.getElementById("answer" + questionId);
    if (!dropdown) return;
    
    // Find the maximum possible value from the dropdown options
    let maxRange = 0;
    for (let i = 0; i < dropdown.options.length; i++) {
        const optionValue = parseInt(dropdown.options[i].value);
        if (!isNaN(optionValue) && optionValue > maxRange) {
            maxRange = optionValue;
        }
    }
    
    // Update existing checkboxes or create new ones if they don't exist
    for (let i = 1; i <= maxRange; i++) {
        const checkboxId = qSafe + "_" + i;
        let checkbox = document.getElementById(checkboxId);
        
        if (!checkbox) {
            // Create new checkbox if it doesn't exist
            checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = checkboxId;
            checkbox.name = qSafe + "_" + i;
            checkbox.style.display = 'none'; // Hidden
            
            // Add to the form
            const form = document.querySelector('form') || document.body;
            form.appendChild(checkbox);
        }
        
        // Update the checked state based on the selected count
        checkbox.checked = i <= selectedCount;
    }
}

// Handle linked dropdown logic
function handleLinkedDropdowns(sourceName, selectedValue) {
    if (typeof linkedDropdowns === 'undefined' || !linkedDropdowns || linkedDropdowns.length === 0 || typeof isHandlingLink !== 'undefined' && isHandlingLink) return;
    
    try {
        isHandlingLink = true;  // Set flag before handling links
        
        linkedDropdowns.forEach(linkPair => {
            if (linkPair.sourceNameId === sourceName) {
                const targetDropdown = document.getElementById(linkPair.targetNameId);
                if (targetDropdown && targetDropdown.value !== selectedValue) {  // Only if value is different
                    let optionExists = false;
                    for (let i = 0; i < targetDropdown.options.length; i++) {
                        if (targetDropdown.options[i].value === selectedValue) {
                            optionExists = true;
                            targetDropdown.value = selectedValue;
                            // Trigger change event only if value actually changed
                            const event = new Event('change');
                            targetDropdown.dispatchEvent(event);
                            break;
                        }
                    }
                    
                    if (!optionExists && selectedValue) {
                        console.warn("Option '" + selectedValue + "' does not exist in linked dropdown " + linkPair.targetNameId);
                    }
                }
            }
            else if (linkPair.targetNameId === sourceName) {
                const sourceDropdown = document.getElementById(linkPair.sourceNameId);
                if (sourceDropdown && sourceDropdown.value !== selectedValue) {  // Only if value is different
                    let optionExists = false;
                    for (let i = 0; i < sourceDropdown.options.length; i++) {
                        if (sourceDropdown.options[i].value === selectedValue) {
                            optionExists = true;
                            sourceDropdown.value = selectedValue;
                            // Trigger change event only if value actually changed
                            const event = new Event('change');
                            sourceDropdown.dispatchEvent(event);
                            break;
                        }
                    }
                    
                    if (!optionExists && selectedValue) {
                        console.warn("Option '" + selectedValue + "' does not exist in linked dropdown " + linkPair.sourceNameId);
                    }
                }
            }
        });
    } finally {
        isHandlingLink = false;  // Always reset flag when done
    }
}

/*──────── mirror a dropdown → textbox and checkbox ────────*/
function dropdownMirror(selectEl, baseName){
    const wrap = document.getElementById("dropdowntext_"+baseName);
    if(!wrap) return;

    const val = selectEl.value.trim();
    if(!val) {
        wrap.innerHTML = "";
        return;
    }

    const textId = baseName + "_dropdown";
    const textField = document.getElementById(textId);
    
    if(textField) {
        textField.value = val;
        textField.style.display = "none";
    }

    const existingCheckboxes = wrap.querySelectorAll("div");
    existingCheckboxes.forEach(div => div.remove());

    const idSuffix = val.replace(/\W+/g, "_").toLowerCase();
    const checkboxId = baseName + "_" + idSuffix;
    
    const checkboxDiv = document.createElement("div");
    checkboxDiv.style.display = "none";
    checkboxDiv.innerHTML = "<input type='checkbox' id='" + checkboxId + "' name='" + checkboxId + "' checked>" +
                     "<label for='" + checkboxId + "'> " + baseName + "_" + idSuffix + "</label>";
    
    wrap.appendChild(checkboxDiv);
    handleLinkedDropdowns(baseName, val);
}

// Function to handle hidden logic for dropdowns
function updateHiddenLogic(dropdownName, selectedValue) {
    // Find the hidden logic configuration for this dropdown
    const config = hiddenLogicConfigs.find(c => c.questionNameId === dropdownName);
    if (!config || config.trigger !== selectedValue) {
        return;
    }
    
    // Check if the hidden element already exists
    let hiddenElement = document.getElementById(config.nodeId);
    
    if (!hiddenElement) {
        // Create the hidden element based on type
        if (config.type === 'checkbox') {
            hiddenElement = document.createElement('input');
            hiddenElement.type = 'checkbox';
            hiddenElement.id = config.nodeId;
            hiddenElement.name = config.nodeId;
            hiddenElement.checked = true;
            hiddenElement.style.display = 'none';
        } else if (config.type === 'textbox') {
            hiddenElement = document.createElement('input');
            hiddenElement.type = 'text';
            hiddenElement.id = config.nodeId;
            hiddenElement.name = config.nodeId;
            hiddenElement.value = config.textboxText || '';
            hiddenElement.style.display = 'none';
        }
        
        // Add the hidden element to the form
        document.body.appendChild(hiddenElement);
    } else {
        // Update existing element
        if (config.type === 'checkbox') {
            hiddenElement.checked = true;
        } else if (config.type === 'textbox') {
            hiddenElement.value = config.textboxText || '';
        }
    }
}

// Function to handle linked fields synchronization
function updateLinkedFields() {
    if (!linkedFields || linkedFields.length === 0) return;
    
    linkedFields.forEach(linkedField => {
        const { linkedFieldId, fields } = linkedField;
        
        // Find the hidden textbox for this linked field
        let hiddenField = document.getElementById(linkedFieldId);
        if (!hiddenField) {
            // Create the hidden textbox if it doesn't exist
            hiddenField = document.createElement('input');
            hiddenField.type = 'text';
            hiddenField.id = linkedFieldId;
            hiddenField.name = linkedFieldId;
            hiddenField.style.display = 'none';
            document.body.appendChild(hiddenField);
        }
        
        // Get all the linked textboxes
        const linkedTextboxes = fields.map(fieldId => document.getElementById(fieldId)).filter(el => el);
        
        if (linkedTextboxes.length === 0) return;
        
        // Find which textbox has content
        const textboxesWithContent = linkedTextboxes.filter(tb => tb.value.trim() !== '');
        
        if (textboxesWithContent.length === 0) {
            // No textboxes have content, clear the hidden field
            hiddenField.value = '';
        } else if (textboxesWithContent.length === 1) {
            // Only one textbox has content, use its value
            hiddenField.value = textboxesWithContent[0].value;
        } else {
            // Multiple textboxes have content, use the one with the longest text
            const longestTextbox = textboxesWithContent.reduce((longest, current) => 
                current.value.length > longest.value.length ? current : longest
            );
            hiddenField.value = longestTextbox.value;
        }
    });
}

// Function to clear inactive linked textboxes (with delay to avoid interfering with typing)
function clearInactiveLinkedFields() {
    if (!linkedFields || linkedFields.length === 0) return;
    
    // Use setTimeout to avoid interfering with user typing
    setTimeout(() => {
        linkedFields.forEach(linkedField => {
            const { fields } = linkedField;
            
            // Get all the linked textboxes
            const linkedTextboxes = fields.map(fieldId => document.getElementById(fieldId)).filter(el => el);
            
            if (linkedTextboxes.length === 0) return;
            
            // Find which textboxes are currently visible (not hidden by conditional logic)
            const visibleTextboxes = linkedTextboxes.filter(tb => {
                const container = tb.closest('.question-container');
                return container && !container.classList.contains('hidden');
            });
            
            // Find which textboxes have content
            const textboxesWithContent = linkedTextboxes.filter(tb => tb.value.trim() !== '');
            
            // Clear all hidden textboxes that have content
            linkedTextboxes.forEach(tb => {
                const container = tb.closest('.question-container');
                if (container && container.classList.contains('hidden') && tb.value.trim() !== '') {
                    tb.value = '';
                }
            });
            
            // If multiple visible textboxes have content, keep only the longest one
            const visibleTextboxesWithContent = visibleTextboxes.filter(tb => tb.value.trim() !== '');
            if (visibleTextboxesWithContent.length > 1) {
                const longestTextbox = visibleTextboxesWithContent.reduce((longest, current) => 
                    current.value.length > longest.value.length ? current : longest
                );
                
                // Clear all other visible textboxes that aren't the longest
                visibleTextboxes.forEach(tb => {
                    if (tb !== longestTextbox && tb.value.trim() !== '') {
                        tb.value = '';
                    }
                });
            }
        });
    }, 100); // 100ms delay to avoid interfering with typing
}

// Function to set up linked fields event listeners
function setupLinkedFields() {
    if (!linkedFields || linkedFields.length === 0) return;
    
    // Use event delegation to handle dynamically created textboxes
    document.addEventListener('input', function(event) {
        if (event.target.tagName === 'INPUT' && event.target.type === 'text') {
            // Check if this input is part of any linked field
            const fieldId = event.target.id;
            const isLinkedField = linkedFields.some(linkedField => 
                linkedField.fields.includes(fieldId)
            );
            
            if (isLinkedField) {
                updateLinkedFields();
            }
        }
    });
    
    document.addEventListener('change', function(event) {
        if (event.target.tagName === 'INPUT' && event.target.type === 'text') {
            // Check if this input is part of any linked field
            const fieldId = event.target.id;
            const isLinkedField = linkedFields.some(linkedField => 
                linkedField.fields.includes(fieldId)
            );
            
            if (isLinkedField) {
                updateLinkedFields();
            }
        }
    });
    
    // Initial update
    updateLinkedFields();
}

function getQuestionInputs (questionId, type = null) {
  /* 1️⃣ First look inside the question container, if it exists */
  const container = document.getElementById('question-container-' + questionId);
  if (container) {
    return container.querySelectorAll(
      type ? 'input[type="' + type + '"]' : 'input, select, textarea'
    );
  }

  /* 2️⃣ Fallback to the old prefix‑style that your generator sometimes uses */
  const prefix = 'input[id^="' + getCbPrefix(questionId) + '"]';

  return document.querySelectorAll(
    type ? prefix + '[type="' + type + '"]' : prefix + ', select[id^="answer' + questionId + '"]'
  );
}

/*------------------------------------------------------------------
 *  handleNext(currentSection)
 *  – pushes the section you are leaving and works out where to go
 *-----------------------------------------------------------------*/
function handleNext(currentSection){
    runAllHiddenCheckboxCalculations();
    runAllHiddenTextCalculations();

    /* remember the place we're leaving */
    sectionStack.push(currentSection);

    let nextSection = currentSection + 1;

    /* ---------- evaluate jump rules ---------- */
    const relevantJumps = jumpLogics.filter(jl => jl.section === currentSection);
    for (const jl of relevantJumps){
        const nmId = questionNameIds[jl.questionId] || ('answer'+jl.questionId);

        if (['radio','dropdown','numberedDropdown'].includes(jl.questionType)){
            const el = document.getElementById(nmId);
            if (el && el.value.trim().toLowerCase() === jl.jumpOption.trim().toLowerCase()){
                nextSection = jl.jumpTo.toLowerCase();
                break;
            }
        } else if (jl.questionType === 'checkbox'){
            const cbs = getQuestionInputs(jl.questionId, 'checkbox');
            const chosen = Array.from(cbs).filter(cb=>cb.checked)
                                .map(cb=>cb.value.trim().toLowerCase());
            if (chosen.includes(jl.jumpOption.trim().toLowerCase())){
                nextSection = jl.jumpTo.toLowerCase();
                break;
            }
        }
    }

    /* ---------- special "end" shortcut ---------- */
    if (nextSection === 'end'){
        processAllPdfs().then(()=>navigateSection('end'));
        return;
    }

    nextSection = parseInt(nextSection,10);
    if (isNaN(nextSection)) nextSection = currentSection + 1;
    navigateSection(nextSection);

    /* recalc hidden fields after navigation */
    runAllHiddenCheckboxCalculations();
    runAllHiddenTextCalculations();
}


/*------------------------------------------------------------------
 *  resetHiddenQuestionsToDefaults(sectionNumber)
 *  – resets hidden questions in the current section to their default values
 *    This prevents Firebase autosave from keeping values for questions
 *    that are hidden due to conditional logic
 *-----------------------------------------------------------------*/
function resetHiddenQuestionsToDefaults(sectionNumber) {
    // Get the current section
    const currentSection = document.getElementById('section' + sectionNumber);
    if (!currentSection) {
        console.log('Reset function: Section not found for section', sectionNumber);
        return;
    }
    
    // Find all hidden question containers in this section
    const hiddenQuestions = currentSection.querySelectorAll('.question-container.hidden');
    
    if (hiddenQuestions.length === 0) {
        console.log('Reset function: No hidden questions found in section', sectionNumber);
        return;
    }
    
    console.log('Reset function: Found', hiddenQuestions.length, 'hidden questions in section', sectionNumber);
    
    hiddenQuestions.forEach((questionContainer, index) => {
        // Get all form elements within this hidden question
        const formElements = questionContainer.querySelectorAll('input, select, textarea');
        
        formElements.forEach(element => {
            const elementName = element.name || element.id || 'unnamed';
            const oldValue = element.value || element.checked;
            
            if (element.tagName === 'SELECT') {
                // Reset dropdown to default "Select an option"
                element.value = '';
                // Find the default option and set it as selected
                const defaultOption = element.querySelector('option[disabled][selected]');
                if (defaultOption) {
                    defaultOption.selected = true;
                }
                console.log('Reset function: Reset dropdown', elementName, 'from', oldValue, 'to default');
            } else if (element.type === 'checkbox' || element.type === 'radio') {
                // Reset checkboxes and radio buttons to unchecked
                element.checked = false;
                console.log('Reset function: Reset', element.type, elementName, 'from', oldValue, 'to false');
            } else if (element.type === 'text' || element.type === 'email' || element.type === 'tel' || 
                      element.type === 'number' || element.type === 'date' || element.tagName === 'TEXTAREA') {
                // Reset text inputs to empty
                element.value = '';
                console.log('Reset function: Reset', element.type || 'textarea', elementName, 'from', oldValue, 'to empty');
            }
        });
    });
}

/*------------------------------------------------------------------
 *  navigateSection(sectionNumber)
 *  – shows exactly one section (or Thank‑you) and records history
 *-----------------------------------------------------------------*/



function navigateSection(sectionNumber){
    const sections  = document.querySelectorAll('.section');
    const form      = document.getElementById('customForm');
    const thankYou  = document.getElementById('thankYouMessage');

    /* hide everything first */
    sections.forEach(sec => sec.classList.remove('active'));
    thankYou.style.display = 'none';
    form.style.display     = 'block';

    if (sectionNumber === 'end'){
        form.style.display   = 'none';
        thankYou.style.display = 'block';
        currentSectionNumber = 'end';
        updateProgressBar();
        return;
    }

    /* ── corrected bounds check ────────────────────────────── */
    const maxSection = sections.length;   // 1‑based section numbers
    if (sectionNumber < 1)           sectionNumber = 1;
    if (sectionNumber > maxSection)  sectionNumber = maxSection;

    /* show the requested section */
    const target = document.getElementById('section' + sectionNumber);
    (target || sections[maxSection - 1]).classList.add('active');

    currentSectionNumber = sectionNumber;
    
    // Reset hidden questions to default values after Firebase autosave
    resetHiddenQuestionsToDefaults(sectionNumber);
    
    updateProgressBar();
}



/*------------------------------------------------------------------
 *  goBack()
 *  – pops the history stack; falls back to numeric −1 if empty
 *-----------------------------------------------------------------*/
function goBack(){
    if (sectionStack.length > 0){
        const prev = sectionStack.pop();
        navigateSection(prev);
    }else if (typeof currentSectionNumber === 'number' && currentSectionNumber > 1){
        navigateSection(currentSectionNumber - 1);
    }
    updateProgressBar();
}


/*──────────────── helpers ───────────────*/
function setCurrentDate () {
    const t = new Date();
    document.getElementById('current_date').value =
        t.getFullYear() + '-' +
        String(t.getMonth() + 1).padStart(2, '0') + '-' +
        String(t.getDate()).padStart(2, '0');
}





window.onload=function(){
    setCurrentDate();
    attachCalculationListeners();
    
    // Trigger visibility updates on page load to show dependent questions
    setTimeout(() => {
        if (typeof triggerVisibilityUpdates === 'function') {
            triggerVisibilityUpdates();
        }
    }, 200);
};

function handleConditionalAlerts(){
    for(var i=0; i<conditionalAlerts.length; i++){
        var obj = conditionalAlerts[i];
        var prevQEl= document.getElementById("answer"+obj.prevQuestionId);
        if(prevQEl){
            if(prevQEl.value.trim().toLowerCase() === obj.prevAnswer.trim().toLowerCase()){
                alert(obj.alertText);
            }
        } else {
            var cbs= document.querySelectorAll('[name^="answer'+obj.prevQuestionId+'_"]');
            for(var x=0; x<cbs.length; x++){
                if(cbs[x].checked && cbs[x].value.trim().toLowerCase()=== obj.prevAnswer.trim().toLowerCase()){
                    alert(obj.alertText);
                }
            }
        }
    }
}

/*──── main submit handler ────*/
function showThankYouMessage (event) {
    // Safely prevent default if an event was provided
    if (event && typeof event.preventDefault === 'function') {
        event.preventDefault();
    }
    
    // Show thank you message immediately (no PDF processing)
    document.getElementById('customForm').style.display = 'none';
    document.getElementById('thankYouMessage').style.display = 'block';
    
    // Display checklist if there are items
    const checklistDisplay = document.getElementById('checklistDisplay');
    const checklistItemsContainer = document.getElementById('checklistItems');
    
    // Combine static and dynamic checklist items
    const allChecklistItems = [...(checklistItems || []), ...(userChecklist || [])];
    
    if (checklistDisplay && checklistItemsContainer && allChecklistItems.length > 0) {
        checklistDisplay.style.display = 'block';
        
        // Create checklist items HTML
        let checklistHTML = '';
        allChecklistItems.forEach((item, index) => {
            checklistHTML += '<div style="margin: 8px 0; padding: 10px; background: white; border-radius: 8px; border-left: 4px solid #2980b9; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">' +
                '<input type="checkbox" id="checklistItem' + index + '" style="margin-right: 10px;">' +
                '<label for="checklistItem' + index + '" style="color: #2c3e50; font-weight: 500; cursor: pointer;">' + item + '</label>' +
            '</div>';
        });
        
        checklistItemsContainer.innerHTML = checklistHTML;
    }
    
    return false;                       // prevent page reload
}

// Form submission is now handled by the inline onsubmit attribute

/*──── process all PDFs sequentially ────*/
async function processAllPdfs() {
    console.log('🔧 [PDF DEBUG] processAllPdfs() called');
    console.log('🔧 [PDF DEBUG] pdfOutputFileName:', pdfOutputFileName);
    console.log('🔧 [PDF DEBUG] conditionalPDFs:', conditionalPDFs);
    console.log('🔧 [PDF DEBUG] pdfLogicPDFs:', pdfLogicPDFs);
    
    // Track processed PDFs to prevent duplicates
    const processedPdfs = new Set();
    
    // Process main PDFs - use the actual PDF filename, not the form name
    if (pdfOutputFileName) {
        console.log('🔧 [PDF DEBUG] Processing main PDF:', pdfOutputFileName);
        // Remove .pdf extension if present since server adds it automatically
        const baseName = pdfOutputFileName.replace(/.pdf$/i, '');
        if (!processedPdfs.has(baseName)) {
            processedPdfs.add(baseName);
        await editAndDownloadPDF(baseName);
        } else {
            console.log('🔧 [PDF DEBUG] Skipping duplicate main PDF:', baseName);
        }
    }
    
    // Process Conditional PDFs
    if (conditionalPDFs && conditionalPDFs.length > 0) {
        for (const conditionalPDF of conditionalPDFs) {
            if (conditionalPDF.pdfName) {
                // Check if conditions are met
                let shouldDownload = false;
                
                // Get the question element
                const questionElement = document.getElementById(questionNameIds[conditionalPDF.questionId]) || 
                                      document.getElementById('answer' + conditionalPDF.questionId);
                
                if (questionElement) {
                    let questionValue = '';
                    
                    if (questionElement.type === 'checkbox') {
                        questionValue = questionElement.checked ? questionElement.value : '';
                    } else {
                        questionValue = questionElement.value;
                    }
                    
                    // Check if the condition matches
                    if (questionValue.toString().toLowerCase() === conditionalPDF.conditionalAnswer.toLowerCase()) {
                        shouldDownload = true;
                    }
                }
                
                // Download PDF if conditions are met
                if (shouldDownload) {
                    const baseName = conditionalPDF.pdfName.replace(/.pdf$/i, '');
                    if (!processedPdfs.has(baseName)) {
                        processedPdfs.add(baseName);
                        await editAndDownloadPDF(baseName);
                    } else {
                        console.log('🔧 [PDF DEBUG] Skipping duplicate conditional PDF:', baseName);
                    }
                }
            }
        }
    }
    
    // Process PDF Logic PDFs
    if (pdfLogicPDFs && pdfLogicPDFs.length > 0) {
        for (const pdfLogic of pdfLogicPDFs) {
            if (pdfLogic.pdfName) {
                // Check if conditions are met
                let shouldDownload = false;
                
                if (pdfLogic.isBigParagraph) {
                    // For Big Paragraph questions, check character limit
                    pdfLogic.conditions.forEach(condition => {
                        if (condition.characterLimit) {
                            // Get the Big Paragraph question's value
                            const questionElement = document.getElementById(questionNameIds[pdfLogic.questionId]) || 
                                                  document.getElementById('answer' + pdfLogic.questionId);
                            
                            if (questionElement) {
                                const questionValue = questionElement.value || '';
                                
                                // Check if the text length exceeds the character limit
                                if (questionValue.length > condition.characterLimit) {
                                    shouldDownload = true;
                                }
                            }
                        }
                    });
                } else {
                    // For other question types, check previous question conditions
                pdfLogic.conditions.forEach(condition => {
                    const prevQuestionId = condition.prevQuestion;
                    const prevAnswer = condition.prevAnswer;
                    
                    // Get the previous question's value
                    const prevQuestionElement = document.getElementById(questionNameIds[prevQuestionId]) || 
                                              document.getElementById('answer' + prevQuestionId);
                    
                    if (prevQuestionElement) {
                        let prevValue = '';
                        
                        if (prevQuestionElement.type === 'checkbox') {
                            prevValue = prevQuestionElement.checked ? prevQuestionElement.value : '';
                        } else {
                            prevValue = prevQuestionElement.value;
                        }
                        
                        // Check if the condition matches
                        if (prevValue.toString().toLowerCase() === prevAnswer.toLowerCase()) {
                            shouldDownload = true;
                        }
                    }
                });
                }
                
                // Download PDF if conditions are met
                if (shouldDownload) {
                    const baseName = pdfLogic.pdfName.replace(/.pdf$/i, '');
                    if (!processedPdfs.has(baseName)) {
                        processedPdfs.add(baseName);
                        await editAndDownloadPDF(baseName);
                    } else {
                        console.log('🔧 [PDF DEBUG] Skipping duplicate PDF logic PDF:', baseName);
                    }
                }
            }
        }
    }
}

// Function to go back to the form from the thank you screen
function goBackToForm() {
    console.log('🔧 [BACK BUTTON] Going back to form');
    
    // Hide the thank you message
    const thankYouMessage = document.getElementById('thankYouMessage');
    if (thankYouMessage) {
        thankYouMessage.style.display = 'none';
    }
    
    // Show the form again
    const formContainer = document.querySelector('form');
    if (formContainer) {
        formContainer.style.display = 'block';
    }
    
    // Scroll back to the top of the form
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// Manual PDF download function (called when user clicks "Download PDF" button)
async function downloadAllPdfs() {
    console.log('🔧 [PDF DEBUG] downloadAllPdfs() called');
    try {
        // Show loading state
        const downloadButton = document.querySelector('button[onclick="downloadAllPdfs()"]');
        console.log('🔧 [PDF DEBUG] Download button found:', !!downloadButton);
        if (downloadButton) {
            downloadButton.textContent = 'Processing...';
            downloadButton.disabled = true;
        }
        
        console.log('🔧 [PDF DEBUG] Calling processAllPdfs()...');
        await processAllPdfs();
        console.log('🔧 [PDF DEBUG] processAllPdfs() completed successfully');
        
        // Reset button
        if (downloadButton) {
            downloadButton.textContent = 'Download PDF';
            downloadButton.disabled = false;
        }
    } catch (error) {
        console.error('🔧 [PDF DEBUG] Error downloading PDFs:', error);
        // Reset button on error
        const downloadButton = document.querySelector('button[onclick="downloadAllPdfs()"]');
        if (downloadButton) {
            downloadButton.textContent = 'Download PDF';
            downloadButton.disabled = false;
        }
    }
}

/*──── build FormData with **everything inside the form** ────*/
async function editAndDownloadPDF (pdfName) {
    try {
        console.log('🔧 [PDF DEBUG] Starting PDF processing for:', pdfName);
        
        /* this grabs every control that belongs to <form id="customForm">,
           including those specified with form="customForm" attributes   */
        const fd = new FormData(document.getElementById('customForm'));
        console.log('🔧 [PDF DEBUG] FormData created with', fd.entries().length, 'entries');

        // Use the /edit_pdf endpoint with the PDF name as a query parameter
        // Remove the .pdf extension if present since server adds it automatically
        const baseName = pdfName.replace(/.pdf$/i, '');
        const endpoint = '/edit_pdf?pdf=' + encodeURIComponent(baseName);
        console.log('🔧 [PDF DEBUG] Making request to:', endpoint);
        
        const res = await fetch(endpoint, { 
            method: 'POST', 
            body: fd 
        });
        
        console.log('🔧 [PDF DEBUG] Response status:', res.status, 'OK:', res.ok);
        console.log('🔧 [PDF DEBUG] Response headers:', Object.fromEntries(res.headers.entries()));
        
        if (!res.ok) {
            const errorText = await res.text();
            console.error('🔧 [PDF DEBUG] Server error response:', errorText);
            throw new Error("HTTP error! status: " + res.status + " - " + errorText);
        }
        
        const blob = await res.blob();
        console.log('🔧 [PDF DEBUG] Blob created, size:', blob.size, 'type:', blob.type);
        
        if (blob.size === 0) {
            throw new Error("Received empty PDF blob from server");
        }
        
        const url = URL.createObjectURL(blob);
        console.log('🔧 [PDF DEBUG] Object URL created:', url);

        // Trigger download
        const a = document.createElement('a');
        a.href = url;
        a.download = 'Edited_' + pdfName;
        console.log('🔧 [PDF DEBUG] Triggering download for:', a.download);
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        // Clean up the object URL after a delay
        setTimeout(() => {
            URL.revokeObjectURL(url);
            console.log('🔧 [PDF DEBUG] Object URL cleaned up');
        }, 1000);

        // inline preview - only show the last one
        const frame = document.getElementById('pdfFrame');
        if (frame) {
            frame.src = url;
            frame.style.display = 'block';
        }
        const preview = document.getElementById('pdfPreview');
        if (preview) {
            preview.style.display = 'none';
        }
        
        console.log("Successfully processed PDF: " + pdfName);
    } catch (error) {
        console.error("Error processing PDF " + pdfName + ":", error);
        throw error; // Re-throw to be handled by the caller
    }
}


/***********************************************
 * Hidden Checkbox Calculations
 ***********************************************/
function runAllHiddenCheckboxCalculations(){
    if(!hiddenCheckboxCalculations || hiddenCheckboxCalculations.length===0) return;
    for(var i=0; i<hiddenCheckboxCalculations.length; i++){
        runSingleHiddenCheckboxCalculation(hiddenCheckboxCalculations[i]);
    }
}

function runSingleHiddenCheckboxCalculation(calcObj){
    var cbox = document.getElementById(calcObj.hiddenFieldName);
    if(!cbox) return;  // hidden field not found

    var finalState = cbox.checked;  // start with default

    // Evaluate each multi-term condition in 'calculations'
    for(var c=0; c<calcObj.calculations.length; c++){
        var oneCalc = calcObj.calculations[c];
        var val = 0;

        // Sum up the terms
        if(oneCalc.terms && oneCalc.terms.length>0){
            val = parseFloat( getMoneyValue(oneCalc.terms[0].questionNameId) )||0;
            for(var t=1; t<oneCalc.terms.length; t++){
                var term = oneCalc.terms[t];
                var op   = term.operator||'';
                var nextVal = parseFloat(getMoneyValue(term.questionNameId))||0;

                if(op==='+') val += nextVal;
                else if(op==='-') val -= nextVal;
                else if(op==='x') val *= nextVal;
                else if(op==='/'){
                    if(nextVal!==0) val /= nextVal;
                    else val=0;
                }
            }
        }

        // Compare val to threshold
        var thr = parseFloat(oneCalc.threshold)||0;
        var matched = false;
        if(oneCalc.compareOperator==='=') matched = (val===thr);
        else if(oneCalc.compareOperator==='<') matched = (val<thr);
        else if(oneCalc.compareOperator==='>') matched = (val>thr);

        // If matched, set final state
        if(matched){
            finalState = (oneCalc.result==='checked');
        }
    }

    // Set the hidden checkbox state
    cbox.checked = finalState;
}


/***********************************************
 * Hidden Text Calculations (with placeholders)
 ***********************************************/
function runAllHiddenTextCalculations(){
    if(!hiddenTextCalculations || hiddenTextCalculations.length===0) return;
    for(var i=0; i<hiddenTextCalculations.length; i++){
        runSingleHiddenTextCalculation(hiddenTextCalculations[i]);
    }
}

/**
 * Evaluate each multi-term calculation and set the hidden text field.
 * If fillValue format is "##fieldName##", we store the numeric sum of the terms
 * using the field's own name (or any other field name).
 */
function runSingleHiddenTextCalculation(calcObj) {
    const textField = document.getElementById(calcObj.hiddenFieldName);
    if (!textField) return;

    // We'll assume that the last matched condition takes precedence
    let finalValue = "";

    calcObj.calculations.forEach(function(oneCalc) {
        let val = 0;
        
        // Calculate the sum of all terms
        if (oneCalc.terms && oneCalc.terms.length > 0) {
            // Get the first term's value
            const firstTerm = oneCalc.terms[0];
            val = parseFloat(getMoneyValue(firstTerm.questionNameId)) || 0;

            // Process remaining terms
            for (let t = 1; t < oneCalc.terms.length; t++) {
                const term = oneCalc.terms[t];
                const termVal = parseFloat(getMoneyValue(term.questionNameId)) || 0;

                switch(term.operator) {
                    case '+': val += termVal; break;
                    case '-': val -= termVal; break;
                    case 'x': val *= termVal; break;
                    case '/': val = termVal !== 0 ? val / termVal : 0; break;
                }
            }
        }

        // Compare to threshold
        const threshold = parseFloat(oneCalc.threshold) || 0;
        let matched = false;

        switch(oneCalc.compareOperator) {
            case '>': matched = val > threshold; break;
            case '<': matched = val < threshold; break;
            case '=': matched = Math.abs(val - threshold) < 0.000001; break; // Use epsilon for float comparison
        }

        if (matched) {
            // Handle special fillValue formats
            if (oneCalc.fillValue === "##total##" || oneCalc.fillValue.match(/^##(.+)##$/)) {
                finalValue = val.toFixed(2); // Format money values with 2 decimal places
            } else {
                finalValue = oneCalc.fillValue;
            }
        }
    });

    // Update the text field
    textField.value = finalValue;
}

function replacePlaceholderTokens (str){
    /* note the doubled back-slashes in the delimiters $$ */
    return str.replace(/\$\$(.*?)\$\$/g, function (_match, innerExpr){
        return evaluatePlaceholderExpression(innerExpr);
    });
}

function evaluatePlaceholderExpression (exprString){
    /* split on +  -  x  /   (all kept as separate tokens) */
    var tokens = exprString.split(/([+-x/])/);          // ← every  is **doubled**
    if (!tokens.length) return '0';

    var currentVal = parseTokenValue(tokens[0]);
    for (var i = 1; i < tokens.length; i += 2){
        var op   = tokens[i];
        var next = parseTokenValue(tokens[i + 1] || '0');

        if      (op === '+') currentVal += next;
        else if (op === '-') currentVal -= next;
        else if (op === 'x') currentVal *= next;
        else if (op === '/') currentVal  = next !== 0 ? currentVal / next : 0;
    }
    return currentVal.toString();
}

function parseTokenValue(token){
    token = token.trim();
    if(!token) return 0;
    var el= document.getElementById(token);
    if(!el) return 0;
    var val= parseFloat(el.value);
    return isNaN(val) ? 0 : val;
}

/*───────────────────────────────────────────────────────────────*
 * 3.  getMoneyValue(qId)
 *     – tiny regex fix so legacy "amountX_Y_Z" can still resolve
 *       (note the escaped \d+ instead of stray 'd').
 *───────────────────────────────────────────────────────────────*/
function getMoneyValue(qId) {
    /* direct hit first */
    const el = document.getElementById(qId);
    if (el) {
        if (el.type === "checkbox") {
            const amt = document.getElementById(el.id + "_amount");
            if (amt && el.checked) return parseFloat(amt.value) || 0;
            return el.checked ? 1 : 0;
        }
        return parseFloat(el.value) || 0;
    }

    /* legacy builder‑shorthand amountX_Y_Z */
    if (/^amountd+_d+_.+/.test(qId)) {
        const el2 = document.getElementById(normaliseDesignerFieldRef(qId));
        if (el2) return parseFloat(el2.value) || 0;
    }

    /* name‑attribute fallback */
    const byName = document.getElementsByName(qId);
    if (byName.length) return parseFloat(byName[0].value) || 0;

    return 0;
}




function attachCalculationListeners() {
    // Universal function to attach listeners in a consistent way
    function attachListenersToCalculationTerms(calculations, runCalculationFunction) {
        for (let i = 0; i < calculations.length; i++) {
            const calcObj = calculations[i];
            for (let c = 0; c < calcObj.calculations.length; c++) {
                const oneCalc = calcObj.calculations[c];
                const terms = oneCalc.terms || [];
                
                for (let t = 0; t < terms.length; t++) {
                    const qNameId = terms[t].questionNameId;
                    
                    // 1. Try direct element
                    const el = document.getElementById(qNameId);
                    if (el) {
                        el.addEventListener('change', runCalculationFunction);
                        el.addEventListener('input', runCalculationFunction);
                        
                        // If it's a checkbox, also listen to its amount field
                        if (el.type === 'checkbox') {
                            const amountField = document.getElementById(el.id + '_amount');
                            if (amountField) {
                                amountField.addEventListener('input', runCalculationFunction);
                            }
                        }
                        continue; // Found and attached, go to next term
                    }
                    
                    // 2. Try elements with this name
                    const namedElements = document.getElementsByName(qNameId);
                    if (namedElements.length > 0) {
                        for (let n = 0; n < namedElements.length; n++) {
                            namedElements[n].addEventListener('change', runCalculationFunction);
                            namedElements[n].addEventListener('input', runCalculationFunction);
                        }
                        continue;
                    }
                    
                    // 3. Look for prefixed IDs like "answerX_qId"
                    const prefixPattern = new RegExp('.*_' + qNameId + '$');
                    const allInputs = document.querySelectorAll('input, select, textarea');
                    
                    for (let inp = 0; inp < allInputs.length; inp++) {
                        const input = allInputs[inp];
                        if (prefixPattern.test(input.id)) {
                            input.addEventListener('change', runCalculationFunction);
                            input.addEventListener('input', runCalculationFunction);
                            
                            // If it's a checkbox with amount field
                            if (input.type === 'checkbox') {
                                const amountField = document.getElementById(input.id + '_amount');
                                if (amountField) {
                                    amountField.addEventListener('input', runCalculationFunction);
                                }
                            }
                        }
                    }
                    
                    // 4. Look specifically for amount fields with this name
                    const amountElements = document.querySelectorAll('input[name="' + qNameId + '"]');
                    for (let a = 0; a < amountElements.length; a++) {
                        amountElements[a].addEventListener('input', runCalculationFunction);
                        
                        // Also find and attach to the controlling checkbox
                        if (amountElements[a].id.includes('_amount')) {
                            const checkboxId = amountElements[a].id.replace('_amount', '');
                            const checkbox = document.getElementById(checkboxId);
                            if (checkbox) {
                                checkbox.addEventListener('change', runCalculationFunction);
                            }
                        }
                    }
                    
                    // 5. Try direct amount field
                    const directAmountField = document.getElementById(qNameId + '_amount');
                    if (directAmountField) {
                        directAmountField.addEventListener('input', runCalculationFunction);
                        
                        // Find the checkbox controlling this amount field
                        const checkboxSelector = 'input[type="checkbox"][onchange*="' + directAmountField.id + '"]';
                        const checkbox = document.querySelector(checkboxSelector);
                        if (checkbox) {
                            checkbox.addEventListener('change', runCalculationFunction);
                        }
                    }
                }
            }
        }
    }
    
    // For hidden checkbox calculations
    if (hiddenCheckboxCalculations && hiddenCheckboxCalculations.length > 0) {
        const runAllCheckboxCalcs = function() {
            runAllHiddenCheckboxCalculations();
        };
        attachListenersToCalculationTerms(hiddenCheckboxCalculations, runAllCheckboxCalcs);
    }
    
    // For hidden text calculations
    if (hiddenTextCalculations && hiddenTextCalculations.length > 0) {
        const runAllTextCalcs = function() {
            runAllHiddenTextCalculations();
        };
        attachListenersToCalculationTerms(hiddenTextCalculations, runAllTextCalcs);
    }
    
    // Run calculations once on page load to set initial values
    runAllHiddenCheckboxCalculations();
    runAllHiddenTextCalculations();
}

// Progress Bar Logic
function updateProgressBar() {
  // Stepper logic
  const stepper = document.getElementById('stepperProgressBar');
  if (!stepper) return;
  const steps = stepper.querySelectorAll('.stepper-step');
  
  // Check if we're using group-based progress
  if (window.groupToSectionMap && window.sectionToGroupMap) {
    // Group-based progress bar
    let activeGroupStep = 1;
    
    if (typeof currentSectionNumber === 'number') {
      // Find which section we're currently on
      const currentSectionEl = document.querySelector('#section' + currentSectionNumber);
      if (currentSectionEl) {
        const sectionTitleEl = currentSectionEl.querySelector('.section-title');
        if (sectionTitleEl) {
          const currentSectionName = sectionTitleEl.textContent.trim();
          const currentGroupId = window.sectionToGroupMap[currentSectionName];
          if (currentGroupId) {
            // Find the step number for this group
            const groupIds = Object.keys(window.groupToSectionMap).sort((a, b) => parseInt(a) - parseInt(b));
            activeGroupStep = groupIds.indexOf(currentGroupId) + 1;
          }
        }
      }
    } else if (currentSectionNumber === 'end') {
      activeGroupStep = steps.length;
    }
    
    steps.forEach((step, idx) => {
      step.classList.remove('active', 'completed');
      if (idx + 1 < activeGroupStep) {
        step.classList.add('completed');
      } else if (idx + 1 === activeGroupStep) {
        step.classList.add('active');
      }
    });
    
    // Animate lines between completed steps
    const lines = stepper.querySelectorAll('.stepper-line');
    lines.forEach((line, idx) => {
      if (idx < activeGroupStep - 1) {
        line.classList.add('filled');
      } else {
        line.classList.remove('filled');
      }
    });
  } else {
    // Section-based progress bar (fallback)
    let activeStep = 1;
    if (typeof currentSectionNumber === 'number') {
      activeStep = currentSectionNumber;
    } else if (currentSectionNumber === 'end') {
      activeStep = steps.length;
    }
    steps.forEach((step, idx) => {
      step.classList.remove('active', 'completed');
      if (idx + 1 < activeStep) {
        step.classList.add('completed');
      } else if (idx + 1 === activeStep) {
        step.classList.add('active');
      }
    });
    // Animate lines between completed steps
    const lines = stepper.querySelectorAll('.stepper-line');
    lines.forEach((line, idx) => {
      if (idx < activeStep - 1) {
        line.classList.add('filled');
      } else {
        line.classList.remove('filled');
      }
    });
  }
}

// Animate the progress bar fill width smoothly
function animateProgressBarFill(fillEl, targetPercent) {
  if (!fillEl) return;
  // Cancel any previous animation
  if (fillEl._progressAnimFrame) {
    cancelAnimationFrame(fillEl._progressAnimFrame);
    fillEl._progressAnimFrame = null;
  }
  const currentWidth = parseFloat(fillEl.style.width) || 0;
  const start = currentWidth;
  const end = targetPercent;
  const duration = 500; // ms, should match CSS transition
  const startTime = performance.now();

  function animate(now) {
    const elapsed = now - startTime;
    const t = Math.min(elapsed / duration, 1);
    // Use easeInOutCubic for a nice effect
    const ease = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    const newWidth = start + (end - start) * ease;
    fillEl.style.width = newWidth + '%';
    if (t < 1) {
      fillEl._progressAnimFrame = requestAnimationFrame(animate);
    } else {
      fillEl.style.width = end + '%';
      fillEl._progressAnimFrame = null;
    }
  }
  requestAnimationFrame(animate);
}

document.addEventListener('DOMContentLoaded', function() {
  updateProgressBar();
});

// Modal logic
function showLoginRequiredModal() {
  document.getElementById('loginRequiredModal').style.display = 'flex';
}
function hideLoginRequiredModal() {
  document.getElementById('loginRequiredModal').style.display = 'none';
}
document.addEventListener('DOMContentLoaded', function() {
  var backBtn = document.getElementById('modalBackBtn');
  var contBtn = document.getElementById('modalContinueBtn');
  if (backBtn) backBtn.onclick = hideLoginRequiredModal;
  if (contBtn) contBtn.onclick = function() {
    window.location.href = '../Pages/account.html';
  };
});

// Patch handleNext to check login before advancing
if (typeof handleNext === 'function') {
  var originalHandleNext = handleNext;
  window.handleNext = function(currentSection) {
    if (!isUserLoggedIn) {
      showLoginRequiredModal();
      return;
    }
    originalHandleNext(currentSection);
  };
}

// AUTOSAVE, RESTORE, AND WIPE LOGIC FOR ALL GENERATED FORMS
(function() {
    // Wait for Firebase and DOM
    function onReady(fn) {
        if (document.readyState !== 'loading') fn();
        else document.addEventListener('DOMContentLoaded', fn);
    }
    onReady(function() {
        if (typeof firebase === 'undefined' || !firebase.auth || !firebase.firestore) return;
        const db = firebase.firestore();
        const urlParams = new URLSearchParams(window.location.search);
        const baseFormId = urlParams.get('formId') || window.formId || 'default';
        const county = urlParams.get('county') || '';
        const portfolioId = urlParams.get('portfolioId') || '';
        // Create a unique form ID that includes county and portfolio information for autosave separation
        let formId = baseFormId;
        if (county) formId += '_' + county.replace(/s+/g, '_');
        if (portfolioId) formId += '_' + portfolioId;
        let userId = null;
        let isUserLoggedIn = false;



        // Helper: get all form fields to save
        function getFormFields() {
            const form = document.getElementById('customForm');
            if (!form) {
                return [];
            }
            const fields = Array.from(form.elements).filter(el =>
                el.name &&
                !el.disabled &&
                ['INPUT', 'TEXTAREA', 'SELECT'].includes(el.tagName) &&
                !['hidden', 'button', 'submit', 'reset'].includes(el.type)
            );
            return fields;
        }

        // Helper: save answers
        async function saveAnswers() {
            if (!isUserLoggedIn || !userId) return;
            const fields = getFormFields();
            const answers = {};
            fields.forEach(el => {
                if (el.type === 'checkbox' || el.type === 'radio') {
                    answers[el.name] = el.checked;
                } else {
                    answers[el.name] = el.value;
                }
            });
            
   
            
            await db.collection('users').doc(userId).collection('formAnswers').doc(formId).set(answers, { merge: true });
            
            
        }

        // Helper function to check paragraph limits for autofilled textareas
        function triggerParagraphLimitCheckForAutofilledTextareas() {
            
            // Find all textareas and check if they need paragraph limit checking
            const textareas = document.querySelectorAll('textarea');
            textareas.forEach(textarea => {
                if (textarea.value && textarea.value.length > 0) {
                    // Check if this textarea has a paragraph limit by looking for the checkParagraphLimit function
                    // We'll trigger the oninput event which will call checkParagraphLimit if it's set up
                    const event = new Event('input', { bubbles: true });
                    textarea.dispatchEvent(event);
                }
            });
        }

        // Helper function to trigger line splitting for autofilled textareas
        function triggerLineSplittingForAutofilledTextareas() {
            
            // Find all textareas that have a line limit data attribute
            const textareas = document.querySelectorAll('textarea[data-line-limit]');
            textareas.forEach(textarea => {
                const lineLimit = parseInt(textarea.getAttribute('data-line-limit'));
                if (lineLimit && textarea.value && textarea.value.length > 0) {
                    
                    // Call the handleLineSplitting function if it exists
                    if (typeof handleLineSplitting === 'function') {
                        handleLineSplitting(textarea.id, lineLimit);
                    } else {
                        // Fallback: manually trigger the line splitting logic
                        const text = textarea.value;
                        const totalChars = text.length;
                        const linesNeeded = Math.ceil(totalChars / lineLimit);
                        
                        console.log('🔧 [LINE SPLITTING DEBUG] Creating', linesNeeded, 'hidden textboxes for textarea:', textarea.id);
                        
                        // Create or update hidden textboxes for each line
                        for (let i = 1; i <= linesNeeded; i++) {
                            const startIndex = (i - 1) * lineLimit;
                            const endIndex = Math.min(startIndex + lineLimit, totalChars);
                            const lineText = text.substring(startIndex, endIndex);
                            
                            const hiddenInputId = textarea.id + '_line' + i;
                            let hiddenInput = document.getElementById(hiddenInputId);
                            
                            if (!hiddenInput) {
                                // Create new hidden input
                                hiddenInput = document.createElement('input');
                                hiddenInput.type = 'hidden';
                                hiddenInput.id = hiddenInputId;
                                hiddenInput.name = hiddenInputId;
                                textarea.parentNode.appendChild(hiddenInput);
                                console.log('🔧 [LINE SPLITTING DEBUG] Created hidden input:', hiddenInputId);
                            }
                            
                            hiddenInput.value = lineText;
                            console.log('🔧 [LINE SPLITTING DEBUG] Set value for', hiddenInputId, 'to:', lineText);
                        }
                        
                        // Remove any extra hidden inputs that are no longer needed
                        let lineNum = linesNeeded + 1;
                        while (true) {
                            const extraInput = document.getElementById(textarea.id + '_line' + lineNum);
                            if (extraInput) {
                                extraInput.remove();
                                console.log('🔧 [LINE SPLITTING DEBUG] Removed extra hidden input:', textarea.id + '_line' + lineNum);
                                lineNum++;
                            } else {
                                break;
                            }
                        }
                    }
                }
            });
        }

        // Helper: load answers
        async function loadAnswers() {
            console.log('🔧 [AUTOFILL DEBUG] loadAnswers() called - isUserLoggedIn:', isUserLoggedIn, 'userId:', userId, 'formId:', formId);
            if (!isUserLoggedIn || !userId) {
                console.log('🔧 [AUTOFILL DEBUG] Skipping loadAnswers - user not logged in or no userId');
                return;
            }
            try {
                // First, try to load user profile data from a user profile document
                console.log('🔧 [AUTOFILL DEBUG] Attempting to fetch user profile data...');
                const userProfileDoc = await db.collection('users').doc(userId).get();
                console.log('🔧 [AUTOFILL DEBUG] User profile document exists:', userProfileDoc.exists);
                
                let userProfileData = {};
                if (userProfileDoc.exists) {
                    userProfileData = userProfileDoc.data();
                    console.log('🔧 [AUTOFILL DEBUG] User profile data loaded:', userProfileData);
                }
                
                // Then, try to load form-specific data
                console.log('🔧 [AUTOFILL DEBUG] Attempting to fetch Firebase document for formId:', formId);
                const doc = await db.collection('users').doc(userId).collection('formAnswers').doc(formId).get();
                console.log('🔧 [AUTOFILL DEBUG] Firebase document exists:', doc.exists);
                
                let formData = {};
                if (doc.exists) {
                    formData = doc.data();
                    console.log('🔧 [AUTOFILL DEBUG] Form data loaded:', formData);
                }
                
                // Combine user profile data with form data
                const data = { ...userProfileData, ...formData };
                console.log('🔧 [AUTOFILL DEBUG] Combined data (user profile + form):', data);
                
                // Helper function to map Firebase data to form field names
                function mapFirebaseDataToFormFields(firebaseData) {
                    const mappedData = { ...firebaseData };
                    
                    // Map user info fields from Firebase structure to form field names
                    if (firebaseData.firstName) mappedData.user_firstname = firebaseData.firstName;
                    if (firebaseData.lastName) mappedData.user_lastname = firebaseData.lastName;
                    if (firebaseData.email) mappedData.user_email = firebaseData.email;
                    if (firebaseData.phone) mappedData.user_phone = firebaseData.phone;
                    
                    // Map address fields
                    if (firebaseData.address) {
                        if (firebaseData.address.street) mappedData.user_street = firebaseData.address.street;
                        if (firebaseData.address.city) mappedData.user_city = firebaseData.address.city;
                        if (firebaseData.address.state) mappedData.user_state = firebaseData.address.state;
                        if (firebaseData.address.zip) mappedData.user_zip = firebaseData.address.zip;
                    }
                    
                    console.log('🔧 [AUTOFILL DEBUG] Mapped data for form fields:', mappedData);
                    return mappedData;
                }
                
                const mappedData = mapFirebaseDataToFormFields(data);
                    const fields = getFormFields();
                    fields.forEach(el => {
                    if (mappedData.hasOwnProperty(el.name)) {
                            // Check if this answer would trigger a jump to the end
                        if (wouldTriggerJumpToEnd(el, mappedData[el.name])) {
                                // Don't autofill this answer - keep it as default
                                console.log('Skipping autofill for ' + el.name + ' as it would trigger jump to end');
                                return;
                            }
                            
                        console.log('🔧 [AUTOFILL DEBUG] Autofilling field:', el.name, 'with value:', mappedData[el.name]);
                            if (el.type === 'checkbox' || el.type === 'radio') {
                            el.checked = !!mappedData[el.name];
                            } else {
                            el.value = mappedData[el.name];
                            }
                        }
                    });
                    
                    // After autofilling, trigger visibility updates for dependent questions
                    // Use a longer delay to ensure conditional logic scripts are fully loaded and executed
                    setTimeout(() => {
                        console.log('🔧 [VISIBILITY DEBUG] Starting visibility updates after autofill...');
                        
                        // Trigger change events on all autofilled elements to ensure conditional logic runs
                        fields.forEach(el => {
                            if (el.value || el.checked) {
                                console.log('🔧 [VISIBILITY DEBUG] Triggering change event on autofilled element:', el.id || el.name);
                                const event = new Event('change', { bubbles: true });
                                el.dispatchEvent(event);
                            }
                        });
                        
                        // Also call the global visibility updates function
                        if (typeof triggerVisibilityUpdates === 'function') {
                            triggerVisibilityUpdates();
                        }
                    }, 2000);
                    
                    // Trigger numbered dropdown textbox generation for any numbered dropdowns that were autofilled
                    fields.forEach(el => {
                        if (el.tagName === 'SELECT' && el.id.startsWith('answer') && el.value) {
                            const questionId = el.id.replace('answer', '');
                            if (typeof showTextboxLabels === 'function') {
                                showTextboxLabels(questionId, el.value);
                            }
                            if (typeof updateHiddenCheckboxes === 'function') {
                                updateHiddenCheckboxes(questionId, el.value);
                            }
                        }
                    });
                    
                    // Trigger state hidden field updates for any state dropdowns that were autofilled
                    fields.forEach(el => {
                        if (el.tagName === 'SELECT' && el.id && el.value && el.classList.contains('address-select')) {
                            // This is a state dropdown that was autofilled
                            const hiddenFullId = el.id; // Keep the full ID with number
                            const hiddenShortId = hiddenFullId + '_short';
                            if (typeof updateStateHiddenFields === 'function') {
                                updateStateHiddenFields(el, hiddenFullId, hiddenShortId);
                            }
                        }
                    });
                    
                    // Trigger hidden checkbox generation for any regular dropdowns that were autofilled
                    fields.forEach(el => {
                        if (el.tagName === 'SELECT' && el.id && !el.id.startsWith('answer') && el.value) {
                            console.log('🔧 [AUTOFILL DEBUG] Triggering dropdownMirror for regular dropdown:', el.id, 'with value:', el.value);
                            if (typeof dropdownMirror === 'function') {
                                dropdownMirror(el, el.id);
                            }
                            // Trigger hidden logic for autofilled dropdowns
                            if (typeof updateHiddenLogic === 'function') {
                                updateHiddenLogic(el.id, el.value);
                            }
                        }
                    });
                    
                    // Create hidden checkboxes for all autofilled dropdowns
                    if (typeof createHiddenCheckboxesForAutofilledDropdowns === 'function') {
                        createHiddenCheckboxesForAutofilledDropdowns();
                    }
                    
                    // Trigger line splitting for autofilled textareas
                    triggerLineSplittingForAutofilledTextareas();
                    
                    // Trigger paragraph limit checking for autofilled textareas
                    triggerParagraphLimitCheckForAutofilledTextareas();
                    
                    // Second autofill pass for dynamically generated textbox inputs
                    // Use a longer delay to ensure textbox inputs are fully generated
                    setTimeout(() => {
                        console.log('🔧 [AUTOFILL DEBUG] Starting second autofill pass for dynamically generated inputs');
                        const allFields = getFormFields();
                        console.log('🔧 [AUTOFILL DEBUG] Found', allFields.length, 'total form fields');
                        
                        // Also try to find fields by ID directly as a fallback
                        const fieldsById = {};
                        allFields.forEach(el => {
                            if (el.id) {
                                fieldsById[el.id] = el;
                            }
                        });
                        
                        allFields.forEach(el => {
                            if (mappedData.hasOwnProperty(el.name)) {
                                console.log('🔧 [AUTOFILL DEBUG] Autofilling field:', el.name, 'with value:', mappedData[el.name]);
                                if (el.type === 'checkbox' || el.type === 'radio') {
                                    el.checked = !!mappedData[el.name];
                                } else {
                                    el.value = mappedData[el.name];
                                    console.log('🔧 [AUTOFILL DEBUG] Set value for', el.name, 'to:', el.value);
                                }
                            }
                        });
                        
                        // Additional pass: try to autofill by ID for any fields that might have been missed
                        Object.keys(mappedData).forEach(fieldName => {
                            const fieldById = fieldsById[fieldName];
                            if (fieldById && !fieldById.value && mappedData[fieldName]) {
                                console.log('🔧 [AUTOFILL DEBUG] Additional autofill by ID for:', fieldName, 'with value:', mappedData[fieldName]);
                                if (fieldById.type === 'checkbox' || fieldById.type === 'radio') {
                                    fieldById.checked = !!mappedData[fieldName];
                                } else {
                                    fieldById.value = mappedData[fieldName];
                                    console.log('🔧 [AUTOFILL DEBUG] Set value by ID for', fieldName, 'to:', fieldById.value);
                                }
                            }
                        });
                        
                        // Trigger line splitting again after the second autofill pass
                        triggerLineSplittingForAutofilledTextareas();
                        
                        // Trigger paragraph limit checking again after the second autofill pass
                        triggerParagraphLimitCheckForAutofilledTextareas();
                        
                        // Trigger state hidden field updates for any state dropdowns that were autofilled in second pass
                        allFields.forEach(el => {
                            if (el.tagName === 'SELECT' && el.id && el.value && el.classList.contains('address-select')) {
                                // This is a state dropdown that was autofilled
                                const hiddenFullId = el.id; // Keep the full ID with number
                                const hiddenShortId = hiddenFullId + '_short';
                                if (typeof updateStateHiddenFields === 'function') {
                                    updateStateHiddenFields(el, hiddenFullId, hiddenShortId);
                                }
                            }
                        });
                    }, 1500);
                    
                        // Reset hidden questions to defaults after autofill and visibility updates
                        if (typeof currentSectionNumber === 'number') {
                            resetHiddenQuestionsToDefaults(currentSectionNumber);
                }
            } catch (e) {
                console.log('🔧 [AUTOFILL DEBUG] Error in loadAnswers:', e);
            }
        }
        

        
        // Helper: check if an answer would trigger a jump to the end
        function wouldTriggerJumpToEnd(element, answerValue) {
            if (!jumpLogics || jumpLogics.length === 0) return false;
            
            // Find the question ID for this element
            let questionId = null;
            for (const [qId, nameId] of Object.entries(questionNameIds)) {
                if (element.name === nameId || element.id === nameId) {
                    questionId = qId;
                    break;
                }
            }
            
            if (!questionId) return false;
            
            // Check if there's a jump logic for this question that would go to 'end'
            const relevantJumps = jumpLogics.filter(jl => jl.questionId === questionId);
            for (const jl of relevantJumps) {
                if (jl.jumpTo.toLowerCase() === 'end') {
                    // Check if the answer matches the jump condition
                    if (jl.questionType === 'dropdown' || jl.questionType === 'radio' || jl.questionType === 'numberedDropdown') {
                        if (answerValue.toString().toLowerCase() === jl.jumpOption.trim().toLowerCase()) {
                            return true;
                        }
                    } else if (jl.questionType === 'checkbox') {
                        if (answerValue.toString().toLowerCase() === jl.jumpOption.trim().toLowerCase()) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }

        // Helper: wipe answers
        function wipeAnswers() {
            if (!isUserLoggedIn || !userId) return;
            db.collection('users').doc(userId).collection('formAnswers').doc(formId).delete();
        }

        // Attach listeners to all fields
        function attachAutosaveListeners() {
            const fields = getFormFields();
            fields.forEach(el => {
                el.addEventListener('input', function() {
                    if (isUserLoggedIn) {
                        saveAnswers();
                    } else {
                        saveAnswersToLocalStorage();
                    }
                    
                    // Update full name if first or last name changed
                    if (el.id === 'user_firstname' || el.id === 'user_lastname') {
                        if (typeof updateUserFullName === 'function') {
                            updateUserFullName();
                        }
                    }
                });
                el.addEventListener('change', function() {
                    if (isUserLoggedIn) {
                        saveAnswers();
                    } else {
                        saveAnswersToLocalStorage();
                    }
                    
                    // Update full name if first or last name changed
                    if (el.id === 'user_firstname' || el.id === 'user_lastname') {
                        if (typeof updateUserFullName === 'function') {
                            updateUserFullName();
                        }
                    }
                });
            });
            
            // Set up periodic autosave every 1 second
            setInterval(() => {
                if (isUserLoggedIn) {
                    saveAnswers();
                } else {
                    saveAnswersToLocalStorage();
                }
            }, 1000);
        }
        

























        
        // Cart Modal Logic - now handled by global functions outside Firebase IIFE

        // Helper: save answers to localStorage for non-logged-in users
        function saveAnswersToLocalStorage() {
            try {
                const fields = getFormFields();
                const answers = {};
                fields.forEach(el => {
                    if (el.type === 'checkbox' || el.type === 'radio') {
                        answers[el.name] = el.checked;
                    } else {
                        answers[el.name] = el.value;
                    }
                });
                
                localStorage.setItem('formData_' + formId, JSON.stringify(answers));
            } catch (e) {
                console.log('Error saving to localStorage:', e);
            }
        }

        // Helper: load answers from localStorage for non-logged-in users
        function loadAnswersFromLocalStorage() {
            try {
                const savedData = localStorage.getItem('formData_' + formId);
                if (savedData) {
                    const data = JSON.parse(savedData);
                    const fields = getFormFields();
                    fields.forEach(el => {
                        if (data.hasOwnProperty(el.name)) {
                            if (el.type === 'checkbox' || el.type === 'radio') {
                                el.checked = !!data[el.name];
                            } else {
                                el.value = data[el.name];
                            }
                        }
                    });
                    
                    // Update full name after autofilling with delay to ensure DOM is ready
                    setTimeout(() => {
                        if (typeof updateUserFullName === 'function') {
                            updateUserFullName();
                        }
                    }, 2000);
                    
                    // Trigger visibility updates for dependent questions
                    setTimeout(() => {
                        
                        // Trigger change events on all autofilled elements to ensure conditional logic runs
                        const fields = getFormFields();
                        fields.forEach(el => {
                            if (el.value || el.checked) {
                                const event = new Event('change', { bubbles: true });
                                el.dispatchEvent(event);
                            }
                        });
                        
                        // Also call the global visibility updates function
                        if (typeof triggerVisibilityUpdates === 'function') {
                            triggerVisibilityUpdates();
                        }
                        
                        // Trigger numbered dropdown textbox generation for any numbered dropdowns that were autofilled
                        fields.forEach(el => {
                            if (el.tagName === 'SELECT' && el.id.startsWith('answer') && el.value) {
                                const questionId = el.id.replace('answer', '');
                                if (typeof showTextboxLabels === 'function') {
                                    showTextboxLabels(questionId, el.value);
                                }
                                if (typeof updateHiddenCheckboxes === 'function') {
                                    updateHiddenCheckboxes(questionId, el.value);
                                }
                            }
                        });
                        
                        // Trigger state hidden field updates for any state dropdowns that were autofilled
                        fields.forEach(el => {
                            if (el.tagName === 'SELECT' && el.id && el.value && el.classList.contains('address-select')) {
                                // This is a state dropdown that was autofilled
                                const hiddenFullId = el.id; // Keep the full ID with number
                                const hiddenShortId = hiddenFullId + '_short';
                                if (typeof updateStateHiddenFields === 'function') {
                                    updateStateHiddenFields(el, hiddenFullId, hiddenShortId);
                                }
                            }
                        });
                        
                        // Trigger hidden checkbox generation for any regular dropdowns that were autofilled
                        fields.forEach(el => {
                            if (el.tagName === 'SELECT' && el.id && !el.id.startsWith('answer') && el.value) {
                                if (typeof dropdownMirror === 'function') {
                                    dropdownMirror(el, el.id);
                                }
                                // Trigger hidden logic for autofilled dropdowns
                                if (typeof updateHiddenLogic === 'function') {
                                    updateHiddenLogic(el.id, el.value);
                                }
                            }
                        });
                        
                        // Create hidden checkboxes for all autofilled dropdowns
                        if (typeof createHiddenCheckboxesForAutofilledDropdowns === 'function') {
                            createHiddenCheckboxesForAutofilledDropdowns();
                        }
                        
                        // Trigger line splitting for autofilled textareas
                        triggerLineSplittingForAutofilledTextareas();
                        
                        // Trigger paragraph limit checking for autofilled textareas
                        triggerParagraphLimitCheckForAutofilledTextareas();
                        
                        // Second autofill pass for dynamically generated textbox inputs
                        // Use a longer delay to ensure textbox inputs are fully generated
                        setTimeout(() => {
                            const allFields = getFormFields();
                            
                            // Also try to find fields by ID directly as a fallback
                            const fieldsById = {};
                            allFields.forEach(el => {
                                if (el.id) {
                                    fieldsById[el.id] = el;
                                }
                            });
                            
                            allFields.forEach(el => {
                                if (data.hasOwnProperty(el.name)) {
                                    if (el.type === 'checkbox' || el.type === 'radio') {
                                        el.checked = !!data[el.name];
                                    } else {
                                        el.value = data[el.name];
                                        console.log('🔧 [LOCALSTORAGE AUTOFILL DEBUG] Set value for', el.name, 'to:', el.value);
                                    }
                                }
                            });
                            
                            // Additional pass: try to autofill by ID for any fields that might have been missed
                            Object.keys(data).forEach(fieldName => {
                                const fieldById = fieldsById[fieldName];
                                if (fieldById && !fieldById.value && data[fieldName]) {
                                    console.log('🔧 [LOCALSTORAGE AUTOFILL DEBUG] Additional autofill by ID for:', fieldName, 'with value:', data[fieldName]);
                                    if (fieldById.type === 'checkbox' || fieldById.type === 'radio') {
                                        fieldById.checked = !!data[fieldName];
                                    } else {
                                        fieldById.value = data[fieldName];
                                        console.log('🔧 [LOCALSTORAGE AUTOFILL DEBUG] Set value by ID for', fieldName, 'to:', fieldById.value);
                                    }
                                }
                            });
                            
                            // Trigger line splitting again after the second autofill pass
                            triggerLineSplittingForAutofilledTextareas();
                            
                            // Trigger paragraph limit checking again after the second autofill pass
                            triggerParagraphLimitCheckForAutofilledTextareas();
                            
                            // Trigger state hidden field updates for any state dropdowns that were autofilled in second pass
                            allFields.forEach(el => {
                                if (el.tagName === 'SELECT' && el.id && el.value && el.classList.contains('address-select')) {
                                    // This is a state dropdown that was autofilled
                                    const hiddenFullId = el.id; // Keep the full ID with number
                                    const hiddenShortId = hiddenFullId + '_short';
                                    if (typeof updateStateHiddenFields === 'function') {
                                        updateStateHiddenFields(el, hiddenFullId, hiddenShortId);
                                    }
                                }
                            });
                        }, 1500);
                    }, 2000);
                }
            } catch (e) {
                console.log('No localStorage data found or error loading:', e);
            }
        }

        // On auth state change
        firebase.auth().onAuthStateChanged(function(user) {
            isUserLoggedIn = !!user;
            userId = user ? user.uid : null;
            if (isUserLoggedIn) {
                const params = new URLSearchParams(window.location.search);
                if (params.get('payment') === 'success') {
                    console.log('Payment successful! Processing PDF...');
                    loadAnswers().then(() => {
                        processAllPdfs().then(() => {
                            wipeAnswers();
                            window.history.replaceState({}, document.title, "/" + pdfOutputFileName);
                            navigateSection('end');
                        });
                    });
                } else {
                    loadAnswers().then(attachAutosaveListeners);
                }
            } else {
                // For non-logged-in users, try to load from localStorage
                loadAnswersFromLocalStorage();
                attachAutosaveListeners();
            }
        });

        // Form submission now shows thank you message first, then user can continue to cart

        // Update cart count
        function updateCartCount() {
            const cartCountElement = document.getElementById('cart-count');
            if (cartCountElement && typeof getCartCount === 'function') {
                const count = getCartCount();
                cartCountElement.textContent = count;
                cartCountElement.style.display = count > 0 ? 'inline' : 'none';
            }
        }

        // Update cart count on page load and periodically
        document.addEventListener('DOMContentLoaded', function() {
            updateCartCount();
            // Update cart count every 5 seconds
            setInterval(updateCartCount, 5000);
        });
    });
})();

    // Header functionality
    document.addEventListener('DOMContentLoaded', function() {
        // Use existing Firebase instance instead of creating a new one
        if (typeof firebase !== 'undefined' && firebase.apps.length > 0) {
            const auth = firebase.auth();
            const db = firebase.firestore();

            // Function to update button display based on auth state
            function updateAuthButtons(user) {
                const signInBtn = document.getElementById('sign-in-btn');
                const logoutBtn = document.getElementById('logout-btn');
                
                if (user) {
                    // User is signed in
                    if (signInBtn) signInBtn.style.display = 'none';
                    if (logoutBtn) logoutBtn.style.display = 'inline-block';
                } else {
                    // User is signed out
                    if (signInBtn) signInBtn.style.display = 'inline-block';
                    if (logoutBtn) logoutBtn.style.display = 'none';
                }
            }

            // Authentication state observer
            auth.onAuthStateChanged(function(user) {
                updateAuthButtons(user);
            });

            // Check current auth state immediately with a small delay to ensure Firebase is ready
            setTimeout(function() {
                const currentUser = auth.currentUser;
                updateAuthButtons(currentUser);
            }, 200);

            // Logout functionality
            const logoutBtn = document.getElementById('logout-btn');
            if (logoutBtn) {
                logoutBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    auth.signOut().then(function() {
                        window.location.href = '../Pages/index.html';
                    }).catch(function(error) {
                        console.error('Error signing out:', error);
                    });
                });
            }

            // Dropdown for Forms nav
            const formsWrapper = document.getElementById('forms-dropdown-wrapper');
            const formsLink = document.getElementById('forms-nav-link');
            const dropdownMenu = document.getElementById('forms-dropdown-menu');
            let dropdownOpen = false;

            function openDropdown() {
                formsWrapper.classList.add('open');
                dropdownOpen = true;
            }
            function closeDropdown() {
                formsWrapper.classList.remove('open');
                dropdownOpen = false;
            }
            if (formsLink) {
                formsLink.addEventListener('click', function(e) {
                    e.preventDefault();
                    dropdownOpen ? closeDropdown() : openDropdown();
                });
            }
            document.addEventListener('mousedown', function(e) {
                if (formsWrapper && !formsWrapper.contains(e.target)) {
                    closeDropdown();
                }
            });
            // Keyboard accessibility
            if (formsLink) {
                formsLink.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        dropdownOpen ? closeDropdown() : openDropdown();
                    }
                });
            }

            // Update cart count badge in header
            function updateCartCountBadge() {
                const cartCountElement = document.getElementById('cart-count-badge');
                if (cartCountElement) {
                    let count = 0;
                    
                    // Try to get count from getCartCount function first
                    if (typeof getCartCount === 'function') {
                        count = getCartCount();
                    } else {
                        // Fallback to localStorage
                        try {
                            const cartData = localStorage.getItem('formwiz_cart');
                            if (cartData) {
                                const cart = JSON.parse(cartData);
                                count = Array.isArray(cart) ? cart.length : 0;
                            }
                        } catch (e) {
                            count = 0;
                        }
                    }
                    
                    // Always update the text content, even if count is 0
                    cartCountElement.textContent = count;
                    
                    if (count > 0) {
                        cartCountElement.style.display = 'flex';
                    } else {
                        cartCountElement.style.display = 'none';
                    }
                }
            }

            // Also update auth buttons when cart count updates
            function updateAuthButtonsAndCart() {
                const currentUser = auth.currentUser;
                updateAuthButtons(currentUser);
                updateCartCountBadge();
            }

            // Initialize auth buttons and cart count badge with a small delay to ensure DOM is ready
            setTimeout(updateAuthButtonsAndCart, 100);
            // Update more frequently to ensure cart count is always current
            setInterval(updateAuthButtonsAndCart, 2000);
            // Also update cart count immediately when page loads
            setTimeout(updateCartCountBadge, 500);

            // Sliding Cart Menu
            const cartIconLink = document.getElementById('cart-icon-link');
            const cartOverlay = document.getElementById('cart-overlay');
            const cartSideMenu = document.getElementById('cart-side-menu');
            const cartCloseBtn = document.getElementById('cart-close-btn');

            function openCart() {
                cartOverlay.classList.add('active');
                cartSideMenu.classList.add('active');
                document.body.style.overflow = 'hidden'; // Prevent scrolling when menu is open
                
                // Update cart content based on auth state
                updateCartContent();
            }

            function closeCart() {
                cartOverlay.classList.remove('active');
                cartSideMenu.classList.remove('active');
                document.body.style.overflow = ''; // Restore scrolling
            }

            if (cartIconLink) {
                cartIconLink.addEventListener('click', function(e) {
                    e.preventDefault();
                    openCart();
                });
            }

            if (cartCloseBtn) {
                cartCloseBtn.addEventListener('click', closeCart);
            }
            if (cartOverlay) {
                cartOverlay.addEventListener('click', function(e) {
                    if (e.target === cartOverlay) {
                        closeCart();
                    }
                });
            }

            // Update cart content based on authentication state
            function updateCartContent() {
                const cartMessage = document.getElementById('cart-message');
                const cartDescription = document.getElementById('cart-description');
                const cartSignupBtn = document.getElementById('cart-signup-btn');
                const cartItemsList = document.getElementById('cart-items-list');
                const cartCheckoutBtn = document.getElementById('cart-checkout-btn');
                const cartIconLarge = document.querySelector('.cart-icon-large');
                
                if (auth.currentUser) {
                    // User is signed in - show cart items
                    if (cartMessage) cartMessage.textContent = 'Your Cart';
                    if (cartDescription) cartDescription.textContent = 'Review your selected forms and proceed to checkout.';
                    if (cartSignupBtn) cartSignupBtn.style.display = 'none';
                    if (cartIconLarge) cartIconLarge.textContent = '🛒';
                    
                    // Load and display cart items
                    loadCartItems();
                } else {
                    // User is not signed in - show signup message
                    if (cartMessage) cartMessage.textContent = 'Create an account to start shopping!';
                    if (cartDescription) cartDescription.textContent = 'To add forms to your cart and make purchases, you\'ll need to create a FormWiz account. Sign up now to access our complete library of legal forms and start simplifying your paperwork.';
                    if (cartSignupBtn) cartSignupBtn.style.display = 'inline-block';
                    if (cartItemsList) cartItemsList.style.display = 'none';
                    if (cartCheckoutBtn) cartCheckoutBtn.style.display = 'none';
                    if (cartIconLarge) cartIconLarge.textContent = '🛒';
                }
            }
            
            // Load cart items for logged-in users
            async function loadCartItems() {
                const cartItemsList = document.getElementById('cart-items-list');
                const cartCheckoutBtn = document.getElementById('cart-checkout-btn');
                
                if (!cartItemsList || !auth.currentUser) return;
                
                try {
                    // Get cart data from cookies or localStorage
                    function getCookie(name) {
                        const value = '; ' + document.cookie;
                        const parts = value.split('; ' + name + '=');
                        if (parts.length === 2) return parts.pop().split(';').shift();
                        return null;
                    }
                    
                    const cartData = getCookie('formwiz_cart') || localStorage.getItem('formwiz_cart');
                    let cart = [];
                    
                    if (cartData) {
                        try {
                            cart = JSON.parse(cartData);
                        } catch (e) {
                            console.error('Error parsing cart data:', e);
                        }
                    }
                    
                    if (cart.length === 0) {
                        cartItemsList.innerHTML = '<p style="color:#7f8c8d;font-style:italic;">Your cart is empty</p>';
                        cartItemsList.style.display = 'block';
                        if (cartCheckoutBtn) cartCheckoutBtn.style.display = 'none';
                        return;
                    }
                    
                    // Fetch Stripe prices for cart items
                    async function fetchStripePrice(priceId) {
                        try {
                            const response = await fetch('/stripe-price/' + priceId);
                            if (!response.ok) return null;
                            const data = await response.json();
                            return data && data.unit_amount != null ? (data.unit_amount / 100).toFixed(2) : null;
                        } catch (e) {
                            console.error('Error fetching Stripe price:', e);
                            return null;
                        }
                    }
                    
                    // Render cart items
                    let total = 0;
                    let itemsHtml = '';
                    let itemIndex = 0;
                    for (const item of cart) {
                        const price = await fetchStripePrice(item.priceId);
                        const itemPrice = price ? parseFloat(price) : 0;
                        total += itemPrice;
                        // Defendant and county fields
                        let defendantHtml = '';
                        let countyHtml = '';
                        if (item.defendantName) {
                            const capName = String(item.defendantName)
                              .split(/s+/)
                              .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
                              .join(' ');
                            defendantHtml = '<div style=\"color:#e74c3c;font-weight:600;\">Defendant: ' + capName + '</div>';
                        }
                        if (item.countyName) {
                            const countyDisplay = item.countyName.toLowerCase().includes('county') ? item.countyName : item.countyName + ' County';
                            countyHtml = '<div style="color:#7f8c8d;">' + countyDisplay + '</div>';
                        }
                        // Use the proper display name instead of the filename
                        let displayTitle = item.title || 'Form';
                        if (item.formId === 'sc120' || item.formId === 'SC-120') {
                            displayTitle = 'SC-120';
                        } else if (item.formId === 'sc500' || item.formId === 'SC-500') {
                            displayTitle = 'SC-500';
                        }
                        
                        itemsHtml +=
     '<div class="cart-item">' +
       '<div class="cart-item-info">' +
         '<div class="cart-item-title">' + displayTitle + '</div>' +
         defendantHtml +
         countyHtml +
       '</div>' +
       '<div class="cart-item-price">$' + itemPrice.toFixed(2) + '</div>' +
       '<button class="remove-item" title="Remove" data-cart-index="' + itemIndex + '">' +
         '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6l-2 14H7L5 6"></path><path d="M10 11v6"></path><path d="M14 11v6"></path><path d="M5 6V4a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2"></path></svg>' +
       '</button>' +
     '</div>';
                        itemIndex++;
                    }
                    cartItemsList.innerHTML = itemsHtml;
                    cartItemsList.style.display = 'block';
                    // Remove item event listeners
                    const removeButtons = cartItemsList.querySelectorAll('.remove-item');
                    removeButtons.forEach(btn => {
                      btn.addEventListener('click', function(e) {
                        e.preventDefault();
                        const idx = parseInt(btn.getAttribute('data-cart-index'));
                        if (!isNaN(idx)) {
                          cart.splice(idx, 1);
                          // Save updated cart
                          document.cookie = 'formwiz_cart=' + encodeURIComponent(JSON.stringify(cart)) + ';path=/;max-age=2592000';
                          localStorage.setItem('formwiz_cart', JSON.stringify(cart));
                          loadCartItems();
                        }
                      });
                    });
                    if (cartCheckoutBtn) {
                        cartCheckoutBtn.textContent = 'Checkout - $' + total.toFixed(2);
                        cartCheckoutBtn.style.display = 'block';
                        cartCheckoutBtn.onclick = function() {
                            window.location.href = '../Pages/cart.html';
                        };
                    }
                } catch (error) {
                    console.error('Error loading cart items:', error);
                    cartItemsList.innerHTML = '<p style="color:#e74c3c;">Error loading cart items</p>';
                    cartItemsList.style.display = 'block';
                }
            }

            // Keyboard accessibility for cart menu
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeCart();
                }
            });
        }
    });

// Helper function to create styled address input
function createAddressInput(id, label, index, type = 'text') {
    const inputType = type === 'number' ? 'number' : 'text';
    const placeholder = label; // Remove the index number from placeholder
    
    return '<div class="address-field">' +
           '<input type="' + inputType + '" ' +
           'id="' + id + '" ' +
           'name="' + id + '" ' +
           'placeholder="' + placeholder + '" ' +
           'class="address-input">' +
           '</div>';
}

// Helper function to create US states dropdown
function createStateDropdown(id, index) {
    const states = [
        'Alabama', 'Alaska', 'Arizona', 'Arkansas', 'California', 'Colorado', 'Connecticut', 'Delaware',
        'Florida', 'Georgia', 'Hawaii', 'Idaho', 'Illinois', 'Indiana', 'Iowa', 'Kansas', 'Kentucky',
        'Louisiana', 'Maine', 'Maryland', 'Massachusetts', 'Michigan', 'Minnesota', 'Mississippi', 'Missouri',
        'Montana', 'Nebraska', 'Nevada', 'New Hampshire', 'New Jersey', 'New Mexico', 'New York',
        'North Carolina', 'North Dakota', 'Ohio', 'Oklahoma', 'Oregon', 'Pennsylvania', 'Rhode Island',
        'South Carolina', 'South Dakota', 'Tennessee', 'Texas', 'Utah', 'Vermont', 'Virginia',
        'Washington', 'West Virginia', 'Wisconsin', 'Wyoming'
    ];
    
    let options = '<option value="">Select State</option>';
    states.forEach(state => {
        options += '<option value="' + state + '">' + state + '</option>';
    });
    
    return '<div class="address-field">' +
           '<select id="' + id + '" name="' + id + '" class="address-select" onchange="updateStateHiddenFields(this, \'' + id + '\', \'' + id + '_short\')">' +
           options +
           '</select>' +
           '<input type="hidden" id="' + id + '" name="' + id + '" value="">' +
           '<input type="hidden" id="' + id + '_short" name="' + id + '_short" value="">' +
           '</div>';
}

</script>

<!-- Debug Menu -->
<div id="debugMenu" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 99999; font-family: 'Montserrat', sans-serif;">
  <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); width: 90%; max-width: 800px; max-height: 80%; overflow: hidden; display: flex; flex-direction: column;">
    <!-- Header -->
    <div style="background: linear-gradient(90deg, #4f8cff 0%, #38d39f 100%); color: white; padding: 20px; display: flex; justify-content: space-between; align-items: center; position: relative;">
      <h2 style="margin: 0; font-size: 1.5em; font-weight: 700;">🔍 Form Debug Menu</h2>
      <button id="closeDebugMenu" style="position: absolute; top: 10px; right: 10px; background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; padding: 5px; border-radius: 50%; width: 35px; height: 35px; display: flex; align-items: center; justify-content: center;">&times;</button>
    </div>
    
    <!-- Search Bar -->
    <div style="padding: 20px; border-bottom: 1px solid #eee;">
      <input type="text" id="debugSearch" placeholder="Search inputs by name, ID, or value..." style="width: 100%; padding: 12px 16px; border: 2px solid #e0e7ef; border-radius: 8px; font-size: 16px; box-sizing: border-box;">
      
      <!-- Filter Controls -->
      <div style="display: flex; gap: 15px; margin-top: 15px; align-items: center; flex-wrap: wrap;">
        <div style="flex: 1; min-width: 200px;">
          <label for="debugTypeFilter" style="display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50; font-size: 14px;">Filter by Type:</label>
          <select id="debugTypeFilter" style="width: 100%; padding: 10px 12px; border: 2px solid #e0e7ef; border-radius: 8px; font-size: 14px; background: white; cursor: pointer;">
            <option value="">All Types</option>
            <option value="text">📝 Text Inputs</option>
            <option value="email">📧 Email Inputs</option>
            <option value="tel">📞 Phone Inputs</option>
            <option value="number">🔢 Number Inputs</option>
            <option value="date">📅 Date Inputs</option>
            <option value="textarea">📄 Text Areas</option>
            <option value="checkbox">☑️ Checkboxes</option>
            <option value="radio">🔘 Radio Buttons</option>
            <option value="hidden">🔒 Hidden Fields</option>
          </select>
        </div>
        <div style="flex-shrink: 0;">
          <button id="exportNamesIdsBtn" style="background: linear-gradient(90deg, #4f8cff 0%, #38d39f 100%); color: white; border: none; padding: 12px 20px; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(79, 140, 255, 0.3);">
            📋 Export Names/IDs
          </button>
        </div>
      </div>
    </div>
    
    <!-- Content -->
    <div id="debugContent" style="flex: 1; overflow-y: auto; padding: 20px;">
      <!-- Content will be populated by JavaScript -->
    </div>
  </div>
</div>

<script>
// Debug Menu Functionality
let debugMenuVisible = false;

// Show debug menu on Ctrl+Shift
document.addEventListener('keydown', function(e) {
  if (e.ctrlKey && e.shiftKey && !debugMenuVisible) {
    e.preventDefault();
    showDebugMenu();
  }
});

// Close debug menu
document.getElementById('closeDebugMenu').addEventListener('click', hideDebugMenu);

// Close on escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape' && debugMenuVisible) {
    hideDebugMenu();
  }
});

// Tab key navigation - automatically press next button, submit, or download PDFs
document.addEventListener('keydown', function(e) {
  if (e.key === 'Tab') {
    e.preventDefault(); // Prevent default tab behavior
    
    // Check if we're on the thank you screen
    const thankYouMessage = document.getElementById('thankYouMessage');
    if (thankYouMessage && thankYouMessage.style.display !== 'none') {
      // On thank you screen, press download PDFs button
      const downloadButton = document.querySelector('button[onclick="downloadAllPdfs()"]');
      if (downloadButton) {
        downloadButton.click();
        return;
      }
    }
    
    // Look for the next button in the current section
    const nextButton = document.querySelector('.next-button:not([style*="display: none"])');
    if (nextButton) {
      nextButton.click();
      return;
    }
    
    // Look for submit button
    const submitButton = document.querySelector('button[type="submit"]:not([style*="display: none"])');
    if (submitButton) {
      submitButton.click();
      return;
    }
    
    // Look for any button with "submit" in its text or onclick
    const submitButtons = document.querySelectorAll('button');
    for (let button of submitButtons) {
      if (button.style.display !== 'none' && 
          (button.textContent.toLowerCase().includes('submit') || 
           button.onclick && button.onclick.toString().includes('submit'))) {
        button.click();
        return;
      }
    }
    
    // If no submit button found, look for download PDFs button
    const downloadPdfButton = document.querySelector('button[onclick*="downloadAllPdfs"]');
    if (downloadPdfButton) {
      downloadPdfButton.click();
      return;
    }
    
    console.log('🔧 [TAB NAVIGATION] No suitable button found to press');
  }
});

// Removed click-outside-to-close functionality - user must use X button

function showDebugMenu() {
  debugMenuVisible = true;
  document.getElementById('debugMenu').style.display = 'block';
  populateDebugContent();
  document.getElementById('debugSearch').focus();
}

function hideDebugMenu() {
  debugMenuVisible = false;
  document.getElementById('debugMenu').style.display = 'none';
}

// Add virtual checkbox entries for dropdown questions
function addVirtualDropdownCheckboxes(inputData) {
  // Find all dropdown/select elements
  const dropdowns = document.querySelectorAll('select');
  
  dropdowns.forEach(dropdown => {
    if (!dropdown.id) return;
    
    // Check if this is a numbered dropdown
    const isNumberedDropdown = dropdown.id.startsWith('answer') && dropdown.querySelector('option[value="1"]');
    
    if (isNumberedDropdown) {
      // Handle numbered dropdown - generate all possible textbox label combinations
      addNumberedDropdownVirtualEntries(inputData, dropdown);
    } else {
      // Handle regular dropdown - generate checkbox combinations
      addRegularDropdownVirtualEntries(inputData, dropdown);
    }
  });
}

// Create a hidden checkbox in the DOM for virtual checkboxes that should be checked
function createHiddenCheckbox(checkboxId, checkboxName, baseName) {
  // Find the dropdown wrapper or create a container
  let wrap = document.getElementById("dropdowntext_" + baseName);
  if (!wrap) {
    // If no wrapper exists, create one
    wrap = document.createElement("div");
    wrap.id = "dropdowntext_" + baseName;
    wrap.style.display = "none";
    
    // Find the dropdown element and insert the wrapper after it
    const dropdown = document.getElementById(baseName);
    if (dropdown && dropdown.parentNode) {
      dropdown.parentNode.insertBefore(wrap, dropdown.nextSibling);
    } else {
      // Fallback: append to body
      document.body.appendChild(wrap);
    }
  }
  
  // Create the hidden checkbox
  const checkboxDiv = document.createElement("div");
  checkboxDiv.style.display = "none";
  checkboxDiv.innerHTML = "<input type='checkbox' id='" + checkboxId + "' name='" + checkboxName + "' checked>" +
                   "<label for='" + checkboxId + "'> " + checkboxName + "</label>";
  
  wrap.appendChild(checkboxDiv);
}

// Create real hidden checkboxes for all autofilled dropdowns
function createHiddenCheckboxesForAutofilledDropdowns() {
  
  // Find all dropdown/select elements
  const dropdowns = document.querySelectorAll('select');
  
  dropdowns.forEach(dropdown => {
    if (!dropdown.id || dropdown.id.startsWith('answer')) return; // Skip numbered dropdowns
    
    const baseName = dropdown.id;
    const selectedValue = dropdown.value.trim();
    
    if (selectedValue) {
      // Generate checkbox ID using the same pattern as dropdownMirror
      const idSuffix = selectedValue.replace(/W+/g, "_").toLowerCase();
      const checkboxId = baseName + "_" + idSuffix;
      const checkboxName = baseName + "_" + idSuffix;
      
      // Check if this checkbox already exists
      const existingCheckbox = document.getElementById(checkboxId);
      if (!existingCheckbox) {
        createHiddenCheckbox(checkboxId, checkboxName, baseName);
      }
      
      // Handle custom hidden logic for this dropdown
      updateHiddenLogic(baseName, selectedValue);
    }
  });
}

// Add virtual entries for regular dropdowns (checkbox combinations)
function addRegularDropdownVirtualEntries(inputData, dropdown) {
  const baseName = dropdown.id;
  const options = dropdown.querySelectorAll('option[value]:not([value=""])');
  
  options.forEach(option => {
    const optionValue = option.value.trim();
    if (!optionValue) return;
    
    // Generate checkbox ID using the same pattern as dropdownMirror
    const idSuffix = optionValue.replace(/W+/g, "_").toLowerCase();
    const checkboxId = baseName + "_" + idSuffix;
    const checkboxName = baseName + "_" + idSuffix;
    
    // Check if this virtual checkbox already exists in inputData
    const exists = inputData.some(item => item.id === checkboxId);
    
    if (!exists) {
      // Check if this checkbox actually exists in the DOM (user selected this option)
      const actualCheckbox = document.getElementById(checkboxId);
      // Also check if the dropdown value matches this option (for autofilled dropdowns)
      const isChecked = actualCheckbox ? actualCheckbox.checked : (dropdown.value === optionValue);
      
      // If the virtual checkbox should be checked, create the actual hidden checkbox in the DOM
      if (isChecked && !actualCheckbox) {
        createHiddenCheckbox(checkboxId, checkboxName, baseName);
      }
      
      // Add virtual checkbox entry
      inputData.push({
        id: checkboxId,
        name: checkboxName,
        value: isChecked,
        type: 'input',
        inputType: 'checkbox',
        placeholder: '',
        required: false,
        isVirtual: !actualCheckbox, // Only virtual if it doesn't exist in DOM
        dropdownSource: dropdown.id,
        optionValue: optionValue
      });
    }
  });
}

// Add virtual entries for numbered dropdowns (textbox label combinations)
function addNumberedDropdownVirtualEntries(inputData, dropdown) {
  // Extract question ID from dropdown ID (e.g., "answer123" -> "123")
  const questionId = dropdown.id.replace('answer', '');
  
  // Get the question's Node ID from the question text (this is the base we should use)
  const questionH3 = document.getElementById("question-container-" + questionId)?.querySelector("h3")?.textContent;
  const questionNodeId = questionH3 ? sanitizeQuestionText(questionH3) : dropdown.id;
  
  // Get the range from the dropdown options
  const options = dropdown.querySelectorAll('option[value]:not([value=""])');
  let maxRange = 0;
  options.forEach(option => {
    const value = parseInt(option.value);
    if (!isNaN(value) && value > maxRange) {
      maxRange = value;
    }
  });
  
  // Get label information from the global maps
  const labelVals = labelMap[questionId] || [];
  const labelNodeIds = window.labelNodeIdsMap && window.labelNodeIdsMap[questionId] ? window.labelNodeIdsMap[questionId] : [];
  
  
  // Generate all possible combinations
  for (let j = 1; j <= maxRange; j++) {
    // Add textbox label combinations
    for (let lblIndex = 0; lblIndex < labelVals.length; lblIndex++) {
      const lbl = labelVals[lblIndex];
      const labelNodeId = labelNodeIds[lblIndex] || "";
      
      // Use label node ID if provided, otherwise use question Node ID + label + number
      const id = labelNodeId ? 
        labelNodeId + "_" + j : 
        questionNodeId + "_" + j + "_" + sanitizeQuestionText(lbl);
      
      // Check if this virtual input already exists in inputData
      const exists = inputData.some(item => item.id === id);
      
      if (!exists) {
        // Check if this input actually exists in the DOM
        const actualInput = document.getElementById(id);
        const value = actualInput ? actualInput.value : '';
        
        // Add virtual input entry
        inputData.push({
          id: id,
          name: id,
          value: value,
          type: 'input',
          inputType: 'text',
          placeholder: lbl + ' ' + j,
          required: false,
          isVirtual: true,
          dropdownSource: dropdown.id,
          optionValue: j.toString(),
          labelText: lbl
        });
      }
    }
    
    // Add hidden checkbox combinations (for the numbered dropdown hidden checkboxes)
    const checkboxId = questionNodeId + "_" + j;
    const checkboxExists = inputData.some(item => item.id === checkboxId);
    
    if (!checkboxExists) {
      // Check if this checkbox actually exists in the DOM
      const actualCheckbox = document.getElementById(checkboxId);
      const isChecked = actualCheckbox ? actualCheckbox.checked : false;
      
      // Add virtual checkbox entry
      inputData.push({
        id: checkboxId,
        name: checkboxId,
        value: isChecked,
        type: 'input',
        inputType: 'checkbox',
        placeholder: '',
        required: false,
        isVirtual: true,
        dropdownSource: dropdown.id,
        optionValue: j.toString(),
        labelText: 'Hidden checkbox for option ' + j
      });
    }
  }
}

function populateDebugContent() {
  const content = document.getElementById('debugContent');
  const searchTerm = document.getElementById('debugSearch').value.toLowerCase();
  const typeFilter = document.getElementById('debugTypeFilter').value;
  
  // Get all form inputs
  const inputs = document.querySelectorAll('input, select, textarea');
  const inputData = [];
  
  inputs.forEach(input => {
    // Include all inputs that have either an ID or a name (or both)
    if (input.id || input.name) {
      const value = input.type === 'checkbox' ? input.checked : input.value;
      const type = input.tagName.toLowerCase();
      const inputType = input.type || 'text';
      
      inputData.push({
        id: input.id || '',
        name: input.name || '',
        value: value,
        type: type,
        inputType: inputType,
        placeholder: input.placeholder || '',
        required: input.required
      });
    }
  });
  
  // Add virtual checkbox entries for dropdown questions
  addVirtualDropdownCheckboxes(inputData);
  
  // After potentially creating real checkboxes from virtual ones, re-scan the DOM to include them
  const updatedInputs = document.querySelectorAll('input, select, textarea');
  updatedInputs.forEach(input => {
    // Include all inputs that have either an ID or a name (or both)
    if (input.id || input.name) {
      // Check if this input is already in inputData
      const exists = inputData.some(item => item.id === input.id && item.name === input.name);
      if (!exists) {
        const value = input.type === 'checkbox' ? input.checked : input.value;
        const type = input.tagName.toLowerCase();
        const inputType = input.type || 'text';
        
        inputData.push({
          id: input.id || '',
          name: input.name || '',
          value: value,
          type: type,
          inputType: inputType,
          placeholder: input.placeholder || '',
          required: input.required
        });
      }
    }
  });
  
  // Filter by search term and type
  const normalizedSearchTermUnderscore = searchTerm.replace(/[_s]/g, '_');
  const normalizedSearchTermSpace = searchTerm.replace(/[_s]/g, ' ');
  
  const filteredData = inputData.filter(item => {
    // First check type filter
    if (typeFilter) {
      let itemType = '';
      if (item.inputType === 'text' || item.inputType === 'email' || item.inputType === 'tel' || item.inputType === 'number' || item.inputType === 'date') {
        itemType = item.inputType;
      } else if (item.type === 'select') {
        itemType = 'text'; // Classify dropdowns as text inputs
      } else if (item.type === 'textarea') {
        itemType = 'textarea';
      } else if (item.inputType === 'checkbox') {
        itemType = 'checkbox';
      } else if (item.inputType === 'radio') {
        itemType = 'radio';
      } else if (item.inputType === 'hidden') {
        // Check if this is a state-related hidden field that should be grouped with text inputs
        if (item.id && (item.id.includes('_state') || item.id.includes('_state_short'))) {
          itemType = 'text'; // Classify state-related hidden fields as text inputs
        } else {
          itemType = 'hidden';
        }
      } else {
        itemType = 'text'; // Classify other inputs as text inputs
      }
      
      if (itemType !== typeFilter) {
        return false;
      }
    }
    
    // If no search term, return true (type filter already applied)
    if (!searchTerm) {
      return true;
    }
    
    // Apply search term filtering with bidirectional space/underscore normalization
    const normalizedIdUnderscore = item.id.toLowerCase().replace(/[_s]/g, '_');
    const normalizedNameUnderscore = item.name.toLowerCase().replace(/[_s]/g, '_');
    const normalizedValueUnderscore = String(item.value).toLowerCase().replace(/[_s]/g, '_');
    const normalizedPlaceholderUnderscore = item.placeholder.toLowerCase().replace(/[_s]/g, '_');
    
    const normalizedIdSpace = item.id.toLowerCase().replace(/[_s]/g, ' ');
    const normalizedNameSpace = item.name.toLowerCase().replace(/[_s]/g, ' ');
    const normalizedValueSpace = String(item.value).toLowerCase().replace(/[_s]/g, ' ');
    const normalizedPlaceholderSpace = item.placeholder.toLowerCase().replace(/[_s]/g, ' ');
    
    // Check all combinations: underscore search vs underscore data, space search vs space data, and cross-matches
    return normalizedIdUnderscore.includes(normalizedSearchTermUnderscore) ||
           normalizedNameUnderscore.includes(normalizedSearchTermUnderscore) ||
           normalizedValueUnderscore.includes(normalizedSearchTermUnderscore) ||
           normalizedPlaceholderUnderscore.includes(normalizedSearchTermUnderscore) ||
           normalizedIdSpace.includes(normalizedSearchTermSpace) ||
           normalizedNameSpace.includes(normalizedSearchTermSpace) ||
           normalizedValueSpace.includes(normalizedSearchTermSpace) ||
           normalizedPlaceholderSpace.includes(normalizedSearchTermSpace) ||
           // Cross-matches: underscore search vs space data
           normalizedIdSpace.includes(normalizedSearchTermUnderscore) ||
           normalizedNameSpace.includes(normalizedSearchTermUnderscore) ||
           normalizedValueSpace.includes(normalizedSearchTermUnderscore) ||
           normalizedPlaceholderSpace.includes(normalizedSearchTermUnderscore) ||
           // Cross-matches: space search vs underscore data
           normalizedIdUnderscore.includes(normalizedSearchTermSpace) ||
           normalizedNameUnderscore.includes(normalizedSearchTermSpace) ||
           normalizedValueUnderscore.includes(normalizedSearchTermSpace) ||
           normalizedPlaceholderUnderscore.includes(normalizedSearchTermSpace) ||
           // Original exact matches for backward compatibility
    item.id.toLowerCase().includes(searchTerm) ||
    item.name.toLowerCase().includes(searchTerm) ||
    String(item.value).toLowerCase().includes(searchTerm) ||
           item.placeholder.toLowerCase().includes(searchTerm);
  });
  
  // Group by type
  const grouped = {
    text: [],
    email: [],
    tel: [],
    number: [],
    date: [],
    select: [],
    textarea: [],
    checkbox: [],
    radio: [],
    hidden: [],
    other: []
  };
  
  // First pass: collect all visible field names to identify duplicates
  const visibleFieldNames = new Set();
  filteredData.forEach(item => {
    if (item.inputType !== 'hidden' && item.type !== 'hidden') {
      visibleFieldNames.add(item.name);
    }
  });

  filteredData.forEach(item => {
    // Skip hidden fields that have a corresponding visible field with the same name
    if (item.inputType === 'hidden' && visibleFieldNames.has(item.name)) {
      return; // Skip this hidden field
    }
    
    // Use the same logic as the filtering to determine the final itemType
    let itemType = '';
    if (item.inputType === 'text' || item.inputType === 'email' || item.inputType === 'tel' || item.inputType === 'number' || item.inputType === 'date') {
      itemType = item.inputType;
    } else if (item.type === 'select') {
      itemType = 'text'; // Classify dropdowns as text inputs
    } else if (item.type === 'textarea') {
      itemType = 'textarea';
    } else if (item.inputType === 'checkbox') {
      itemType = 'checkbox';
    } else if (item.inputType === 'radio') {
      itemType = 'radio';
    } else if (item.inputType === 'hidden') {
      // Check if this is a state-related hidden field that should be grouped with text inputs
      if (item.id && (item.id.includes('_state') || item.id.includes('_state_short'))) {
        itemType = 'text'; // Classify state-related hidden fields as text inputs
    } else {
        itemType = 'hidden';
      }
    } else {
      itemType = 'text'; // Classify other inputs as text inputs
    }
    
    // Group by the final itemType
    grouped[itemType].push(item);
  });
  
  // Generate HTML
  let html = '';
  
  const typeLabels = {
    text: '📝 Text Inputs',
    email: '📧 Email Inputs', 
    tel: '📞 Phone Inputs',
    number: '🔢 Number Inputs',
    date: '📅 Date Inputs',
    select: '📝 Text Inputs',
    textarea: '📄 Text Areas',
    checkbox: '☑️ Checkboxes',
    radio: '🔘 Radio Buttons',
    hidden: '🔒 Hidden Fields',
    other: '📝 Text Inputs'
  };
  
  Object.keys(grouped).forEach(type => {
    if (grouped[type].length > 0) {
      html += '<div style="margin-bottom: 30px;">';
      html += '<h3 style="color: #2c3e50; margin-bottom: 15px; font-size: 1.2em; border-bottom: 2px solid #e0e7ef; padding-bottom: 8px;">' + typeLabels[type] + ' (' + grouped[type].length + ')</h3>';
      
      grouped[type].forEach(item => {
        const valueDisplay = item.value === '' ? '<em style="color: #999;">(empty)</em>' : 
                           item.value === true ? '<span style="color: #38d39f;">✓ checked</span>' :
                           item.value === false ? '<span style="color: #e74c3c;">✗ unchecked</span>' :
                           '<span style="color: #2c3e50;">' + String(item.value).substring(0, 100) + (String(item.value).length > 100 ? '...' : '') + '</span>';
        
        const requiredBadge = item.required ? '<span style="background: #e74c3c; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; margin-left: 8px;">REQUIRED</span>' : '';
        const virtualBadge = item.isVirtual ? '<span style="background: #4f8cff; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; margin-left: 8px;">VIRTUAL</span>' : '';
        
        // Determine the primary identifier (ID if available, otherwise name)
        const primaryId = item.id || item.name || 'unnamed';
        const displayId = item.id || '<em style="color: #999;">(no ID)</em>';
        const displayName = item.name || '<em style="color: #999;">(no name)</em>';
        
        html += '<div class="debug-entry" data-id="' + primaryId + '" style="background: #f8faff; border: 1px solid #e0e7ef; border-radius: 8px; padding: 15px; margin-bottom: 10px; transition: all 0.3s ease; cursor: pointer; position: relative;">' +
          '<div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px; flex-wrap: wrap; gap: 8px;">' +
            '<div style="flex: 1; min-width: 0;">' +
              '<strong style="color: #2c3e50; font-size: 1.1em; word-break: break-all; line-height: 1.3; display: block;">' + displayId + '</strong>' +
              requiredBadge + virtualBadge +
            '</div>' +
            '<span style="background: #e0e7ef; color: #2c3e50; padding: 4px 8px; border-radius: 4px; font-size: 0.9em; flex-shrink: 0; white-space: nowrap;">' + item.inputType + '</span>' +
          '</div>' +
          '<div style="margin-bottom: 5px;">' +
            '<span style="color: #666; font-size: 0.9em;">Name: </span>' +
            '<code style="background: #f0f0f0; padding: 2px 6px; border-radius: 4px; font-size: 0.9em; word-break: break-all; display: inline-block; max-width: 100%;">' + displayName + '</code>' +
          '</div>' +
          (item.placeholder ? '<div style="margin-bottom: 5px;"><span style="color: #666; font-size: 0.9em;">Placeholder: </span><span style="color: #999;">' + item.placeholder + '</span></div>' : '') +
          (item.isVirtual && item.dropdownSource ? '<div style="margin-bottom: 5px;"><span style="color: #666; font-size: 0.9em;">From Dropdown: </span><span style="color: #4f8cff; font-weight: bold;">' + item.dropdownSource + '</span> → <span style="color: #2c3e50;">' + item.optionValue + '</span></div>' : '') +
          '<div>' +
            '<span style="color: #666; font-size: 0.9em;">Value: </span>' +
            valueDisplay +
          '</div>' +
          '<div class="copy-indicator" style="position: absolute; top: 10px; right: 10px; background: #38d39f; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8em; font-weight: bold; opacity: 0; transform: scale(0.8); transition: all 0.3s ease;">COPIED!</div>' +
        '</div>';
      });
      
      html += '</div>';
    }
  });
  
  if (html === '') {
    html = '<div style="text-align: center; color: #666; padding: 40px;"><p>No inputs found matching your search.</p></div>';
  }
  
  content.innerHTML = html;
  
  // Add click event listeners to debug entries
  const debugEntries = content.querySelectorAll('.debug-entry');
  debugEntries.forEach(entry => {
    entry.addEventListener('click', function() {
      const id = this.getAttribute('data-id');
      copyToClipboard(id, this);
    });
    
    // Add hover effects
    entry.addEventListener('mouseenter', function() {
      this.style.background = '#f0f8ff';
      this.style.borderColor = '#4f8cff';
      this.style.transform = 'translateY(-2px)';
      this.style.boxShadow = '0 4px 12px rgba(79, 140, 255, 0.15)';
    });
    
    entry.addEventListener('mouseleave', function() {
      this.style.background = '#f8faff';
      this.style.borderColor = '#e0e7ef';
      this.style.transform = 'translateY(0)';
      this.style.boxShadow = 'none';
    });
  });
}

// Copy to clipboard function
function copyToClipboard(text, element) {
  // Remove any existing copy highlights
  const allEntries = document.querySelectorAll('.debug-entry');
  allEntries.forEach(entry => {
    entry.style.background = '#f8faff';
    entry.style.borderColor = '#e0e7ef';
    entry.style.borderWidth = '1px';
    const indicator = entry.querySelector('.copy-indicator');
    if (indicator) {
      indicator.style.opacity = '0';
      indicator.style.transform = 'scale(0.8)';
    }
  });
  
  // Highlight the clicked entry
  element.style.background = '#e8f5e8';
  element.style.borderColor = '#38d39f';
  element.style.borderWidth = '2px';
  
  // Show copy indicator
  const copyIndicator = element.querySelector('.copy-indicator');
  if (copyIndicator) {
    copyIndicator.style.opacity = '1';
    copyIndicator.style.transform = 'scale(1)';
  }
  
  // Copy to clipboard
  if (navigator.clipboard && window.isSecureContext) {
    // Use modern clipboard API
    navigator.clipboard.writeText(text).then(() => {
      console.log('Copied to clipboard:', text);
    }).catch(err => {
      console.error('Failed to copy: ', err);
      fallbackCopyToClipboard(text);
    });
  } else {
    // Fallback for older browsers
    fallbackCopyToClipboard(text);
  }
  
  // Reset highlight after 2 seconds
  setTimeout(() => {
    element.style.background = '#f8faff';
    element.style.borderColor = '#e0e7ef';
    element.style.borderWidth = '1px';
    if (copyIndicator) {
      copyIndicator.style.opacity = '0';
      copyIndicator.style.transform = 'scale(0.8)';
    }
  }, 2000);
}

// Fallback copy function for older browsers
function fallbackCopyToClipboard(text) {
  const textArea = document.createElement('textarea');
  textArea.value = text;
  textArea.style.position = 'fixed';
  textArea.style.left = '-999999px';
  textArea.style.top = '-999999px';
  document.body.appendChild(textArea);
  textArea.focus();
  textArea.select();
  
  try {
    document.execCommand('copy');
    console.log('Copied to clipboard (fallback):', text);
  } catch (err) {
    console.error('Fallback copy failed: ', err);
  }
  
  document.body.removeChild(textArea);
}

// Export Names/IDs function
function exportNamesAndIds() {
  // Get form name from the form name input field
  const formNameEl = document.getElementById('formNameInput');
  const formName = formNameEl && formNameEl.value.trim() ? formNameEl.value.trim() : 'Example Form';
  
  const formData = {
    exportDate: new Date().toISOString(),
    formName: formName,
    formTitle: document.title || 'Form Data',
    inputs: []
  };
  
  // Get all form inputs
  const inputs = document.querySelectorAll('input, select, textarea');
  
  inputs.forEach((input, index) => {
    // Only include inputs that have an ID
    if (input.id) {
      const inputData = {
        id: input.id
      };
      formData.inputs.push(inputData);
    }
  });
  
  // Create and download JSON file
  const jsonString = JSON.stringify(formData, null, 2);
  const blob = new Blob([jsonString], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'form-names-ids-' + new Date().toISOString().split('T')[0] + '.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  // Show success message
  const button = document.getElementById('exportNamesIdsBtn');
  const originalText = button.textContent;
  button.textContent = '✅ Exported!';
  button.style.background = 'linear-gradient(90deg, #38d39f 0%, #4f8cff 100%)';
  
  setTimeout(() => {
    button.textContent = originalText;
    button.style.background = 'linear-gradient(90deg, #4f8cff 0%, #38d39f 100%)';
  }, 2000);
}

// Search functionality
document.getElementById('debugSearch').addEventListener('input', populateDebugContent);

// Type filter functionality
document.getElementById('debugTypeFilter').addEventListener('change', populateDebugContent);

// Export Names/IDs functionality
document.getElementById('exportNamesIdsBtn').addEventListener('click', exportNamesAndIds);

// Function to create Form Name input field (to be called from the form editor interface)
function createFormNameInput() {
  const formNameContainer = document.createElement('div');
  formNameContainer.id = 'formNameContainer';
  formNameContainer.style.cssText = 
    'background: #fff; ' +
    'border: 2px solid #2980b9; ' +
    'border-radius: 10px; ' +
    'padding: 20px; ' +
    'margin: 20px auto; ' +
    'max-width: 600px; ' +
    'box-shadow: 0 4px 12px rgba(0,0,0,0.1);';
  
  formNameContainer.innerHTML = 
    '<h3 style="text-align: center; margin-bottom: 15px; color: #2c3e50; font-size: 1.3em;">Form Name</h3>' +
    '<div style="text-align: center;">' +
      '<label for="formNameInput" style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">Form Name:</label>' +
      '<input type="text" id="formNameInput" name="formNameInput" ' +
             'placeholder="Enter your form name (e.g., Customer Survey, Job Application)" ' +
             'style="width: 100%; max-width: 400px; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px; text-align: center;" ' +
             'value="Example Form">' +
      '<p style="margin-top: 8px; font-size: 0.9em; color: #666; font-style: italic;">' +
        'This name will appear in the browser title and be used for the default checkbox.' +
      '</p>' +
    '</div>';
  
  return formNameContainer;
}

// Function to insert Form Name input above the first section
function insertFormNameInput() {
  // Check if form name input already exists
  if (document.getElementById('formNameContainer')) {
    return; // Already exists
  }
  
  // Find the first section or a suitable insertion point
  const firstSection = document.querySelector('[id^="sectionBlock"]');
  const formNameInput = createFormNameInput();
  
  if (firstSection) {
    firstSection.parentNode.insertBefore(formNameInput, firstSection);
  } else {
    // If no sections found, append to body or a container
    const container = document.querySelector('#formEditor') || document.body;
    container.insertBefore(formNameInput, container.firstChild);
  }
}

// Update content when form values change
document.addEventListener('input', function() {
  if (debugMenuVisible) {
    populateDebugContent();
  }
});

document.addEventListener('change', function() {
  if (debugMenuVisible) {
    populateDebugContent();
  }
});

// Function to update hidden state fields when dropdown selection changes
function updateStateHiddenFields(dropdown, hiddenFullId, hiddenShortId) {
    const selectedState = dropdown.value;
    const fullField = document.getElementById(hiddenFullId);
    const shortField = document.getElementById(hiddenShortId);
    
    // State abbreviation mapping
    const stateAbbreviations = {
        'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR', 'California': 'CA', 'Colorado': 'CO',
        'Connecticut': 'CT', 'Delaware': 'DE', 'Florida': 'FL', 'Georgia': 'GA', 'Hawaii': 'HI', 'Idaho': 'ID',
        'Illinois': 'IL', 'Indiana': 'IN', 'Iowa': 'IA', 'Kansas': 'KS', 'Kentucky': 'KY', 'Louisiana': 'LA',
        'Maine': 'ME', 'Maryland': 'MD', 'Massachusetts': 'MA', 'Michigan': 'MI', 'Minnesota': 'MN', 'Mississippi': 'MS',
        'Missouri': 'MO', 'Montana': 'MT', 'Nebraska': 'NE', 'Nevada': 'NV', 'New Hampshire': 'NH', 'New Jersey': 'NJ',
        'New Mexico': 'NM', 'New York': 'NY', 'North Carolina': 'NC', 'North Dakota': 'ND', 'Ohio': 'OH', 'Oklahoma': 'OK',
        'Oregon': 'OR', 'Pennsylvania': 'PA', 'Rhode Island': 'RI', 'South Carolina': 'SC', 'South Dakota': 'SD',
        'Tennessee': 'TN', 'Texas': 'TX', 'Utah': 'UT', 'Vermont': 'VT', 'Virginia': 'VA', 'Washington': 'WA',
        'West Virginia': 'WV', 'Wisconsin': 'WI', 'Wyoming': 'WY'
    };
    
    if (fullField && shortField) {
        if (selectedState) {
            fullField.value = selectedState;
            shortField.value = stateAbbreviations[selectedState] || '';
        } else {
            fullField.value = '';
            shortField.value = '';
        }
    }
}

// Function to update user full name
function updateUserFullName() {
  const firstName = document.getElementById('user_firstname')?.value || '';
  const lastName = document.getElementById('user_lastname')?.value || '';
  const fullNameField = document.getElementById('user_fullname');
  
  if (fullNameField) {
    // Simply combine first and last name with a space
    const fullName = (firstName + ' ' + lastName).trim();
    fullNameField.value = fullName;
  }
}

// Add event listeners for first and last name fields
document.addEventListener('DOMContentLoaded', function() {
  const firstNameField = document.getElementById('user_firstname');
  const lastNameField = document.getElementById('user_lastname');
  
  if (firstNameField) {
    firstNameField.addEventListener('input', updateUserFullName);
    firstNameField.addEventListener('change', updateUserFullName);
  }
  
  if (lastNameField) {
    lastNameField.addEventListener('input', updateUserFullName);
    lastNameField.addEventListener('change', updateUserFullName);
  }
  
  // Set user_fullname 2 seconds after page loads to ensure all autopopulation is complete
  setTimeout(() => {
    updateUserFullName();
  }, 2000);
});

function showTextboxLabels(questionId, count){
    const container = document.getElementById("labelContainer" + questionId);
    if(!container) return;

    container.innerHTML = "";
    
    // Try to get unified fields first, fallback to old arrays
    const qBlock = document.querySelector('#question-container-' + questionId)?.closest('.question-block') || 
                   document.querySelector('[id*="' + questionId + '"]')?.closest('.question-block');
    
    let allFieldsInOrder = [];
    
    if (qBlock) {
        const unifiedFields = Array.from(qBlock.querySelectorAll('#unifiedFields' + questionId + ' .unified-field'));
        
        if (unifiedFields.length > 0) {
            // Use unified container data
            const allElements = [];
            
            unifiedFields.forEach((el) => {
                const fieldType = el.getAttribute('data-type');
                const fieldOrder = parseInt(el.getAttribute('data-order'));
                const labelTextEl = el.querySelector('#labelText' + questionId + '_' + fieldOrder);
                const nodeIdTextEl = el.querySelector('#nodeIdText' + questionId + '_' + fieldOrder);
                
                if (labelTextEl && nodeIdTextEl) {
                    allElements.push({
                        type: fieldType,
                        label: labelTextEl.textContent.trim(),
                        nodeId: nodeIdTextEl.textContent.trim(),
                        order: fieldOrder
                    });
                }
            });
            
            // Sort by data-order attribute (creation order)
            allElements.sort((a, b) => a.order - b.order);
            allFieldsInOrder = allElements;
        }
    }
    
    // Fallback to unified fields map or old arrays if no unified fields found
    if (allFieldsInOrder.length === 0) {
        // Try unified fields map first
        if (window.unifiedFieldsMap && window.unifiedFieldsMap[questionId]) {
            allFieldsInOrder = window.unifiedFieldsMap[questionId];
        } else {
            // Fallback to old arrays
            const theseLabels = labelMap[questionId] || [];
            const theseAmounts = amountMap[questionId] || [];
            
            allFieldsInOrder = [
                ...theseLabels.map((lbl, index) => ({
                    type: 'label',
                    label: lbl,
                    nodeId: (window.labelNodeIdsMap && window.labelNodeIdsMap[questionId] ? window.labelNodeIdsMap[questionId] : [])[index] || "",
                    order: index
                })),
                ...theseAmounts.map((amt, index) => ({
                    type: 'amount',
                    label: amt,
                    nodeId: "",
                    order: index
                }))
            ];
        }
    }

    /* get and sanitise the question's visible text exactly once */
    const questionH3   = document
        .getElementById("question-container-" + questionId)
        ?.querySelector("h3")?.textContent || ("answer" + questionId);
    const qSafe = sanitizeQuestionText(questionH3);

    // Generate hidden checkboxes for the selected count
    generateHiddenCheckboxes(questionId, qSafe, count);

    // Define location field names for visual separation
    const locationFields = ['Street', 'City', 'State', 'Zip'];

    for(let j = 1; j <= count; j++){
        let lastWasLocation = false;
        let firstField = true;
        
        // Create entry container div
        const entryContainer = document.createElement('div');
        entryContainer.className = 'entry-container';
        entryContainer.style.cssText = 'border: 2px solid #2980b9 !important; border-radius: 12px; padding: 20px; margin: 20px auto; background-color: #f8f9ff; box-shadow: 0 4px 8px rgba(41, 128, 185, 0.15); transition: all 0.3s ease; display: inline-block; width: auto; min-width: 450px; max-width: 100%; box-sizing: border-box;';
        
        // Process all fields in creation order
        for(let fieldIndex = 0; fieldIndex < allFieldsInOrder.length; fieldIndex++){
            const field = allFieldsInOrder[fieldIndex];
            const isLocationField = locationFields.includes(field.label);
            
            // Add <br> before first location field in each count
            if (isLocationField && !lastWasLocation && !firstField) {
                const br = document.createElement('br');
                entryContainer.appendChild(br);
            }
            
            if (field.type === 'label') {
                const fieldId = field.nodeId + "_" + j;
                if (field.label === 'State') {
                    // Use dropdown for State field
                    const dropdownDiv = document.createElement('div');
                    dropdownDiv.innerHTML = createStateDropdown(fieldId, j);
                    entryContainer.appendChild(dropdownDiv.firstElementChild);
                } else {
                    // Use regular input for other fields
                    const inputDiv = document.createElement('div');
                    inputDiv.innerHTML = createAddressInput(fieldId, field.label, j);
                    entryContainer.appendChild(inputDiv.firstElementChild);
                }
            } else if (field.type === 'amount') {
                const fieldId = field.nodeId + "_" + j;
                const inputDiv = document.createElement('div');
                inputDiv.innerHTML = createAddressInput(fieldId, field.label, j, 'number');
                entryContainer.appendChild(inputDiv.firstElementChild);
                
                // Add a <br> after the Zip input only if there are more fields after it
                const remainingFields = allFieldsInOrder.slice(fieldIndex + 1);
                if (remainingFields.length > 0) {
                  const brElement = document.createElement('br');
                  entryContainer.appendChild(brElement);
                }
            }
            
            lastWasLocation = isLocationField;
            firstField = false;
        }
        
        // Append the entry container to the main container
        container.appendChild(entryContainer);
        
        // Add 1 <br> tag after each entry for better visual separation
        const br = document.createElement('br');
        container.appendChild(br);
    }
}
</script>

</body>
</html>
