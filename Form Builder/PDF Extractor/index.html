<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>PDF Form Extractor (Exact Field Renaming via Low-Level AcroForm)</title>

  <!-- PDF.js (core + worker) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
  </script>

  <!-- pdf-lib -->
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

  <style>
    .renaming-btn { margin-top: 1rem; padding: 0.8rem 1.5rem; background-color: #48bb78; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; }
    .renaming-btn[disabled] { opacity:.6; cursor:not-allowed; }
    .renaming-btn:hover { background-color: #38a169; }
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    body { background-color: #f0f2f5; min-height: 100vh; display: flex; flex-direction: column; align-items: center; padding: 2rem; }
    .container { background: white; padding: 2rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); width: 90%; max-width: 900px; margin-top: 2rem; }
    h1 { color: #2d3436; margin-bottom: 1.5rem; text-align: center; }
    .upload-section { border: 2px dashed #a0aec0; border-radius: 8px; padding: 2rem; text-align: center; margin-bottom: 2rem; transition: all 0.3s ease; }
    .upload-section:hover { border-color: #4299e1; background-color: #f8fafc; }
    #pdfInput { display: none; }
    .custom-upload-btn { background-color: #4299e1; color: white; padding: 0.8rem 1.5rem; border-radius: 6px; cursor: pointer; transition: background-color 0.3s ease; display: inline-block; margin-bottom: 1rem; }
    .custom-upload-btn:hover { background-color: #3182ce; }
    #loading { display: none; color: #718096; text-align: center; margin: 1rem 0; }
    .extracted-text-container { margin-top: 1rem; background-color: #f8fafc; border-radius: 8px; padding: 1.5rem; }
    .section-header { color: #2d3436; margin-bottom: 1rem; font-size: 1.2rem; }
    .formatted-text { background: white; border-radius: 6px; padding: 1rem; max-height: 420px; overflow-y: auto; border: 1px solid #e2e8f0; }
    .text-line { margin: 2px 0; line-height: 1.4; }
    .page-break { height: 20px; border-bottom: 1px solid #e0e0e0; margin: 15px 0; }
    .field-highlight { background-color: #e3f2fd; color: #1976d2; padding: 2px 4px; border-radius: 3px; font-weight: 600; cursor: pointer; }
    .checkbox-highlight { background-color: #ffebee; color: #d32f2f; padding: 2px 4px; border-radius: 3px; font-weight: 600; cursor: pointer; }

    .pdf-preview-container { margin-top: 2rem; background-color: #f8fafc; border-radius: 8px; padding: 1.5rem; }
    .pdf-preview-wrapper { position: relative; display: inline-block; background: white; border-radius: 6px; padding: 1rem; border: 1px solid #e2e8f0; max-width: 100%; overflow-x: auto; }
    #pdfCanvas { display: block; max-width: 100%; height: auto; border: 1px solid #ddd; }
    .field-overlays { position: absolute; top: 0; left: 0; pointer-events: none; }
    .field-overlay { position: absolute; border: 2px solid; border-radius: 3px; opacity: 0.7; pointer-events: auto; }
    .field-overlay.text-field { border-color: #1976d2; background-color: rgba(227,242,253,.3); }
    .field-overlay.checkbox-field { border-color: #d32f2f; background-color: rgba(255,235,238,.3); }
    .field-overlay.checkbox-field.unchecked { border-color: #d32f2f; background-color: rgba(255,235,238,.1); }
    .field-overlay.checkbox-field.checked { border-color: #d32f2f; background-color: rgba(255,235,238,.3); }
    .page-nav-btn { padding: 0.5rem 1rem; margin: 0 0.5rem; background-color: #4299e1; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .page-nav-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .page-nav-btn:hover:not(:disabled) { background-color: #3182ce; }
    .json-controls { display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; }
    
    /* Modal Styles */
    .modal { position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
    .modal-content { background-color: white; margin: 5% auto; padding: 0; border-radius: 8px; width: 80%; max-width: 800px; max-height: 80vh; display: flex; flex-direction: column; }
    .modal-header { padding: 1rem 1.5rem; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center; }
    .modal-header h2 { margin: 0; color: #2d3436; }
    .close { color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; }
    .close:hover { color: #000; }
    .modal-body { padding: 1rem 1.5rem; flex: 1; overflow-y: auto; }
    .modal-footer { padding: 1rem 1.5rem; border-top: 1px solid #e2e8f0; display: flex; gap: 1rem; justify-content: flex-end; }
    .field-list { max-height: 400px; overflow-y: auto; }
    .field-item { display: flex; align-items: center; padding: 0.5rem; border: 1px solid #e2e8f0; border-radius: 4px; margin-bottom: 0.5rem; background: #f8fafc; }
    .field-item.selected { background: #e6fffa; border-color: #48bb78; }
    .field-checkbox { margin-right: 0.75rem; }
    .field-info { flex: 1; }
    .field-name { font-weight: 600; color: #2d3436; margin-bottom: 0.25rem; }
    .field-details { font-size: 0.875rem; color: #718096; }
    .field-type-badge { display: inline-block; padding: 0.25rem 0.5rem; border-radius: 3px; font-size: 0.75rem; font-weight: 600; margin-right: 0.5rem; }
    .field-type-badge.text { background: #e3f2fd; color: #1976d2; }
    .field-type-badge.checkbox { background: #ffebee; color: #d32f2f; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üìÑ PDF Form Extractor (Exact Field Renaming via Low-Level AcroForm)</h1>

    <div class="upload-section">
      <label class="custom-upload-btn" for="pdfInput">Choose PDF File</label>
      <p>or drag and drop PDF here</p>
      <input type="file" id="pdfInput" accept=".pdf" />
    </div>

    <div id="loading">Analyzing PDF... Please wait</div>

    <div class="extracted-text-container">
      <h2 class="section-header">Extracted Document Content</h2>
      <div class="formatted-text" id="formattedOutput"></div>
    </div>

    <div class="pdf-preview-container" id="pdfPreviewContainer" style="display:none;">
      <h2 class="section-header">PDF Preview with Field Highlights</h2>
      <div class="page-navigation" id="pageNavigation" style="margin-bottom: 1rem; text-align: center;">
        <button id="prevPage" class="page-nav-btn" disabled>‚Üê Previous</button>
        <span id="pageInfo">Page 1 of 1</span>
        <button id="nextPage" class="page-nav-btn" disabled>Next ‚Üí</button>
      </div>
      <div class="pdf-preview-wrapper">
        <canvas id="pdfCanvas"></canvas>
        <div id="fieldOverlays" class="field-overlays"></div>
      </div>
    </div>

    <div class="json-controls" id="jsonControls" style="display:none; margin-top: 2rem;">
      <button class="renaming-btn" id="exportJsonBtn">Export Field Names JSON</button>
      <input type="file" id="importJsonInput" accept=".json" style="display:none;" />
      <button class="renaming-btn" id="importJsonBtn">Import Name Change JSON</button>
      <button class="renaming-btn" id="compareIdsBtn">Compare IDs</button>
    </div>

    <!-- Field Selection Modal -->
    <div id="fieldSelectionModal" class="modal" style="display:none;">
      <div class="modal-content">
        <div class="modal-header">
          <h2>Select Fields to Export</h2>
          <span class="close" id="closeModal">&times;</span>
        </div>
        <div class="modal-body">
          <div class="field-list" id="fieldList"></div>
        </div>
        <div class="modal-footer">
          <button class="renaming-btn" id="selectAllBtn">Select All</button>
          <button class="renaming-btn" id="deselectAllBtn">Deselect All</button>
          <button class="renaming-btn" id="exportSelectedBtn">Export Selected</button>
          <button class="renaming-btn" id="cancelExportBtn">Cancel</button>
        </div>
      </div>
    </div>

    <!-- ID Comparison Modal -->
    <div id="idComparisonModal" class="modal" style="display:none;">
      <div class="modal-content">
        <div class="modal-header">
          <h2>Compare Field IDs</h2>
          <span class="close" id="closeComparisonModal">&times;</span>
        </div>
        <div class="modal-body">
          <div class="comparison-input-section">
            <label for="jsonInputTextarea" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #2d3436;">Paste your JSON with field IDs:</label>
            <textarea id="jsonInputTextarea" placeholder="Paste your JSON here..." style="width: 100%; height: 200px; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.875rem; resize: vertical;"></textarea>
          </div>
          <div class="comparison-results" id="comparisonResults" style="display: none; margin-top: 1.5rem;">
            <h3 style="color: #2d3436; margin-bottom: 1rem;">Comparison Results</h3>
            <div class="results-summary" id="resultsSummary" style="background: #f8fafc; padding: 1rem; border-radius: 6px; margin-bottom: 1rem;"></div>
            <div class="unmatched-fields" id="unmatchedFields" style="max-height: 300px; overflow-y: auto;"></div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="renaming-btn" id="compareFieldsBtn">Compare Fields</button>
          <button class="renaming-btn" id="cancelComparisonBtn">Cancel</button>
        </div>
      </div>
    </div>

    <button class="renaming-btn" id="downloadBtn" disabled>Download Updated PDF</button>
  </div>

  <script>
    const pdfInput = document.getElementById('pdfInput');
    const loadingDiv = document.getElementById('loading');
    const formattedOutput = document.getElementById('formattedOutput');
    const downloadBtn = document.getElementById('downloadBtn');
    const pdfPreviewContainer = document.getElementById('pdfPreviewContainer');
    const pdfCanvas = document.getElementById('pdfCanvas');
    const fieldOverlays = document.getElementById('fieldOverlays');
    const prevPageBtn = document.getElementById('prevPage');
    const nextPageBtn = document.getElementById('nextPage');
    const pageInfo = document.getElementById('pageInfo');
    const exportJsonBtn = document.getElementById('exportJsonBtn');
    const importJsonBtn = document.getElementById('importJsonBtn');
    const importJsonInput = document.getElementById('importJsonInput');
    const jsonControls = document.getElementById('jsonControls');
    const fieldSelectionModal = document.getElementById('fieldSelectionModal');
    const closeModal = document.getElementById('closeModal');
    const fieldList = document.getElementById('fieldList');
    const selectAllBtn = document.getElementById('selectAllBtn');
    const deselectAllBtn = document.getElementById('deselectAllBtn');
    const exportSelectedBtn = document.getElementById('exportSelectedBtn');
    const cancelExportBtn = document.getElementById('cancelExportBtn');
    const compareIdsBtn = document.getElementById('compareIdsBtn');
    const idComparisonModal = document.getElementById('idComparisonModal');
    const closeComparisonModal = document.getElementById('closeComparisonModal');
    const jsonInputTextarea = document.getElementById('jsonInputTextarea');
    const compareFieldsBtn = document.getElementById('compareFieldsBtn');
    const cancelComparisonBtn = document.getElementById('cancelComparisonBtn');
    const comparisonResults = document.getElementById('comparisonResults');
    const resultsSummary = document.getElementById('resultsSummary');
    const unmatchedFields = document.getElementById('unmatchedFields');

    let originalFile = null;
    let originalPdfBytes = null;    // Uint8Array (stable copy)
    let normalizedPdfBytes = null;  // Uint8Array starting at %PDF-
    let uploadedFileName = 'updated-fields.pdf';
    let renameMap = {};             // { oldFQN: newName }
    let allFields = [];
    let currentPdf = null;          // PDF.js document
    let currentPageNum = 1;         // Current page being displayed
    let totalPages = 0;             // Total number of pages
    let selectedFields = new Set(); // Track which fields are selected for export

    const lineThreshold = 10;
    const wordSpacingThreshold = 1;

    // ---------- Byte helpers ----------
    function toU8(buf) {
      if (buf instanceof Uint8Array) return buf;
      if (buf instanceof ArrayBuffer) return new Uint8Array(buf);
      if (buf && buf.data instanceof Uint8Array) return buf.data;
      throw new Error('Unsupported buffer type');
    }

    function findPdfHeaderOffset(u8) {
      const sig = [37,80,68,70,45]; // %PDF-
      const n = u8.length - sig.length;
      outer: for (let i = 0; i <= n; i++) {
        for (let j = 0; j < sig.length; j++) {
          if (u8[i + j] !== sig[j]) continue outer;
        }
        return i;
      }
      return -1;
    }

    function strictHeaderCopy(u8) {
      const off = findPdfHeaderOffset(u8);
      if (off < 0) throw new Error('No %PDF- header found');
      if (off === 0) { const out = new Uint8Array(u8.length); out.set(u8); return out; }
      const out = new Uint8Array(u8.length - off); out.set(u8.subarray(off)); return out;
    }

    // ---------- Drag & drop ----------
    document.addEventListener('dragover', e => { e.preventDefault(); document.querySelector('.upload-section').style.borderColor = '#4299e1'; });
    document.addEventListener('dragleave', () => { document.querySelector('.upload-section').style.borderColor = '#a0aec0'; });
    document.addEventListener('drop', e => {
      e.preventDefault();
      document.querySelector('.upload-section').style.borderColor = '#a0aec0';
      const file = e.dataTransfer.files[0];
      if (file) analyzePDF(file);
    });

    pdfInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if (file) analyzePDF(file);
    });

    async function analyzePDF(file) {
      loadingDiv.style.display = 'block';
      formattedOutput.innerHTML = '';
      pdfPreviewContainer.style.display = 'none';
      fieldOverlays.innerHTML = '';
      jsonControls.style.display = 'none';
      renameMap = {};
      downloadBtn.disabled = true;

      try {
        originalFile = file;
        uploadedFileName = file.name || 'updated-fields.pdf';

        const reader = new FileReader();
        reader.onload = async function(e) {
          try {
            const raw = toU8(e.target.result);
            originalPdfBytes = new Uint8Array(raw.length);
            originalPdfBytes.set(raw);

            try { normalizedPdfBytes = strictHeaderCopy(originalPdfBytes); }
            catch (headerErr) { console.warn(headerErr.message); normalizedPdfBytes = null; }

            // Preview via pdf.js
            const pdf = await pdfjsLib.getDocument({ data: originalPdfBytes }).promise;
            currentPdf = pdf;
            totalPages = pdf.numPages;

            let allPagesContent = [];
            allFields = [];

            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
              const page = await pdf.getPage(pageNum);
              const textContent = await page.getTextContent();
              const annotations = await page.getAnnotations();

              let textItems = textContent.items.map(item => ({
                type: 'text', text: item.str,
                xStart: item.transform[4],
                xEnd: item.transform[4] + (item.str.length * 0.6 * Math.abs(item.transform[0])),
                y: item.transform[5]
              }));

              textItems.sort((a, b) => b.y - a.y || a.xStart - b.xStart);

              let lines = [];
              let currentLine = { y: null, items: [] };

              textItems.forEach(ti => {
                if (!currentLine.y || Math.abs(currentLine.y - ti.y) < lineThreshold) {
                  currentLine.items.push(ti);
                  currentLine.y = currentLine.y || ti.y;
                } else {
                  lines.push(currentLine);
                  currentLine = { y: ti.y, items: [ti] };
                }
              });
              if (currentLine.items.length) lines.push(currentLine);

              const pageFields = annotations
                .filter(a => ['Tx', 'Btn'].includes(a.fieldType))
                .map(a => ({
                  name: a.fieldName || 'Unnamed Field',
                  type: 'field',
                  fieldType: a.fieldType,
                  xStart: (a.rect[0] + a.rect[2]) / 2,
                  xEnd: (a.rect[0] + a.rect[2]) / 2,
                  centerY: (a.rect[1] + a.rect[3]) / 2,
                  rect: a.rect,
                  pageNum
                }));

              pageFields.sort((a, b) => b.centerY - a.centerY);
              allFields.push(...pageFields);

              pageFields.forEach(field => {
                const closestLine = lines.reduce((closest, ln) =>
                  Math.abs(ln.y - field.centerY) < Math.abs(closest.y - field.centerY) ? ln : closest
                , { y: Infinity, items: [] });
                field.text = field.fieldType === 'Btn' ? `{{${field.name}}}` : `[[${field.name}]]`;
                closestLine.items.push(field);
              });

              const pageContent = lines.map(ln => {
                ln.items.sort((a, b) => a.xStart - b.xStart);
                let lineParts = [];
                ln.items.forEach((item, i) => {
                  if (item.type === 'field') {
                    const className = item.fieldType === 'Btn' ? 'checkbox-highlight' : 'field-highlight';
                    const dataAttr = `data-original-name="${item.name}" data-field-type="${item.fieldType}"`;
                    lineParts.push(`<span class="${className} renameable-field" ${dataAttr} title="Double-click to rename">${item.text}</span>`);
                  } else {
                    const prev = ln.items[i - 1];
                    const gap = prev ? item.xStart - prev.xEnd : 0;
                    lineParts.push((gap > wordSpacingThreshold ? ' ' : '') + item.text);
                  }
                });
                return `<div class="text-line">${lineParts.join('')}</div>`;
              }).join('');

              allPagesContent.push(pageContent);
            }

            formattedOutput.innerHTML = allPagesContent.join('<div class="page-break"></div>');
            attachRenameListeners();
            
            // Reset page navigation
            currentPageNum = 1;
            updatePageNavigation();
            await renderPDFPreview(pdf, 1);
            
            // Show JSON controls
            jsonControls.style.display = 'block';
            loadingDiv.style.display = 'none';

            downloadBtn.disabled = false;
          } catch (innerErr) {
            loadingDiv.style.display = 'none';
            formattedOutput.innerHTML = `<div style="color:#e53e3e">Error processing PDF: ${innerErr.message}</div>`;
            console.error(innerErr);
          }
        };

        reader.readAsArrayBuffer(file);
      } catch (err) {
        loadingDiv.style.display = 'none';
        formattedOutput.innerHTML = `<div style="color:#e53e3e">Error: ${err.message}</div>`;
        console.error(err);
      }
    }

    function attachRenameListeners() {
      const fields = document.querySelectorAll('.renameable-field');
      fields.forEach(fieldEl => {
        fieldEl.addEventListener('dblclick', () => {
          const oldName = fieldEl.getAttribute('data-original-name');
          const fieldType = fieldEl.getAttribute('data-field-type');
          const promptName = prompt("Enter a new name for this field (exact):", oldName);
          const newName = (promptName || '').trim();

          if (newName && newName !== oldName) {
            renameMap[oldName] = newName;
            fieldEl.textContent = fieldType === 'Btn' ? `{{${newName}}}` : `[[${newName}]]`;
            fieldEl.setAttribute('data-original-name', newName);
          }
        });
      });
    }

    // ---- Low-level AcroForm helpers (no reliance on field.acroField) ----
    function getAcroFormAndFields(pdfDoc) {
      const { PDFName, PDFDict, PDFArray } = PDFLib;
      const context = pdfDoc.context;
      const acroFormRef = pdfDoc.catalog.get(PDFName.of('AcroForm'));
      if (!acroFormRef) throw new Error('No AcroForm found.');
      const acroForm = context.lookup(acroFormRef, PDFDict);
      let fieldsArrRef = acroForm.get(PDFName.of('Fields'));
      let fieldsArr = fieldsArrRef ? context.lookup(fieldsArrRef, PDFArray) : null;
      if (!fieldsArr) {
        fieldsArr = PDFArray.withContext(context);
        acroForm.set(PDFName.of('Fields'), fieldsArr);
      }
      return { acroForm, fieldsArr };
    }

    // Traverse by FQN segments: Fields[] -> Kids[] -> ... -> leaf
    function findFieldNodeByFQN(pdfDoc, fqn) {
      const { PDFName, PDFDict, PDFArray } = PDFLib;
      const context = pdfDoc.context;
      const { fieldsArr } = getAcroFormAndFields(pdfDoc);
      const segments = fqn.split('.');

      // search among an array of refs for a child with /T == seg
      function findInArrayByT(arr, seg) {
        for (let i = 0, n = arr.size(); i < n; i++) {
          const ref = arr.get(i);
          const dict = context.lookup(ref, PDFDict);
          if (!dict) continue;
          const t = dict.get(PDFName.of('T'));
          if (t && t.decodeText ? t.decodeText() === seg : String(t) === seg) return { ref, dict };
        }
        return null;
      }

      // Starting level: root Fields
      let parentRef = null;
      let current = null;

      current = findInArrayByT(fieldsArr, segments[0]);
      if (!current) return null;

      for (let si = 1; si < segments.length; si++) {
        parentRef = current.ref;
        const kidsRef = current.dict.get(PDFName.of('Kids'));
        const kids = kidsRef ? context.lookup(kidsRef, PDFArray) : null;
        if (!kids) return null; // no deeper nodes; FQN not found
        const next = findInArrayByT(kids, segments[si]);
        if (!next) return null;
        current = next;
      }
      return { ref: current.ref, dict: current.dict, parentRef };
    }

    function makeNodeRootAndRename(pdfDoc, nodeRef, nodeDict, newName) {
      const { PDFName, PDFString, PDFArray, PDFDict } = PDFLib;
      const context = pdfDoc.context;
      const { acroForm, fieldsArr } = getAcroFormAndFields(pdfDoc);

      // 1) Remove from its parent /Kids if any
      const parentRef = nodeDict.get(PDFName.of('Parent'));
      if (parentRef) {
        const parentDict = context.lookup(parentRef, PDFDict);
        const kidsRef = parentDict.get(PDFName.of('Kids'));
        const kids = kidsRef ? context.lookup(kidsRef, PDFArray) : null;
        if (kids) {
          const newKids = PDFArray.withContext(context);
          for (let i = 0, n = kids.size(); i < n; i++) {
            const k = kids.get(i);
            if (k !== nodeRef) newKids.push(k);
          }
          parentDict.set(PDFName.of('Kids'), newKids);
        }
        nodeDict.delete(PDFName.of('Parent'));
      }

      // 2) Ensure node is present at root /Fields
      let alreadyRoot = false;
      for (let i = 0, n = fieldsArr.size(); i < n; i++) {
        if (fieldsArr.get(i) === nodeRef) { alreadyRoot = true; break; }
      }
      if (!alreadyRoot) fieldsArr.push(nodeRef);

      // 3) Set its local name /T to the exact target
      nodeDict.set(PDFName.of('T'), PDFString.of(newName));
    }

    // Fallback: if FQN path fails, try to find by leaf name only (last segment)
    function findByLeafNameDeep(pdfDoc, leafName) {
      const { PDFName, PDFDict, PDFArray } = PDFLib;
      const context = pdfDoc.context;
      const { fieldsArr } = getAcroFormAndFields(pdfDoc);

      function dfs(ref, parentRef) {
        const dict = context.lookup(ref, PDFDict);
        if (!dict) return null;
        const t = dict.get(PDFName.of('T'));
        const nameStr = t && t.decodeText ? t.decodeText() : (t ? String(t) : null);
        if (nameStr === leafName) return { ref, dict, parentRef };

        const kidsRef = dict.get(PDFName.of('Kids'));
        const kids = kidsRef ? context.lookup(kidsRef, PDFArray) : null;
        if (kids) {
          for (let i = 0, n = kids.size(); i < n; i++) {
            const childRef = kids.get(i);
            const found = dfs(childRef, ref);
            if (found) return found;
          }
        }
        return null;
      }

      for (let i = 0, n = fieldsArr.size(); i < n; i++) {
        const ref = fieldsArr.get(i);
        const found = dfs(ref, null);
        if (found) return found;
      }
      return null;
    }

    downloadBtn.addEventListener('click', async () => {
      if (!originalPdfBytes || !originalFile) { alert("No PDF loaded yet."); return; }

      // If user didn‚Äôt rename anything, pass-through exact original file
      if (Object.keys(renameMap).length === 0) {
        downloadBlob(originalFile, uploadedFileName);
        return;
      }

      // Need strict header-aligned bytes for pdf-lib editing
      if (!normalizedPdfBytes) {
        alert("This PDF's header isn't where pdf-lib expects it. Try 'Print to PDF' then re-upload.");
        return;
      }

      try {
        const { PDFDocument, PDFName, PDFString } = PDFLib;
        const pdfDoc = await PDFDocument.load(normalizedPdfBytes);

        for (const [oldFQN, newName] of Object.entries(renameMap)) {
          // Try FQN traversal first
          let node = findFieldNodeByFQN(pdfDoc, oldFQN);

          // Fallback: search by leaf name only
          if (!node) {
            const leaf = oldFQN.split('.').pop();
            node = findByLeafNameDeep(pdfDoc, leaf);
          }

          if (!node) {
            console.warn(`Field not found: ${oldFQN}`);
            continue;
          }

          try {
            makeNodeRootAndRename(pdfDoc, node.ref, node.dict, newName);
          } catch (e) {
            console.warn(`Rename failed for "${oldFQN}" -> "${newName}":`, e);
            // last-resort: strip ancestor names, then set /T
            const context = pdfDoc.context;
            const { PDFName, PDFDict } = PDFLib;
            let parentRef = node.dict.get(PDFName.of('Parent'));
            while (parentRef) {
              const parentDict = context.lookup(parentRef, PDFDict);
              if (!parentDict) break;
              parentDict.delete(PDFName.of('T'));
              parentRef = parentDict.get(PDFName.of('Parent'));
            }
            node.dict.set(PDFName.of('T'), PDFLib.PDFString.of(newName));
          }
        }

        const newPdfBytes = await pdfDoc.save();
        downloadBytes(newPdfBytes, "updated-fields.pdf");
      } catch (err) {
        alert("Error renaming fields: " + err.message);
        console.error(err);
      }
    });

    function downloadBlob(blobOrFile, fileName) {
      const url = URL.createObjectURL(blobOrFile);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName || blobOrFile.name || 'file.pdf';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function downloadBytes(u8, fileName) {
      const blob = new Blob([u8], { type: 'application/pdf' });
      downloadBlob(blob, fileName || 'file.pdf');
    }

    async function renderPDFPreview(pdf, pageNum = 1) {
      try {
        const page = await pdf.getPage(pageNum);
        const baseViewport = page.getViewport({ scale: 1.0 });
        const scale = 1.5;
        const viewport = page.getViewport({ scale });

        pdfCanvas.width = viewport.width;
        pdfCanvas.height = viewport.height;
        const context = pdfCanvas.getContext('2d');
        await page.render({ canvasContext: context, viewport }).promise;

        fieldOverlays.innerHTML = '';
        const currentPageFields = allFields.filter(f => f.pageNum === pageNum);

        const toCanvasX = (x) => (x / baseViewport.width) * viewport.width;
        const toCanvasY = (y) => viewport.height - (y / baseViewport.height) * viewport.height;

        currentPageFields.forEach(field => {
          const overlay = document.createElement('div');
          const isCheckbox = field.fieldType === 'Btn';
          let className = isCheckbox ? 'checkbox-field' : 'text-field';
          
          // For checkboxes, we need to determine if they're checked or not
          // Since we can't easily determine the actual state from PDF.js, 
          // we'll use a neutral styling for all checkboxes
          if (isCheckbox) {
            className += ' unchecked'; // Default to unchecked styling
          }
          
          overlay.className = `field-overlay ${className}`;

          const [x0, y0, x1, y1] = field.rect;
          const left = toCanvasX(Math.min(x0, x1));
          const right = toCanvasX(Math.max(x0, x1));
          const bottom = toCanvasY(Math.min(y0, y1));
          const top = toCanvasY(Math.max(y0, y1));

          overlay.style.left = `${left}px`;
          overlay.style.top = `${top}px`;
          overlay.style.width = `${right - left}px`;
          overlay.style.height = `${bottom - top}px`;
          overlay.title = `${isCheckbox ? 'Checkbox' : 'Text Field'}: ${field.name}`;

          fieldOverlays.appendChild(overlay);
        });

        const wrap = document.querySelector('.pdf-preview-wrapper');
        wrap.style.width = viewport.width + 'px';
        wrap.style.height = viewport.height + 'px';

        pdfPreviewContainer.style.display = 'block';
      } catch (error) {
        console.error('Error rendering PDF preview:', error);
      }
    }

    function updatePageNavigation() {
      pageInfo.textContent = `Page ${currentPageNum} of ${totalPages}`;
      prevPageBtn.disabled = currentPageNum <= 1;
      nextPageBtn.disabled = currentPageNum >= totalPages;
    }

    async function goToPage(pageNum) {
      if (pageNum < 1 || pageNum > totalPages || !currentPdf) return;
      currentPageNum = pageNum;
      updatePageNavigation();
      await renderPDFPreview(currentPdf, pageNum);
    }

    // Page navigation event listeners
    prevPageBtn.addEventListener('click', () => goToPage(currentPageNum - 1));
    nextPageBtn.addEventListener('click', () => goToPage(currentPageNum + 1));

    // Export JSON functionality - Show field selection modal
    exportJsonBtn.addEventListener('click', () => {
      showFieldSelectionModal();
    });

    function showFieldSelectionModal() {
      // Initialize all fields as selected by default
      selectedFields.clear();
      allFields.forEach(field => selectedFields.add(field.name));
      
      // Populate the field list
      populateFieldList();
      
      // Show the modal
      fieldSelectionModal.style.display = 'block';
    }

    function populateFieldList() {
      fieldList.innerHTML = '';
      
      allFields.forEach(field => {
        const fieldItem = document.createElement('div');
        fieldItem.className = 'field-item';
        if (selectedFields.has(field.name)) {
          fieldItem.classList.add('selected');
        }
        
        const fieldType = field.fieldType === 'Btn' ? 'checkbox' : 'text';
        const typeClass = field.fieldType === 'Btn' ? 'checkbox' : 'text';
        
        fieldItem.innerHTML = `
          <input type="checkbox" class="field-checkbox" ${selectedFields.has(field.name) ? 'checked' : ''} data-field-name="${field.name}">
          <div class="field-info">
            <div class="field-name">${field.name}</div>
            <div class="field-details">
              <span class="field-type-badge ${typeClass}">${fieldType}</span>
              Page ${field.pageNum}
            </div>
          </div>
        `;
        
        // Add click handler for the entire item
        fieldItem.addEventListener('click', (e) => {
          if (e.target.type !== 'checkbox') {
            const checkbox = fieldItem.querySelector('.field-checkbox');
            checkbox.checked = !checkbox.checked;
            toggleFieldSelection(field.name, checkbox.checked);
          }
        });
        
        // Add checkbox change handler
        const checkbox = fieldItem.querySelector('.field-checkbox');
        checkbox.addEventListener('change', (e) => {
          toggleFieldSelection(field.name, e.target.checked);
        });
        
        fieldList.appendChild(fieldItem);
      });
    }

    function toggleFieldSelection(fieldName, isSelected) {
      const fieldItem = document.querySelector(`[data-field-name="${fieldName}"]`).closest('.field-item');
      
      if (isSelected) {
        selectedFields.add(fieldName);
        fieldItem.classList.add('selected');
      } else {
        selectedFields.delete(fieldName);
        fieldItem.classList.remove('selected');
      }
    }

    // Modal control event listeners
    closeModal.addEventListener('click', () => {
      fieldSelectionModal.style.display = 'none';
    });

    cancelExportBtn.addEventListener('click', () => {
      fieldSelectionModal.style.display = 'none';
    });

    // Close modal when clicking outside of it
    window.addEventListener('click', (e) => {
      if (e.target === fieldSelectionModal) {
        fieldSelectionModal.style.display = 'none';
      }
    });

    // Select All / Deselect All functionality
    selectAllBtn.addEventListener('click', () => {
      allFields.forEach(field => {
        selectedFields.add(field.name);
        const checkbox = document.querySelector(`[data-field-name="${field.name}"]`);
        if (checkbox) {
          checkbox.checked = true;
          checkbox.closest('.field-item').classList.add('selected');
        }
      });
    });

    deselectAllBtn.addEventListener('click', () => {
      selectedFields.clear();
      allFields.forEach(field => {
        const checkbox = document.querySelector(`[data-field-name="${field.name}"]`);
        if (checkbox) {
          checkbox.checked = false;
          checkbox.closest('.field-item').classList.remove('selected');
        }
      });
    });

    // Export selected fields
    exportSelectedBtn.addEventListener('click', () => {
      const selectedFieldData = allFields
        .filter(field => selectedFields.has(field.name))
        .map(field => ({
          id: field.name,
          type: field.fieldType === 'Btn' ? 'checkbox' : 'text',
          page: field.pageNum,
          currentName: field.name
        }));
      
      const jsonData = {
        fields: selectedFieldData,
        exportDate: new Date().toISOString(),
        totalFields: selectedFieldData.length,
        selectedFields: selectedFieldData.length,
        totalAvailableFields: allFields.length
      };
      
      const jsonString = JSON.stringify(jsonData, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'selected-field-names.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      // Close the modal
      fieldSelectionModal.style.display = 'none';
    });

    // Import JSON functionality
    importJsonBtn.addEventListener('click', () => {
      importJsonInput.click();
    });

    importJsonInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const jsonData = JSON.parse(event.target.result);
          
          if (jsonData.fields && Array.isArray(jsonData.fields)) {
            // Clear existing rename map
            renameMap = {};
            
            // Apply imported field name changes
            jsonData.fields.forEach(field => {
              if (field.id && field.newName && field.id !== field.newName) {
                renameMap[field.id] = field.newName;
              }
            });
            
            // Update the display with new names
            updateFieldDisplay();
            
            alert(`Successfully imported ${Object.keys(renameMap).length} field name changes.`);
          } else {
            alert('Invalid JSON format. Expected a "fields" array.');
          }
        } catch (error) {
          alert('Error parsing JSON file: ' + error.message);
        }
      };
      reader.readAsText(file);
    });

    function updateFieldDisplay() {
      // Update the formatted text display
      const fields = document.querySelectorAll('.renameable-field');
      fields.forEach(fieldEl => {
        const oldName = fieldEl.getAttribute('data-original-name');
        if (renameMap[oldName]) {
          const newName = renameMap[oldName];
          const fieldType = fieldEl.getAttribute('data-field-type');
          fieldEl.textContent = fieldType === 'Btn' ? `{{${newName}}}` : `[[${newName}]]`;
          fieldEl.setAttribute('data-original-name', newName);
        }
      });
      
      // Update field overlays in PDF preview
      const overlays = document.querySelectorAll('.field-overlay');
      overlays.forEach(overlay => {
        const title = overlay.getAttribute('title');
        if (title) {
          const match = title.match(/(Checkbox|Text Field): (.+)/);
          if (match) {
            const fieldType = match[1];
            const fieldName = match[2];
            if (renameMap[fieldName]) {
              overlay.setAttribute('title', `${fieldType}: ${renameMap[fieldName]}`);
            }
          }
        }
      });
    }

    // ID Comparison functionality
    compareIdsBtn.addEventListener('click', () => {
      showIdComparisonModal();
    });

    function showIdComparisonModal() {
      // Clear previous results
      comparisonResults.style.display = 'none';
      jsonInputTextarea.value = '';
      
      // Show the modal
      idComparisonModal.style.display = 'block';
    }

    // Close comparison modal event listeners
    closeComparisonModal.addEventListener('click', () => {
      idComparisonModal.style.display = 'none';
    });

    cancelComparisonBtn.addEventListener('click', () => {
      idComparisonModal.style.display = 'none';
    });

    // Close modal when clicking outside of it
    window.addEventListener('click', (e) => {
      if (e.target === idComparisonModal) {
        idComparisonModal.style.display = 'none';
      }
    });

    // Compare fields functionality
    compareFieldsBtn.addEventListener('click', () => {
      performFieldComparison();
    });

    function performFieldComparison() {
      const jsonText = jsonInputTextarea.value.trim();
      
      if (!jsonText) {
        alert('Please paste your JSON with field IDs first.');
        return;
      }

      try {
        const jsonData = JSON.parse(jsonText);
        
        if (!jsonData.inputs || !Array.isArray(jsonData.inputs)) {
          alert('Invalid JSON format. Expected an "inputs" array.');
          return;
        }

        // Extract IDs from the JSON
        const providedIds = new Set(jsonData.inputs.map(input => input.id).filter(id => id));
        
        // Get PDF field names
        const pdfFieldNames = new Set(allFields.map(field => field.name));
        
        // Find unmatched fields (PDF fields that don't have corresponding IDs)
        const unmatchedPdfFields = allFields.filter(field => !providedIds.has(field.name));
        
        // Find unmatched IDs (provided IDs that don't have corresponding PDF fields)
        const unmatchedProvidedIds = Array.from(providedIds).filter(id => !pdfFieldNames.has(id));
        
        // Display results
        displayComparisonResults(unmatchedPdfFields, unmatchedProvidedIds, providedIds.size, pdfFieldNames.size);
        
      } catch (error) {
        alert('Error parsing JSON: ' + error.message);
      }
    }

    function displayComparisonResults(unmatchedPdfFields, unmatchedProvidedIds, totalProvidedIds, totalPdfFields) {
      // Show results section
      comparisonResults.style.display = 'block';
      
      // Update summary
      const matchedCount = totalPdfFields - unmatchedPdfFields.length;
      const matchPercentage = totalPdfFields > 0 ? Math.round((matchedCount / totalPdfFields) * 100) : 0;
      
      resultsSummary.innerHTML = `
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
          <div style="text-align: center;">
            <div style="font-size: 1.5rem; font-weight: bold; color: #48bb78;">${matchedCount}</div>
            <div style="color: #718096; font-size: 0.875rem;">Matched Fields</div>
          </div>
          <div style="text-align: center;">
            <div style="font-size: 1.5rem; font-weight: bold; color: #e53e3e;">${unmatchedPdfFields.length}</div>
            <div style="color: #718096; font-size: 0.875rem;">Unmatched PDF Fields</div>
          </div>
        </div>
        <div style="text-align: center; color: #2d3436; font-weight: 600;">
          Match Rate: ${matchPercentage}% (${matchedCount}/${totalPdfFields})
        </div>
      `;
      
      // Display unmatched PDF fields
      unmatchedFields.innerHTML = '';
      
      if (unmatchedPdfFields.length === 0) {
        unmatchedFields.innerHTML = `
          <div style="text-align: center; padding: 2rem; color: #48bb78; background: #f0fff4; border-radius: 6px; border: 1px solid #9ae6b4;">
            <div style="font-size: 1.2rem; font-weight: bold; margin-bottom: 0.5rem;">üéâ Perfect Match!</div>
            <div>All PDF fields have corresponding IDs in your JSON.</div>
          </div>
        `;
      } else {
        const unmatchedHeader = document.createElement('h4');
        unmatchedHeader.textContent = `PDF Fields Without Matches (${unmatchedPdfFields.length})`;
        unmatchedHeader.style.cssText = 'color: #e53e3e; margin-bottom: 1rem; font-size: 1.1rem;';
        unmatchedFields.appendChild(unmatchedHeader);
        
        unmatchedPdfFields.forEach(field => {
          const fieldItem = document.createElement('div');
          fieldItem.className = 'field-item';
          fieldItem.style.cssText = 'background: #fed7d7; border-color: #feb2b2; margin-bottom: 0.5rem;';
          
          const fieldType = field.fieldType === 'Btn' ? 'checkbox' : 'text';
          const typeClass = field.fieldType === 'Btn' ? 'checkbox' : 'text';
          
          fieldItem.innerHTML = `
            <div class="field-info">
              <div class="field-name" style="color: #c53030;">${field.name}</div>
              <div class="field-details">
                <span class="field-type-badge ${typeClass}">${fieldType}</span>
                Page ${field.pageNum}
              </div>
            </div>
          `;
          
          unmatchedFields.appendChild(fieldItem);
        });
      }
      
      // If there are unmatched provided IDs, show them too
      if (unmatchedProvidedIds.length > 0) {
        const extraIdsHeader = document.createElement('h4');
        extraIdsHeader.textContent = `Provided IDs Without PDF Fields (${unmatchedProvidedIds.length})`;
        extraIdsHeader.style.cssText = 'color: #d69e2e; margin: 1.5rem 0 1rem 0; font-size: 1.1rem;';
        unmatchedFields.appendChild(extraIdsHeader);
        
        unmatchedProvidedIds.forEach(id => {
          const idItem = document.createElement('div');
          idItem.className = 'field-item';
          idItem.style.cssText = 'background: #fef5e7; border-color: #f6e05e; margin-bottom: 0.5rem;';
          
          idItem.innerHTML = `
            <div class="field-info">
              <div class="field-name" style="color: #b7791f;">${id}</div>
              <div class="field-details" style="color: #744210;">
                No corresponding PDF field found
              </div>
            </div>
          `;
          
          unmatchedFields.appendChild(idItem);
        });
      }
    }
  </script>
</body>
</html>
