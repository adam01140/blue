<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Flowchart + Preview Combined</title>

  <!-- mxGraph CDN -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mxgraph@4.2.2/javascript/mxClient.min.js"></script>

  <style>
    /* --------------------- Flowchart Styles --------------------- */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
      user-select: none;
    }
    .toolbar {
      width: 220px;
      background: #f9f9f9;
      border-right: 1px solid #ccc;
      float: left;
      padding: 10px;
      box-sizing: border-box;
    }
    #graphContainer {
      position: absolute;
      left: 220px;
      right: 0;
      top: 0;
      bottom: 0;
      cursor: default;
    }
    .shape {
      background: #fff;
      border: 1px solid #999;
      margin-bottom: 8px;
      text-align: center;
      padding: 6px;
      border-radius: 4px;
      cursor: move;
    }
    .shape:hover {
      background: #e0e0e0;
    }
    .button-bar {
      margin-top: 15px;
    }
    button {
      margin-bottom: 6px;
      padding: 6px 10px;
      background-color: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: block;
      width: 100%;
      box-sizing: border-box;
    }
    button:hover {
      background-color: #0056b3;
    }
    input[type="file"] {
      display: none;
    }
    .context-menu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
      display: none;
      z-index: 1000;
      padding: 5px;
    }
    .context-menu button {
      border: none;
      background: none;
      color: #000;
      padding: 5px 10px;
      text-align: left;
      width: 100%;
      cursor: pointer;
    }
    .context-menu button:hover {
      background-color: #f0f0f0;
    }
    .submenu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      padding: 5px;
      display: none;
      z-index: 2000;
    }
    .submenu button {
      display: block;
      margin-bottom: 4px;
      border: none;
      background: none;
      color: #000;
      padding: 5px 10px;
      text-align: left;
      width: 100%;
      cursor: pointer;
    }
    .submenu button:hover {
      background-color: #f0f0f0;
    }

    /* Properties menu */
    #propertiesMenu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 4px;
      display: none;
      z-index: 3000;
      width: 220px;
    }
    #propertiesMenu p {
      margin: 4px 0;
    }
    .editable-field {
      border: 1px dashed transparent;
      padding: 2px;
      display: inline-block;
      min-width: 50px;
      cursor: text;
    }
    .editable-field:focus {
      outline: 1px dashed #888;
    }

    /* --------------------- Preview Modal Styles --------------------- */
    .modal {
      position: fixed;
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5); 
      z-index: 9999; 
      display: flex;
      justify-content: center; 
      align-items: center;
    }
    .modal-content {
      background-color: #fff; 
      border-radius: 8px; 
      padding: 20px;
      width: 90%;
      max-width: 1200px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      position: relative;
    }
    .modal-content iframe {
      width: 100%; 
      height: 800px; 
      border: none;
    }
    .close {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 25px;
      cursor: pointer;
    }

    /* Minimal styling for the formBuilder area (kept hidden) */
    #formBuilder {
      display: none;
    }

    /* Additional classes used by the generated form (like .hidden, etc.) */
    .hidden {
      display: none !important;
    }

    .thank-you-message {
      display: none;
      margin-top: 40px;
      font-size: 1.2em;
      color: green;
    }
  </style>
</head>

<body>

  <!-- Left toolbar with shapes and buttons -->
  <div class="toolbar">
    <h3>Shapes</h3>
    <!-- Default question node -->
    <div
      class="shape"
      data-type="question"
      data-style="rounded=1;whiteSpace=wrap;html=1;nodeType=question;questionType=dropdown;sectionId=1;nodeId=Question_node;"
    >
      Question Node
    </div>
    <!-- Default options node -->
    <div
      class="shape"
      data-type="options"
      data-style="rounded=1;whiteSpace=wrap;html=1;nodeType=options;questionType=dropdown;sectionId=1;nodeId=Option_node;"
    >
      Options Node
    </div>

    <div class="button-bar">
      <button onclick="exportFlowchartJson()">Export Flowchart JSON</button>
      <button onclick="document.getElementById('importFlowchartFile').click()">Import Flowchart</button>
      <input
        type="file"
        id="importFlowchartFile"
        accept=".json"
        onchange="importFlowchartJson(event)"
      />
      <button onclick="exportGuiJson()">Export GUI JSON</button>
      <!-- New Preview button -->
      <button onclick="previewCurrentGuiJson()">Preview</button>
    </div>
  </div>

  <!-- Graph Container -->
  <div id="graphContainer"></div>

  <!-- Main context menu -->
  <div id="contextMenu" class="context-menu">
    <button id="deleteNode">Delete Node</button>
    <button id="jumpNode">Jump</button>
    <button id="changeType">Change Type &raquo;</button>
    <button id="newSectionButton">New Section</button>
    <button id="propertiesButton">Properties</button>
  </div>

  <!-- Sub-menu for "Change Type" -->
  <div id="typeSubmenu" class="submenu">
    <button id="dropdownType">Drop Down</button>
    <button id="checkboxType">Checkbox</button>
    <button id="textType">Text</button>
    <button id="moneyType">Money</button>
  </div>

  <!-- Properties menu -->
  <div id="propertiesMenu">
    <p><strong>Node Text:</strong>
      <span id="propNodeText" class="editable-field" tabindex="0"></span>
    </p>
    <p><strong>Node ID:</strong>
      <span id="propNodeId" class="editable-field" tabindex="0"></span>
    </p>
    <p><strong>Node Type:</strong> <span id="propNodeType"></span></p>
    <p><strong>Section Name:</strong> <span id="propSectionName"></span></p>
  </div>

  <!-- Hidden builder container (for generating the form in memory) -->
  <div id="formBuilder"></div>

  <!-- Modal for previewing the generated form HTML -->
  <div id="previewModal" class="modal" style="display:none;">
    <div class="modal-content">
      <span class="close" onclick="closePreview()">&times;</span>
      <iframe id="previewFrame"></iframe>
    </div>
  </div>

  <script>
    /********************************************
     * 1) FLOWCHART LOGIC (original flowchart.html)
     ********************************************/
    document.addEventListener("DOMContentLoaded", function () {
      if (typeof mxGraph === "undefined") {
        alert("mxGraph library not found!");
        return;
      }

      const container = document.getElementById("graphContainer");
      const contextMenu = document.getElementById("contextMenu");
      const deleteNodeButton = document.getElementById("deleteNode");
      const jumpNodeButton = document.getElementById("jumpNode");
      const changeTypeButton = document.getElementById("changeType");
      const newSectionButton = document.getElementById("newSectionButton");
      const propertiesButton = document.getElementById("propertiesButton");
      const typeSubmenu = document.getElementById("typeSubmenu");
      const dropdownTypeBtn = document.getElementById("dropdownType");
      const checkboxTypeBtn = document.getElementById("checkboxType");
      const textTypeBtn = document.getElementById("textType");
      const moneyTypeBtn = document.getElementById("moneyType");

      const propertiesMenu = document.getElementById("propertiesMenu");
      const propNodeText = document.getElementById("propNodeText");
      const propNodeId = document.getElementById("propNodeId");
      const propNodeType = document.getElementById("propNodeType");
      const propSectionName = document.getElementById("propSectionName");

      let selectedCell = null;
      let currentMouseEvent = null;
      let lastSelectedCell = null;

      // Track which node is in Jump Mode (only one at a time for simplicity)
      let jumpModeNode = null;
      // Permanent jump style
      const jumpBorderStyle = ";strokeWidth=3;strokeColor=#ff0000;dashed=1;dashPattern=4 4;";

      mxEvent.disableContextMenu(container);

      const graph = new mxGraph(container);
      graph.setPanning(true);
      graph.panningHandler.useLeftButtonForPanning = true;
      graph.setCellsMovable(true);
      graph.setConnectable(true);
      graph.setCellsResizable(true);
      new mxRubberband(graph);

      // Sync node IDs to labels on selection change
      graph.getSelectionModel().addListener(mxEvent.CHANGE, () => {
        if (lastSelectedCell) {
          autoUpdateNodeIdBasedOnLabel(lastSelectedCell);
        }
        lastSelectedCell = graph.getSelectionCell();
      });

      function autoUpdateNodeIdBasedOnLabel(cell) {
        if (!cell.vertex) return;
        const label = (cell.value || "").trim();
        if (!label) return;
        if (isQuestion(cell)) {
          refreshNodeIdFromLabel(cell);
        } else if (isOptions(cell)) {
          refreshOptionNodeId(cell);
        }
      }

      // ---------- Style / ID Helpers ----------
      function setSectionId(cell, sid) {
        if (!cell) return;
        let style = cell.style || "";
        style = style.replace(/sectionId=[^;]+/, "");
        style += `;sectionId=${sid};`;
        graph.getModel().setStyle(cell, style);
      }
      function getSectionId(cell) {
        const style = cell.style || "";
        const m = style.match(/sectionId=([^;]+)/);
        return m ? parseInt(m[1], 10) : 1;
      }

      // skipReassign => permanently skip auto–section logic
      function addSkipReassign(cell) {
        if (!cell) return;
        let style = cell.style || "";
        style = style.replace(/skipReassign=[^;]+/, "");
        style += ";skipReassign=true;";
        graph.getModel().setStyle(cell, style);
      }
      function hasSkipReassign(cell) {
        return cell && cell.style && cell.style.includes("skipReassign=true");
      }

      function setCellColor(cell, color) {
        let style = cell.style || "";
        style = style.replace(/fillColor=[^;]+/, "");
        style += `;fillColor=${color};`;
        graph.getModel().setStyle(cell, style);
      }

      function getQuestionType(cell) {
        const style = cell.style || "";
        const m = style.match(/questionType=([^;]+)/);
        return m ? m[1] : "dropdown";
      }
      function setQuestionType(cell, newType) {
        let style = cell.style || "";
        style = style.replace(/questionType=[^;]+/, "");
        style += `;questionType=${newType};`;
        graph.getModel().setStyle(cell, style);
      }

      function getNodeId(cell) {
        const style = cell.style || "";
        const m = style.match(/nodeId=([^;]+)/);
        return m ? decodeURIComponent(m[1]) : "";
      }
      function setNodeId(cell, nodeId) {
        let style = cell.style || "";
        style = style.replace(/nodeId=[^;]+/, "");
        style += `;nodeId=${encodeURIComponent(nodeId)};`;
        graph.getModel().setStyle(cell, style);
      }

      function isQuestion(cell) {
        return cell && cell.style && cell.style.includes("nodeType=question");
      }
      function isOptions(cell) {
        return cell && cell.style && cell.style.includes("nodeType=options");
      }

      // ---------- refresh logic ----------
      function refreshAllCells() {
        const parent = graph.getDefaultParent();
        const vertices = graph.getChildVertices(parent);

        vertices.forEach((cell) => {
          // If skipReassign => skip auto–section logic
          if (!hasSkipReassign(cell)) {
            // If it's an options node, we often inherit parent's section
            if (isOptions(cell)) {
              const incomingEdges = graph.getIncomingEdges(cell) || [];
              if (incomingEdges.length > 0) {
                const parentCell = incomingEdges[0].source;
                if (parentCell && isQuestion(parentCell)) {
                  const pSec = getSectionId(parentCell);
                  setSectionId(cell, pSec);
                }
              }
            }

            // If it's a question node, we might adjust the section
            if (isQuestion(cell)) {
              const thisSection = getSectionId(cell);
              const incomingEdges = graph.getIncomingEdges(cell) || [];
              const incomingOptions = incomingEdges.filter(e => {
                return e.source && isOptions(e.source);
              });
              if (
                !cell.style.includes("newSection=true") &&
                (thisSection === 1 || thisSection === 0) &&
                incomingOptions.length > 0
              ) {
                const parentOpt = incomingOptions[0].source;
                const parentSectionId = getSectionId(parentOpt);
                setSectionId(cell, parentSectionId);
              }
            }
          }

          colorCell(cell);
          updateOverlay(cell);
        });
      }

      function colorCell(cell) {
        if (!cell.vertex) return;
        let fillColor = "#ADD8E6"; // default fill
        if (isQuestion(cell) && cell.style.includes("newSection=true")) {
          fillColor = "#FFC0CB"; // pink for new-section question
        }
        let style = cell.style || "";
        style = style.replace(/fillColor=[^;]+/, "");
        style += `;fillColor=${fillColor};`;
        graph.getModel().setStyle(cell, style);
      }

      function markAsNewSection(cell) {
        if (!cell) return;
        let style = cell.style || "";
        style = style.replace(/newSection=[^;]+/, "");
        style += ";newSection=true;";
        graph.getModel().setStyle(cell, style);
        setCellColor(cell, "#FFC0CB");
      }

      function updateOverlay(cell) {
        graph.removeCellOverlays(cell);
        if (!cell.vertex) return;
        let text = "node";
        if (isQuestion(cell)) text = getQuestionType(cell);
        else if (isOptions(cell)) text = "options";
        const overlay = new mxCellOverlay(
          // Transparent GIF
          new mxImage("data:image/gif;base64,R0lGODlhAQABAAAAACw=", 1, 1),
          text
        );
        graph.addCellOverlay(cell, overlay);
      }

      // ---------- Context Menu & handlers ----------
      graph.popupMenuHandler.factoryMethod = function (menu, cell, evt) {
        selectedCell = cell;
        currentMouseEvent = evt;
        if (cell) {
          showContextMenu(evt);
        } else {
          hideContextMenu();
        }
      };

      function showContextMenu(evt) {
        contextMenu.style.display = "block";
        contextMenu.style.left = evt.clientX + "px";
        contextMenu.style.top = evt.clientY + "px";
        typeSubmenu.style.display = "none";
      }
      function hideContextMenu() {
        contextMenu.style.display = "none";
        typeSubmenu.style.display = "none";
      }
      document.addEventListener("click", (e) => {
        if (
          !contextMenu.contains(e.target) &&
          !typeSubmenu.contains(e.target) &&
          !propertiesMenu.contains(e.target)
        ) {
          hideContextMenu();
          propertiesMenu.style.display = "none";
        }
      });

      deleteNodeButton.addEventListener("click", () => {
        if (selectedCell) {
          graph.removeCells([selectedCell]);
          refreshAllCells();
        }
        hideContextMenu();
      });

      jumpNodeButton.addEventListener("click", () => {
        if (selectedCell) {
          // If a different node was previously in jump mode, remove that styling
          if (jumpModeNode && jumpModeNode !== selectedCell) {
            removeJumpStyling(jumpModeNode);
          }
          jumpModeNode = selectedCell;
          addJumpStyling(jumpModeNode);
        }
        hideContextMenu();
      });
      function addJumpStyling(cell) {
        if (!cell) return;
        let style = cell.style || "";
        style = style.replace(/strokeWidth=\d+;?/, "");
        style = style.replace(/strokeColor=[^;]+;?/, "");
        style = style.replace(/dashed=\d;?/, "");
        style = style.replace(/dashPattern=[^;]+;?/, "");
        style += jumpBorderStyle;
        graph.getModel().setStyle(cell, style);
      }
      function removeJumpStyling(cell) {
        if (!cell) return;
        let style = cell.style || "";
        style = style.replace(/strokeWidth=\d+;?/, "");
        style = style.replace(/strokeColor=[^;]+;?/, "");
        style = style.replace(/dashed=\d;?/, "");
        style = style.replace(/dashPattern=[^;]+;?/, "");
        graph.getModel().setStyle(cell, style);
      }

      changeTypeButton.addEventListener("click", () => {
        const rect = contextMenu.getBoundingClientRect();
        typeSubmenu.style.display = "block";
        typeSubmenu.style.left = rect.right + "px";
        typeSubmenu.style.top = rect.top + "px";
      });

      dropdownTypeBtn.addEventListener("click", () => {
        if (selectedCell && isQuestion(selectedCell)) {
          setQuestionType(selectedCell, "dropdown");
          selectedCell.value = "Dropdown question node";
          refreshAllCells();
        }
        hideContextMenu();
      });
      checkboxTypeBtn.addEventListener("click", () => {
        if (selectedCell && isQuestion(selectedCell)) {
          setQuestionType(selectedCell, "checkbox");
          selectedCell.value = "Checkbox question node";
          refreshAllCells();
        }
        hideContextMenu();
      });
      textTypeBtn.addEventListener("click", () => {
        if (selectedCell && isQuestion(selectedCell)) {
          setQuestionType(selectedCell, "text");
          selectedCell.value = "Text question node";
          refreshAllCells();
        }
        hideContextMenu();
      });
      moneyTypeBtn.addEventListener("click", () => {
        if (selectedCell && isQuestion(selectedCell)) {
          setQuestionType(selectedCell, "money");
          selectedCell.value = "Money question node";
          refreshAllCells();
        }
        hideContextMenu();
      });

      newSectionButton.addEventListener("click", () => {
        if (selectedCell && isQuestion(selectedCell)) {
          const oldSec = getSectionId(selectedCell);
          const newSec = oldSec + 1;
          setSectionId(selectedCell, newSec);
          markAsNewSection(selectedCell);
          refreshAllCells();
        }
        hideContextMenu();
      });

      propertiesButton.addEventListener("click", () => {
        if (selectedCell) {
          showPropertiesMenu(selectedCell, currentMouseEvent);
        }
        hideContextMenu();
      });

      // ---------- Properties Menu ----------
      function showPropertiesMenu(cell, evt) {
        if (!cell) return;
        propertiesMenu.style.display = "block";
        propertiesMenu.style.left = evt.clientX + 10 + "px";
        propertiesMenu.style.top = evt.clientY + 10 + "px";

        propNodeText.textContent = cell.value || "";
        propNodeId.textContent = getNodeId(cell) || "";
        if (isQuestion(cell)) {
          propNodeType.textContent = getQuestionType(cell);
        } else if (isOptions(cell)) {
          propNodeType.textContent = "options";
        } else {
          propNodeType.textContent = "other";
        }
        const sid = getSectionId(cell);
        propSectionName.textContent = "Section " + sid;
      }
      makeEditableField(propNodeText, onNodeTextFieldChange);
      makeEditableField(propNodeId, onNodeIdFieldChange);

      function makeEditableField(spanEl, onChangeCb) {
        spanEl.addEventListener("dblclick", (e) => {
          e.stopPropagation();
          e.preventDefault();
          spanEl.contentEditable = "true";
          spanEl.focus();
        });
        spanEl.addEventListener("blur", () => {
          spanEl.contentEditable = "false";
          onChangeCb(spanEl.textContent);
        });
        spanEl.addEventListener("keydown", (evt) => {
          if (evt.key === "Enter") {
            evt.preventDefault();
            spanEl.blur();
          }
        });
      }

      function onNodeTextFieldChange(newText) {
        if (!selectedCell) return;
        graph.getModel().beginUpdate();
        try {
          selectedCell.value = newText.trim();
          if (isQuestion(selectedCell)) {
            refreshNodeIdFromLabel(selectedCell);
          } else if (isOptions(selectedCell)) {
            refreshOptionNodeId(selectedCell);
          }
        } finally {
          graph.getModel().endUpdate();
        }
        refreshAllCells();
      }
      function onNodeIdFieldChange(newId) {
        if (!selectedCell) return;
        graph.getModel().beginUpdate();
        try {
          setNodeId(selectedCell, newId);
        } finally {
          graph.getModel().endUpdate();
        }
        refreshAllCells();
      }

      function refreshNodeIdFromLabel(cell) {
        const label = (cell.value || "").toString().trim();
        const nodeId = label.replace(/\s+/g, "_");
        setNodeId(cell, nodeId);
      }
      function refreshOptionNodeId(cell) {
        const edges = graph.getIncomingEdges(cell) || [];
        let parentNodeId = "ParentQuestion";
        for (let e of edges) {
          const p = e.source;
          if (isQuestion(p)) {
            parentNodeId = getNodeId(p) || "ParentQuestion";
            break;
          }
        }
        let label = (cell.value || "Option").toString().trim().replace(/\s+/g, "_");
        setNodeId(cell, parentNodeId + label);
      }

      // Copy/Paste
      const keyHandler = new mxKeyHandler(graph);
      keyHandler.bindControlKey(67, () => {
        mxClipboard.copy(graph);
      });
      keyHandler.bindControlKey(86, () => {
        const pasted = mxClipboard.paste(graph);
        if (pasted && pasted.length > 0) {
          graph.moveCells(pasted, 40, 40);
          refreshAllCells();
        }
      });

      // Drag from shapes
      const toolbarShapes = document.querySelectorAll(".shape");
      toolbarShapes.forEach((shapeEl) => {
        const baseStyle = shapeEl.dataset.style;
        mxUtils.makeDraggable(
          shapeEl,
          graph,
          function (graph, evt, targetCell, x, y) {
            const parent = graph.getDefaultParent();
            graph.getModel().beginUpdate();
            let newVertex;
            try {
              newVertex = graph.insertVertex(
                parent,
                null,
                shapeEl.dataset.type + " node",
                x,
                y,
                100,
                60,
                baseStyle
              );
            } finally {
              graph.getModel().endUpdate();
            }
            if (isQuestion(newVertex)) {
              refreshNodeIdFromLabel(newVertex);
            } else if (isOptions(newVertex)) {
              refreshOptionNodeId(newVertex);
            }
            refreshAllCells();
            return newVertex;
          }
        );
      });

      // If label ends with '?', auto question
      graph.getModel().addListener(mxEvent.EVENT_CHANGE, function (sender, evt) {
        const changes = evt.getProperty("changes");
        if (!changes) return;
        changes.forEach((change) => {
          if (change.constructor.name === "mxValueChange") {
            const { cell, value } = change;
            if (value && typeof value === "string") {
              if (value.trim().endsWith("?")) {
                if (!isQuestion(cell)) {
                  let style = cell.style || "";
                  style += ";nodeType=question;";
                  graph.getModel().setStyle(cell, style);
                  refreshNodeIdFromLabel(cell);
                }
              }
            }
          }
        });
        refreshAllCells();
      });

      // CONNECT logic: child inherits parent's section UNLESS parent is in jump mode
      graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty("cell");
        if (!edge) return;
        const parent = edge.source;
        const child = edge.target;

        const parentIsJump = (parent && parent === jumpModeNode);

        let parentQuestion = null;
        if (parent && isOptions(parent)) {
          parentQuestion = parent.source;
        } else if (parent && isQuestion(parent)) {
          parentQuestion = parent;
        }
        const gpIsJump = (parentQuestion && parentQuestion === jumpModeNode);

        if (parentIsJump || gpIsJump) {
          addSkipReassign(child);
        } else {
          const parentSec = getSectionId(parent);
          setSectionId(child, parentSec);
        }
        refreshAllCells();
      });

      // ---------- Export Flowchart JSON ----------
      window.exportFlowchartJson = function () {
        const data = [];
        const cells = graph.getModel().cells;
        for (let id in cells) {
          if (id === "0" || id === "1") continue; // skip root
          const cell = cells[id];
          data.push({
            id: cell.id,
            value: cell.value,
            geometry: cell.geometry
              ? {
                  x: cell.geometry.x,
                  y: cell.geometry.y,
                  width: cell.geometry.width,
                  height: cell.geometry.height
                }
              : null,
            style: cell.style || "",
            vertex: !!cell.vertex,
            edge: !!cell.edge,
            source: cell.edge ? cell.source?.id : null,
            target: cell.edge ? cell.target?.id : null
          });
        }
        downloadJson(JSON.stringify(data, null, 2), "flowchart_data.json");
      };

      // ---------- Import Flowchart JSON ----------
      window.importFlowchartJson = function (evt) {
        const file = evt.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
          const jsonData = JSON.parse(e.target.result);
          loadFlowchartData(jsonData);
        };
        reader.readAsText(file);
      };

      function loadFlowchartData(data) {
        graph.getModel().beginUpdate();
        try {
          const parent = graph.getDefaultParent();
          graph.removeCells(graph.getChildVertices(parent));
          const createdCells = {};
          // pass1: vertices
          data.forEach((item) => {
            if (item.vertex) {
              const geo = new mxGeometry(
                item.geometry.x,
                item.geometry.y,
                item.geometry.width,
                item.geometry.height
              );
              const newCell = new mxCell(item.value, geo, item.style);
              newCell.vertex = true;
              newCell.id = item.id;
              graph.addCell(newCell, parent);
              createdCells[item.id] = newCell;
            }
          });
          // pass2: edges
          data.forEach((item) => {
            if (item.edge) {
              const newEdge = new mxCell(item.value, new mxGeometry(), item.style);
              newEdge.edge = true;
              newEdge.id = item.id;
              const src = createdCells[item.source];
              const trg = createdCells[item.target];
              graph.addCell(newEdge, parent, undefined, src, trg);
            }
          });
        } finally {
          graph.getModel().endUpdate();
        }
        refreshAllCells();
      }

      function downloadJson(str, filename) {
        const blob = new Blob([str], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // ---------- Export GUI JSON (returns object) ----------
      // We'll store the logic in a function that returns the object
      // but keep a button that can still download it if desired.
      function buildGuiJsonObject() {
        const model = graph.getModel();
        const allCells = model.cells;
        const sectionsMap = {};
        let questionIdCounter = 1;
        let maxSectionId = 1;

        function getNodeType(cell) {
          if (cell.style && cell.style.includes("nodeType=question")) return "question";
          if (cell.style && cell.style.includes("nodeType=options")) return "options";
          return "other";
        }
        function getSectionId(cell) {
          const style = cell.style || "";
          const m = style.match(/sectionId=([^;]+)/);
          return m ? parseInt(m[1], 10) : 1;
        }
        function getQuestionType(cell) {
          const style = cell.style || "";
          const m = style.match(/questionType=([^;]+)/);
          return m ? m[1] : "dropdown";
        }

        // pass1: gather question nodes
        for (let id in allCells) {
          if (id === "0" || id === "1") continue;
          const cell = allCells[id];
          if (cell.vertex && getNodeType(cell) === "question") {
            const sId = getSectionId(cell);
            if (sId > maxSectionId) maxSectionId = sId;
            const label = (cell.value || "").trim() || "Untitled";
            const qType = getQuestionType(cell);

            const questionObj = {
              questionId: questionIdCounter,
              text: label,
              type: qType,
              logic: {
                enabled: false,
                conditions: []
              },
              jump: {
                enabled: false,
                option: "",
                to: ""
              },
              conditionalPDF: {
                enabled: false,
                pdfName: "",
                answer: "Yes"
              },
              conditionalAlert: {
                enabled: false,
                prevQuestion: "",
                prevAnswer: "",
                text: ""
              },
              options: [],
              labels: []
            };
            if (!sectionsMap[sId]) sectionsMap[sId] = [];
            sectionsMap[sId].push(questionObj);

            cell._questionId = questionIdCounter;
            questionIdCounter++;
          }
        }

        // pass2: gather "options" from each question, set logic/jump
        for (let id in allCells) {
          if (id === "0" || id === "1") continue;
          const cell = allCells[id];
          if (cell.vertex && getNodeType(cell) === "question") {
            const sId = getSectionId(cell);
            const label = (cell.value || "").trim() || "Untitled";
            const questionList = sectionsMap[sId] || [];
            const qObj = questionList.find(q => q.text === label);
            if (!qObj) continue;

            const outEdges = graph.getOutgoingEdges(cell) || [];
            outEdges.forEach(edge => {
              const target = edge.target;
              if (!target) return;
              if (getNodeType(target) === "options") {
                const optLabel = (target.value || "Option").trim();
                const optNodeId = getNodeId(target);

                if (qObj.type === "checkbox") {
                  qObj.options.push({
                    label: capitalizeFirst(optLabel),
                    nameId: optNodeId,
                    value: ""
                  });
                } else {
                  qObj.options.push(capitalizeFirst(optLabel));
                }

                // nextEdges might lead to a question
                const nextEdges = graph.getOutgoingEdges(target) || [];
                nextEdges.forEach(ne => {
                  const q2 = ne.target;
                  if (q2 && getNodeType(q2) === "question") {
                    const q2Sid = getSectionId(q2);
                    const questionList2 = sectionsMap[q2Sid] || [];
                    const q2Obj = questionList2.find(o => o.text === (q2.value || "").trim());
                    if (!q2Obj) return;

                    // If it references an earlier question => jump
                    if (q2._questionId < cell._questionId) {
                      qObj.jump.enabled = true;
                      qObj.jump.option = capitalizeFirst(optLabel);
                      qObj.jump.to = q2._questionId.toString();
                    } else {
                      // If it references a later question => logic
                      q2Obj.logic.enabled = true;
                      q2Obj.logic.conditions.push({
                        prevQuestion: qObj.questionId.toString(),
                        prevAnswer: capitalizeFirst(optLabel)
                      });
                    }
                  }
                });
              }
            });
          }
        }

        // finalize
        const sectionsArr = [];
        for (let s = 1; s <= maxSectionId; s++) {
          const qList = sectionsMap[s] || [];
          sectionsArr.push({
            sectionId: s,
            sectionName: "Section " + s,
            questions: qList
          });
        }

        return {
          sections: sectionsArr,
          hiddenFields: [],
          sectionCounter: maxSectionId + 1,
          questionCounter: questionIdCounter,
          hiddenFieldCounter: 1,
          defaultPDFName: ""
        };
      }

      window.exportGuiJson = function () {
        const guiData = buildGuiJsonObject();
        const jsonStr = JSON.stringify(guiData, null, 2);
        // Download
        downloadJson(jsonStr, "gui_data.json");
      };

      // We'll use this function to generate GUI JSON and immediately preview
      window.previewCurrentGuiJson = function() {
        const guiData = buildGuiJsonObject();
        // load into form builder memory
        loadFormData(guiData);
        // show the preview modal
        previewForm();
      };

      // simple helper
      function capitalizeFirst(str) {
        if (!str) return str;
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
    });

    /********************************************
     * 2) (Merged) "EXPORT.HTML" LOGIC FOR PREVIEW
     *    - We'll embed the relevant code below.
     ********************************************/

    // We replicate some global counters:
    let sectionCounter = 1;
    let questionCounter = 1;
    let hiddenFieldCounter = 1; // if needed

    /**********************************************
     * Minimal stubs that let us reconstruct the form
     **********************************************/
    function initializeHiddenPDFFieldsModule() {
      const formBuilder = document.getElementById('formBuilder');
      let hiddenFieldsModule = document.getElementById('hiddenFieldsModule');
      if (!hiddenFieldsModule) {
        hiddenFieldsModule = document.createElement('div');
        hiddenFieldsModule.id = 'hiddenFieldsModule';
        hiddenFieldsModule.innerHTML = `
          <h2 style="display:none;">Hidden Fields</h2>
          <div id="hiddenFieldsContainer"></div>
        `;
        formBuilder.appendChild(hiddenFieldsModule);
      }
    }

    function addSection(sectionId = null) {
      const formBuilder = document.getElementById('formBuilder');
      const sectionBlock = document.createElement('div');

      const currentSectionId = sectionId || sectionCounter;
      sectionBlock.className = 'section-block';
      sectionBlock.id = `sectionBlock${currentSectionId}`;

      sectionBlock.innerHTML = `
        <h2 id="sectionLabel${currentSectionId}">Section ${currentSectionId}</h2>
        <label>Section Name: </label>
        <input type="text" id="sectionName${currentSectionId}" placeholder="Enter section name"
               value="Section ${currentSectionId}"
               oninput="updateSectionName(${currentSectionId})"><br><br>
        <div id="questionsSection${currentSectionId}"></div>
        <hr>
      `;
      formBuilder.appendChild(sectionBlock);

      if (!sectionId) {
        sectionCounter++;
      }
    }

    function updateSectionName(sectionId) {
      const sectionNameInput = document.getElementById(`sectionName${sectionId}`);
      const sectionLabel = document.getElementById(`sectionLabel${sectionId}`);
      if (sectionLabel && sectionNameInput) {
        sectionLabel.textContent = sectionNameInput.value;
      }
    }

    function addQuestion(sectionId, questionId = null) {
      const questionsSection = document.getElementById(`questionsSection${sectionId}`);
      const questionBlock = document.createElement('div');

      const currentQuestionId = questionId || questionCounter;
      questionBlock.className = 'question-block';
      questionBlock.id = `questionBlock${currentQuestionId}`;

      questionBlock.innerHTML = `
        <label>Question ${currentQuestionId}: </label>
        <input type="text" placeholder="Enter your question" id="question${currentQuestionId}"><br><br>

        <label>Question Type: </label>
        <select id="questionType${currentQuestionId}">
          <option value="text">Text</option>
          <option value="radio">Yes/No</option>
          <option value="dropdown">Dropdown</option>
          <option value="checkbox">Checkbox</option>
          <option value="numberedDropdown">Numbered Dropdown</option>
          <option value="multipleTextboxes">Multiple Textboxes</option>
          <option value="money">Money</option>
          <option value="date">Date</option>
          <option value="bigParagraph">Big Paragraph</option>
        </select><br><br>

        <div id="dropdownOptions${currentQuestionId}" style="display:none;"></div>
        <div id="checkboxOptions${currentQuestionId}" style="display:none;"></div>
        <div id="multipleTextboxesOptions${currentQuestionId}" style="display:none;"></div>
        <div id="textboxOptions${currentQuestionId}" style="display:none;"></div>
        <div id="numberedDropdownBlock${currentQuestionId}" style="display:none;"></div>

        <div id="logicBlock${currentQuestionId}" style="display:none;"></div>
        <div id="jumpBlock${currentQuestionId}" style="display:none;"></div>
        <div id="conditionalPDFBlock${currentQuestionId}" style="display:none;"></div>
        <div id="conditionalAlertBlock${currentQuestionId}" style="display:none;"></div>
      `;
      questionsSection.appendChild(questionBlock);

      if (!questionId) {
        questionCounter++;
      }
    }

    function addHiddenField() {
      const hiddenFieldsContainer = document.getElementById('hiddenFieldsContainer');
      const hiddenFieldBlock = document.createElement('div');
      const currentHiddenFieldId = hiddenFieldCounter;

      hiddenFieldBlock.className = 'hidden-field-block';
      hiddenFieldBlock.id = `hiddenFieldBlock${currentHiddenFieldId}`;
      hiddenFieldBlock.innerHTML = `
        <label>Hidden Field ${currentHiddenFieldId}: </label>
        <select id="hiddenFieldType${currentHiddenFieldId}">
          <option value="text">Textbox</option>
          <option value="checkbox">Checkbox</option>
        </select>
        <div id="hiddenFieldOptions${currentHiddenFieldId}"></div>
      `;
      hiddenFieldsContainer.appendChild(hiddenFieldBlock);
      hiddenFieldCounter++;
    }

    /**********************************************
     * This builds the final HTML for the preview
     **********************************************/
    function getFormHTML() {
    let formHTML = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Custom Form</title>
        <link rel="stylesheet" href="generate.css">
    </head>
    <body>
    <header>
        <img src="logo.png" alt="FormWiz Logo" width="130" height="80" onclick="location.href='index.html';">
        <nav>
            <a href="index.html">Home</a>
            <a href="forms.html">Forms</a>
            <a href="contact.html">Contact Us</a>
        </nav>
    </header>
    <div id="pdfPreview" style="display:none;">
        <iframe id="pdfFrame" style="display:none"></iframe>
    </div>
    <input type="text" id="current_date" name="current_date" placeholder="current_date" style="display:none">
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"><\/script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"><\/script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"><\/script>
    <div id="questions">
        <div id="result"></div>
        <section>
        <div id="box">
            <form id="customForm" onsubmit="return showThankYouMessage();">
    `;

    // We track single-element question IDs to help us attach logic
    let questionNameIds = {};
    // We also track question types. e.g. questionTypesMap[questionId] = "checkbox"
    let questionTypesMap = {};

    // For conditional PDFs & alerts
    let conditionalPDFs = [];
    let conditionalAlerts = [];

    // For jump logic
    let jumpLogics = [];

    // Possibly read a PDF name if user typed it, else default
    const pdfFormNameInput = document.getElementById('formPDFName')
        ? document.getElementById('formPDFName').value.trim()
        : '';
    const pdfFormName = pdfFormNameInput || 'default.pdf';
    const escapedPdfFormName = pdfFormName
        .replace(/\\/g, '\\\\')
        .replace(/'/g, '\\\'')
        .replace(/"/g, '\\"');

    // Build each section
    for (let s = 1; s < sectionCounter; s++) {
        const sectionBlock = document.getElementById(`sectionBlock${s}`);
        if (!sectionBlock) continue;

        const sectionNameInput = sectionBlock.querySelector(`#sectionName${s}`);
        const sectionName = sectionNameInput ? sectionNameInput.value : `Section ${s}`;

        // Start the section
        formHTML += `<div id="section${s}" class="section${s === 1 ? ' active' : ''}">`;
        formHTML += `<h2>${sectionName}</h2>`;

        // For each question in that section
        const questionsSection = sectionBlock.querySelectorAll('.question-block');
        questionsSection.forEach((questionBlock) => {
            const questionId = questionBlock.id.replace('questionBlock', '');
            const questionText = questionBlock.querySelector(`#question${questionId}`).value;
            const questionType = questionBlock.querySelector(`#questionType${questionId}`).value;

            questionTypesMap[questionId] = questionType;

            // Check logic
            const logicCheckbox = questionBlock.querySelector(`#logic${questionId}`);
            const logicEnabled = logicCheckbox ? logicCheckbox.checked : false;

            // Jump logic
            const jumpCheckbox = questionBlock.querySelector(`#enableJump${questionId}`);
            const jumpEnabled = jumpCheckbox ? jumpCheckbox.checked : false;
            const jumpToInput = questionBlock.querySelector(`#jumpTo${questionId}`);
            const jumpOptionSelect = questionBlock.querySelector(`#jumpOption${questionId}`);
            const jumpTo = jumpToInput ? jumpToInput.value : '';
            const jumpOption = jumpOptionSelect ? jumpOptionSelect.value : '';

            // If jump is enabled, store it for later
            if (jumpEnabled && jumpTo) {
                jumpLogics.push({
                    questionId,
                    questionNameId: '',
                    jumpOption,
                    jumpTo,
                    section: s,
                    questionType
                });
            }

            // Conditional PDF
            const conditionalPDFCheckbox = questionBlock.querySelector(`#enableConditionalPDF${questionId}`);
            const conditionalPDFEnabled = conditionalPDFCheckbox ? conditionalPDFCheckbox.checked : false;
            const conditionalPDFNameEl = questionBlock.querySelector(`#conditionalPDFName${questionId}`);
            const conditionalPDFAnswerEl = questionBlock.querySelector(`#conditionalPDFAnswer${questionId}`);
            const conditionalPDFName = conditionalPDFNameEl ? conditionalPDFNameEl.value : '';
            const conditionalPDFAnswer = conditionalPDFAnswerEl ? conditionalPDFAnswerEl.value : '';

            // Conditional Alert
            const alertCheckbox = questionBlock.querySelector(`#enableConditionalAlert${questionId}`);
            const conditionalAlertEnabled = alertCheckbox ? alertCheckbox.checked : false;
            const alertPrevQ = questionBlock.querySelector(`#alertPrevQuestion${questionId}`);
            const alertPrevA = questionBlock.querySelector(`#alertPrevAnswer${questionId}`);
            const alertTextEl = questionBlock.querySelector(`#alertText${questionId}`);
            const alertPrevQuestion = alertPrevQ ? alertPrevQ.value : '';
            const alertPrevAnswer = alertPrevA ? alertPrevA.value : '';
            const alertText = alertTextEl ? alertTextEl.value : '';

            if (conditionalAlertEnabled && alertPrevQuestion && alertPrevAnswer && alertText) {
                conditionalAlerts.push({
                    questionId,
                    prevQuestionId: alertPrevQuestion,
                    prevAnswer: alertPrevAnswer,
                    alertText
                });
            }

            // Build the question container
            formHTML += `<div id="question-container-${questionId}" ${logicEnabled ? 'class="hidden"' : ''}>`;
            formHTML += `<label><h3>${questionText}</h3></label>`;

            // Now create the actual question input(s)
            if (questionType === 'text') {
                const textboxName = questionBlock.querySelector(`#textboxName${questionId}`);
                const textboxPlaceholder = questionBlock.querySelector(`#textboxPlaceholder${questionId}`);
                const nameId = textboxName ? (textboxName.value || `answer${questionId}`) : `answer${questionId}`;
                const placeholder = textboxPlaceholder ? textboxPlaceholder.value : '';
                questionNameIds[questionId] = nameId;
                formHTML += `<input type="text" id="${nameId}" name="${nameId}" placeholder="${placeholder}"><br><br>`;

            } else if (questionType === 'bigParagraph') {
                const textboxName = questionBlock.querySelector(`#textboxName${questionId}`);
                const textboxPlaceholder = questionBlock.querySelector(`#textboxPlaceholder${questionId}`);
                const nameId = textboxName ? (textboxName.value || `answer${questionId}`) : `answer${questionId}`;
                const placeholder = textboxPlaceholder ? textboxPlaceholder.value : '';
                questionNameIds[questionId] = nameId;
                formHTML += `<textarea id="${nameId}" name="${nameId}" rows="5" cols="50" placeholder="${placeholder}"></textarea><br>`;

            } else if (questionType === 'radio') {
                const textboxName = questionBlock.querySelector(`#textboxName${questionId}`);
                const nameId = textboxName ? (textboxName.value || `answer${questionId}`) : `answer${questionId}`;
                questionNameIds[questionId] = nameId;
                formHTML += `
                    <select id="${nameId}" name="${nameId}">
                        <option value="" disabled selected>Select an option</option>
                        <option value="Yes">Yes</option>
                        <option value="No">No</option>
                    </select><br>
                `;
                if (conditionalPDFEnabled) {
                    conditionalPDFs.push({
                        questionId,
                        questionNameId: nameId,
                        conditionalAnswer: conditionalPDFAnswer,
                        pdfName: conditionalPDFName,
                        questionType
                    });
                }

            } else if (questionType === 'dropdown') {
                const textboxName = questionBlock.querySelector(`#textboxName${questionId}`);
                const nameId = textboxName ? (textboxName.value || `answer${questionId}`) : `answer${questionId}`;
                questionNameIds[questionId] = nameId;

                formHTML += `<select id="${nameId}" name="${nameId}">`;
                formHTML += `<option value="" disabled selected>Select an option</option>`;

                // Gather the dropdown options from the DOM
                const optionInputs = questionBlock.querySelectorAll('#dropdownOptions' + questionId + ' input');
                optionInputs.forEach(input => {
                    const val = input.value;
                    formHTML += `<option value="${val}">${val}</option>`;
                });

                formHTML += `</select><br>`;

            } else if (questionType === 'checkbox') {
                // Gather the <div> elements that contain each checkbox option
                const optionsDivs = questionBlock.querySelectorAll(`#checkboxOptions${questionId} > div`);
                const checkboxOptions = [];

                formHTML += `<div><center><div id="checkmark">`;

                optionsDivs.forEach((optionDiv, index) => {
                    const optTextEl = optionDiv.querySelector(`#checkboxOptionText${questionId}_${index + 1}`);
                    const optNameEl = optionDiv.querySelector(`#checkboxOptionName${questionId}_${index + 1}`);
                    const optValueEl = optionDiv.querySelector(`#checkboxOptionValue${questionId}_${index + 1}`);

                    let optionText = optTextEl ? optTextEl.value.trim() : `Option ${index + 1}`;
                    let optionNameId = optNameEl ? optNameEl.value.trim() : "";
                    let optionValue = optValueEl ? optValueEl.value.trim() : "";

                    // Force a consistent prefix
                    const forcedPrefix = `answer${questionId}_`;
                    if (!optionNameId) {
                        const sanitized = optionText.replace(/\W+/g, "_").toLowerCase();
                        optionNameId = forcedPrefix + sanitized;
                    } else {
                        if (!optionNameId.startsWith(forcedPrefix)) {
                            optionNameId = forcedPrefix + optionNameId;
                        }
                    }
                    if (!optionValue) {
                        optionValue = optionText;
                    }

                    checkboxOptions.push({ optionText, optionNameId, optionValue });

                    // Render the checkbox
                    formHTML += `
                        <span class="checkbox-inline">
                            <label class="checkbox-label">
                                <input type="checkbox" id="${optionNameId}" name="${optionNameId}" value="${optionValue}">
                                ${optionText}
                            </label>
                        </span>
                    `;
                });

                // **FIX**: Safely check for the "noneOfTheAbove" element
                const noneOfTheAboveEl = questionBlock.querySelector(`#noneOfTheAbove${questionId}`);
                const noneOfTheAboveSelected = noneOfTheAboveEl ? noneOfTheAboveEl.checked : false;

                if (noneOfTheAboveSelected) {
                    const optionText = 'None of the above';
                    const forcedPrefix = `answer${questionId}_`;
                    const sanitized = optionText.replace(/\W+/g, "_").toLowerCase();
                    const optionNameId = forcedPrefix + sanitized;
                    const optionValue = optionText;

                    checkboxOptions.push({ optionText, optionNameId, optionValue });

                    formHTML += `
                        <span class="checkbox-inline">
                            <label class="checkbox-label">
                                <input type="checkbox" id="${optionNameId}" name="${optionNameId}" value="${optionValue}">
                                ${optionText}
                            </label>
                        </span>
                    `;
                }

                formHTML += `</div><br></div>`;

                // Conditional PDF if any
                if (conditionalPDFEnabled) {
                    const matchingOption = checkboxOptions.find(opt => opt.optionText === conditionalPDFAnswer);
                    if (matchingOption) {
                        conditionalPDFs.push({
                            questionId,
                            questionNameId: matchingOption.optionNameId,
                            conditionalAnswer: matchingOption.optionValue,
                            pdfName: conditionalPDFName,
                            questionType
                        });
                    }
                }

            } else if (questionType === 'numberedDropdown') {
                const rangeStartEl = questionBlock.querySelector(`#numberRangeStart${questionId}`);
                const rangeEndEl = questionBlock.querySelector(`#numberRangeEnd${questionId}`);
                const start = rangeStartEl ? parseInt(rangeStartEl.value) : 1;
                const end = rangeEndEl ? parseInt(rangeEndEl.value) : 1;
                const labels = questionBlock.querySelectorAll(`#textboxLabels${questionId} input`);
                const labelValues = Array.from(labels).map(label => label.value);

                formHTML += `<select id="answer${questionId}" onchange="showTextboxLabels(${questionId}, this.value)">
                                <option value="" disabled selected>Select an option</option>`;
                for (let i = start; i <= end; i++) {
                    formHTML += `<option value="${i}">${i}</option>`;
                }
                formHTML += `</select><br>
                             <div id="labelContainer${questionId}"></div>
                             <script>
                                 var labels${questionId} = ${JSON.stringify(labelValues)};
                                 function showTextboxLabels(questionId, count) {
                                     const container = document.getElementById('labelContainer' + questionId);
                                     container.innerHTML = '';
                                     for (let j = 1; j <= count; j++) {
                                         labels${questionId}.forEach(function(label) {
                                             const inputId = label.replace(/\\s+/g, '') + j;
                                             container.innerHTML += '<input type="text" id="' + inputId + '" name="' + inputId + '" placeholder="' + label + ' ' + j + '" style="text-align:center;"><br>';
                                         });
                                     }
                                 }
                             <\/script>`;

            } else if (questionType === 'multipleTextboxes') {
                const multiBlocks = questionBlock.querySelectorAll(`#multipleTextboxesOptions${questionId} > div`);
                multiBlocks.forEach((optionDiv, index) => {
                    const labelInput = optionDiv.querySelector(`#multipleTextboxLabel${questionId}_${index + 1}`);
                    const nameIdInput = optionDiv.querySelector(`#multipleTextboxName${questionId}_${index + 1}`);
                    const placeholderInput = optionDiv.querySelector(`#multipleTextboxPlaceholder${questionId}_${index + 1}`);

                    const labelText = labelInput ? labelInput.value.trim() : '';
                    const nameId = nameIdInput ? (nameIdInput.value.trim() || `answer${questionId}_${index + 1}`) : `answer${questionId}_${index + 1}`;
                    const placeholder = placeholderInput ? placeholderInput.value.trim() : '';

                    if (labelText) {
                        formHTML += `<label><h3>${labelText}</h3></label><br>`;
                    }
                    formHTML += `<input type="text" id="${nameId}" name="${nameId}" placeholder="${placeholder}" style="text-align:center;"><br>`;
                });

            } else if (questionType === 'money') {
                const textboxName = questionBlock.querySelector(`#textboxName${questionId}`);
                const textboxPlaceholder = questionBlock.querySelector(`#textboxPlaceholder${questionId}`);
                const nameId = textboxName ? (textboxName.value || `answer${questionId}`) : `answer${questionId}`;
                const placeholder = textboxPlaceholder ? textboxPlaceholder.value : 'Enter amount';
                questionNameIds[questionId] = nameId;
                formHTML += `<input type="number" id="${nameId}" name="${nameId}" min="0" step="0.01" placeholder="${placeholder}"><br>`;

            } else if (questionType === 'date') {
                formHTML += `<input type="date" id="answer${questionId}" name="answer${questionId}" placeholder="Enter a date"><br>`;
            }

            // Close question container
            formHTML += `</div>`;

            // =============== MULTIPLE OR LOGIC ===============
            if (logicEnabled) {
                // We'll find all .logic-condition-row for this question
                const logicRows = questionBlock.querySelectorAll(`.logic-condition-row`);
                if (logicRows.length > 0) {
                    formHTML += `
                    <script>
                        (function(){
                            var thisQ = document.getElementById('question-container-${questionId}');
                            function updateVisibility() {
                                var anyMatch = false;
                    `;
                    logicRows.forEach((row, idx) => {
                        const rowIndex = idx + 1;
                        const prevQNumEl = row.querySelector(`#prevQuestion${questionId}_${rowIndex}`);
                        const prevAnswerEl = row.querySelector(`#prevAnswer${questionId}_${rowIndex}`);
                        const prevQNum = prevQNumEl ? prevQNumEl.value.trim() : "";
                        const prevAnswer = prevAnswerEl ? prevAnswerEl.value.trim().toLowerCase() : "";
                        if (!prevQNum || !prevAnswer) return;

                        const pType = questionTypesMap[prevQNum] || 'text';
                        formHTML += `
                                (function checkCond${idx}(){
                                    var cPrevType = '${pType}';
                                    var cPrevA = '${prevAnswer}';
                                    var cPrevQNum = '${prevQNum}';
                                    if (cPrevType === 'checkbox') {
                                        var cbs = document.querySelectorAll('input[id^="answer' + cPrevQNum + '_"]');
                                        var checkedVals = [];
                                        cbs.forEach(cb => { if(cb.checked) checkedVals.push(cb.value.trim().toLowerCase()); });
                                        if (checkedVals.includes(cPrevA)) {
                                            anyMatch = true;
                                        }
                                    } else {
                                        var el = document.getElementById('answer' + cPrevQNum);
                                        if (el) {
                                            var val = el.value.trim().toLowerCase();
                                            if (val === cPrevA) {
                                                anyMatch = true;
                                            }
                                        }
                                    }
                                })();
                        `;
                    });
                    formHTML += `
                                if (anyMatch) {
                                    thisQ.classList.remove('hidden');
                                } else {
                                    thisQ.classList.add('hidden');
                                }
                            }
                    `;
                    logicRows.forEach((row, idx) => {
                        const rowIndex = idx + 1;
                        const prevQNumEl = row.querySelector(`#prevQuestion${questionId}_${rowIndex}`);
                        const prevQNum = prevQNumEl ? prevQNumEl.value.trim() : "";
                        const pType = questionTypesMap[prevQNum] || 'text';
                        if (!prevQNum) return;

                        if (pType === 'checkbox') {
                            formHTML += `
                            (function attachEvent${idx}(){
                                var cbs = document.querySelectorAll('input[id^="answer${prevQNum}_"]');
                                cbs.forEach(cb => { cb.addEventListener('change', updateVisibility); });
                            })();
                            `;
                        } else {
                            formHTML += `
                            (function attachEvent${idx}(){
                                var singleEl = document.getElementById('answer${prevQNum}');
                                if (singleEl) {
                                    singleEl.addEventListener('change', updateVisibility);
                                }
                            })();
                            `;
                        }
                    });
                    formHTML += `
                            updateVisibility();
                        })();
                    <\/script>
                    `;
                }
            }
        }); // end forEach question

        // Section-level navigation
        formHTML += `<br><br><div class="navigation-buttons">`;
        if (s > 1) {
            formHTML += `<button type="button" onclick="navigateSection(${s - 1})">Back</button>`;
        }
        if (s === sectionCounter - 1) {
            formHTML += `<button type="submit">Submit</button>`;
        } else {
            formHTML += `<button type="button" onclick="handleNext(${s})">Next</button>`;
        }
        formHTML += `</div>`; // close nav-buttons

        // Close the section
        formHTML += `</div>`;
    }

    // Insert hidden fields (stub)
    const { hiddenFieldsHTML, autofillMappings, conditionalAutofillLogic } = generateHiddenPDFFields();
    formHTML += hiddenFieldsHTML;

    // Finish the form & page
    formHTML += `
            </form>
            <div id="thankYouMessage" class="thank-you-message">Thank you for completing the survey</div>
        </div>
        </section>
    </div>
    <footer>
        &copy; 2024 FormWiz. All rights reserved.
    </footer>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyDS-tSSn7fdLBgwzfHQ_1MPG1w8S_4qb04",
            authDomain: "formwiz-3f4fd.firebaseapp.com",
            projectId: "formwiz-3f4fd",
            storageBucket: "formwiz-3f4fd.appspot.com",
            messagingSenderId: "404259212529",
            appId: "1:404259212529:web:15a33bce82383b21cfed50",
            measurementId: "G-P07YEN0HPD"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const urlParams = new URLSearchParams(window.location.search);
        const formId = urlParams.get('formId');
        let userId = null;

        firebase.auth().onAuthStateChanged(user => {
            if (user) {
                userId = user.uid;
            } else {
                console.log("User not logged in.");
                window.location.href = 'account.html';
            }
        });

        function saveFormData(sectionId) {
            // Example of saving data
            const formData = {};
            const inputs = document.querySelectorAll('#' + sectionId + ' input, #' + sectionId + ' select, #' + sectionId + ' textarea');
            inputs.forEach(input => {
                if (input.tagName === 'INPUT' && input.type === 'checkbox') {
                    formData[input.name] = input.checked;
                } else {
                    formData[input.name] = input.value;
                }
            });
        }
        function loadFormData(sectionId) {
            // omitted for brevity
        }
        function autoSaveForm(sectionId) {
            const inputs = document.querySelectorAll('#' + sectionId + ' input, #' + sectionId + ' select, #' + sectionId + ' textarea');
            inputs.forEach(input => {
                // input.addEventListener('change', () => saveFormData(sectionId));
            });
        }

        // We'll re-inject our jumpLogics array below
        var jumpLogics = ${JSON.stringify(jumpLogics)};

        // We'll also store the questionNameIds map
        var questionNameIds = ${JSON.stringify(questionNameIds)};

        function handleNext(currentSection) {
            // default next section
            let nextSection = currentSection + 1;
            // filter jumpLogics
            const relevantJumps = jumpLogics.filter(j => j.section == currentSection);
            // check if user choice matches jumpOption
            for (let i = 0; i < relevantJumps.length; i++) {
                const jlogic = relevantJumps[i];
                const { questionId, questionType, jumpOption, jumpTo } = jlogic;
                const nameId = questionNameIds[questionId] || ('answer' + questionId);

                if (questionType === 'radio' || questionType === 'dropdown') {
                    const el = document.getElementById(nameId);
                    if (el && el.value.trim().toLowerCase() === jumpOption.trim().toLowerCase()) {
                        nextSection = jumpTo;
                        break;
                    }
                } else if (questionType === 'checkbox') {
                    const cbs = document.querySelectorAll('input[id^="answer' + questionId + '_"]');
                    if (cbs && cbs.length > 0) {
                        const selectedValues = [];
                        cbs.forEach(cb => {
                            if (cb.checked) selectedValues.push(cb.value.trim().toLowerCase());
                        });
                        if (selectedValues.includes(jumpOption.trim().toLowerCase())) {
                            nextSection = jumpTo;
                            break;
                        }
                    }
                }
            }
            navigateSection(nextSection);
        }

        function navigateSection(sectionNumber) {
            const sections = document.querySelectorAll('.section');
            sections.forEach(section => section.classList.remove('active'));
            const target = document.getElementById('section' + sectionNumber);
            if (target) {
                target.classList.add('active');
            } else {
                console.log("Tried to jump to an invalid section: " + sectionNumber);
                sections[sections.length - 1].classList.add('active');
            }
        }

        var pdfFormName = '${escapedPdfFormName}';
        function downloadPDF(url, filename) {
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        async function editAndDownloadPDF(pdfName) {
            const formData = new FormData();
            document.querySelectorAll('#questions input, #questions select, #questions textarea').forEach(input => {
                if (input.type === 'checkbox') {
                    formData.append(input.name, input.checked ? 'Yes' : 'No');
                } else {
                    formData.append(input.name, input.value);
                }
            });
            return fetch('/edit_pdf?pdf=' + pdfName, { method: 'POST', body: formData })
                .then(response => response.blob())
                .then(blob => {
                    const url = URL.createObjectURL(blob);
                    downloadPDF(url, 'Edited_' + pdfName + '.pdf');
                });
        }
        function setCurrentDate() {
            var today = new Date();
            var dd = String(today.getDate()).padStart(2, '0');
            var mm = String(today.getMonth() + 1).padStart(2, '0');
            var yyyy = today.getFullYear();
            today = yyyy + '-' + mm + '-' + dd;
            document.getElementById('current_date').value = today;
        }
        window.onload = function() {
            setCurrentDate();
        };

        // conditional PDF array from question logic
        var conditionalPDFs = ${JSON.stringify(conditionalPDFs)};

        // conditional alerts array
        var conditionalAlerts = ${JSON.stringify(conditionalAlerts)};
        function handleConditionalAlerts() {
            conditionalAlerts.forEach(function(alertObj) {
                const prevQuestionNameId = 'answer' + alertObj.prevQuestionId;
                const prevQuestionElement = document.getElementById(prevQuestionNameId);
                if (prevQuestionElement) {
                    const userAnswer = prevQuestionElement.value;
                    if (userAnswer.trim().toLowerCase() === alertObj.prevAnswer.trim().toLowerCase()) {
                        alert(alertObj.alertText);
                    }
                } else {
                    const checkboxes = document.querySelectorAll('[name^="answer' + alertObj.prevQuestionId + '_"]');
                    if (checkboxes.length > 0) {
                        checkboxes.forEach(cb => {
                            if (cb.checked && cb.value.trim().toLowerCase() === alertObj.prevAnswer.trim().toLowerCase()) {
                                alert(alertObj.alertText);
                            }
                        });
                    }
                }
            });
        }

        function showThankYouMessage() {
            const pdfName = pdfFormName.replace('.pdf', '');
            editAndDownloadPDF(pdfName).then(() => {
                // handle conditional PDFs
                conditionalPDFs.forEach(function(conditionalPDF) {
                    if (conditionalPDF.questionType === 'checkbox') {
                        const checkboxInput = document.getElementById(conditionalPDF.questionNameId);
                        if (checkboxInput && checkboxInput.checked && checkboxInput.value === conditionalPDF.conditionalAnswer) {
                            editAndDownloadPDF(conditionalPDF.pdfName.replace('.pdf', ''));
                        }
                    } else {
                        const questionValue = document.getElementById(conditionalPDF.questionNameId)?.value;
                        if (questionValue === conditionalPDF.conditionalAnswer) {
                            editAndDownloadPDF(conditionalPDF.pdfName.replace('.pdf', ''));
                        }
                    }
                });
                // handle alerts
                handleConditionalAlerts();
                // show thank you
                document.getElementById('customForm').style.display = 'none';
                document.getElementById('thankYouMessage').style.display = 'block';
            });
            return false;
        }
    <\/` + `script>
    </body>
    </html>
    `;

    return formHTML;
}

    /**********************************************
     * 3) Functions that import JSON into formBuilder
     **********************************************/
    function importForm(event) {
  const file = event.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function(e) {
      const jsonData = JSON.parse(e.target.result);
      loadFormData(jsonData);
      alert("JSON imported successfully!");
    };
    reader.readAsText(file);
  }
}

    function loadFormData(formData) {
  // Clear the formBuilder
  document.getElementById('formBuilder').innerHTML = '';

  // Reset counters
  sectionCounter = formData.sectionCounter || 1;
  questionCounter = formData.questionCounter || 1;
  hiddenFieldCounter = formData.hiddenFieldCounter || 1;

  // Possibly init hidden fields container
  initializeHiddenPDFFieldsModule();

  // Build sections
  if (formData.sections) {
    formData.sections.forEach(section => {
      addSection(section.sectionId);
      // Set section name
      const sectionNameInput = document.getElementById(`sectionName${section.sectionId}`);
      if (sectionNameInput) {
        sectionNameInput.value = section.sectionName || `Section ${section.sectionId}`;
        updateSectionName(section.sectionId);
      }

      // Build questions
      if (section.questions) {
        section.questions.forEach(q => {
          addQuestion(section.sectionId, q.questionId);
          const qBlock = document.getElementById(`questionBlock${q.questionId}`);
          if (!qBlock) return;

          // question text
          let qInput = qBlock.querySelector(`#question${q.questionId}`);
          if (qInput) {
            qInput.value = q.text || '';
          }

          // question type
          let qTypeSel = qBlock.querySelector(`#questionType${q.questionId}`);
          if (qTypeSel) {
            qTypeSel.value = q.type || 'text';
          }

          // If it's dropdown/checkbox => fill hidden options
          if (q.type === 'dropdown') {
            const dropdownOptionsDiv = qBlock.querySelector(`#dropdownOptions${q.questionId}`);
            if (dropdownOptionsDiv && q.options) {
              dropdownOptionsDiv.innerHTML = '';
              q.options.forEach((val, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = `option${index+1}`;
                optionDiv.innerHTML = `
                  <input type="text" value="${val}" placeholder="Option ${index+1}">
                `;
                dropdownOptionsDiv.appendChild(optionDiv);
              });
            }
          }
          else if (q.type === 'checkbox') {
            const checkboxOptionsDiv = qBlock.querySelector(`#checkboxOptions${q.questionId}`);
            if (checkboxOptionsDiv && q.options) {
              checkboxOptionsDiv.innerHTML = '';
              q.options.forEach((optData, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = `option${index+1}`;
                optionDiv.innerHTML = `
                  <input type="text" id="checkboxOptionText${q.questionId}_${index+1}" value="${optData.label}">
                `;
                checkboxOptionsDiv.appendChild(optionDiv);
              });
            }
          }
        });
      }
    });
  }

  // Build hidden fields if any
  if (formData.hiddenFields) {
    formData.hiddenFields.forEach(hf => {
      addHiddenField(); 
      // Optionally fill details for hidden fields if needed
    });
  }
}

   function generateHiddenPDFFields() {
  // Stub function for hidden fields logic
  const hiddenFieldsHTML = '';
  const autofillMappings = [];
  const conditionalAutofillLogic = [];
  return { hiddenFieldsHTML, autofillMappings, conditionalAutofillLogic };
}

/**********************************************
 * 5) PREVIEW & MODAL HANDLERS
 **********************************************/
function previewForm() {
  const formHTML = getFormHTML();
  const previewFrame = document.getElementById('previewFrame');
  previewFrame.srcdoc = formHTML;
  document.getElementById('previewModal').style.display = 'flex';
}


    function closePreview() {
      document.getElementById('previewModal').style.display = 'none';
    }
  </script>
</body>
</html>
