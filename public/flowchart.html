<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Flowchart Creator (No Sections, No Jumping)</title>
  <!-- mxGraph -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mxgraph@4.2.2/javascript/mxClient.min.js"></script>
  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
      user-select: none;
    }
    .toolbar {
      width: 220px;
      background: #f9f9f9;
      border-right: 1px solid #ccc;
      float: left;
      padding: 10px;
      box-sizing: border-box;
    }
    #graphContainer {
      position: absolute;
      left: 220px;
      right: 0;
      top: 0;
      bottom: 0;
      cursor: default;
    }
    .shape {
      background: #fff;
      border: 1px solid #999;
      margin-bottom: 8px;
      text-align: center;
      padding: 6px;
      border-radius: 4px;
      cursor: move;
    }
    .shape:hover {
      background: #e0e0e0;
    }
    .button-bar {
      margin-top: 15px;
    }
    button {
      margin-bottom: 6px;
      padding: 6px 10px;
      background-color: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: block;
      width: 100%;
      box-sizing: border-box;
    }
    button:hover {
      background-color: #0056b3;
    }
    input[type="file"] {
      display: none;
    }
    .context-menu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
      display: none;
      z-index: 1000;
      padding: 5px;
    }
    .context-menu button {
      border: none;
      background: none;
      color: #000;
      padding: 5px 10px;
      text-align: left;
      width: 100%;
      cursor: pointer;
    }
    .context-menu button:hover {
      background-color: #f0f0f0;
    }
    .submenu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      padding: 5px;
      display: none;
      z-index: 2000;
    }
    .submenu button {
      display: block;
      margin-bottom: 4px;
      border: none;
      background: none;
      color: #000;
      padding: 5px 10px;
      text-align: left;
      width: 100%;
      cursor: pointer;
    }
    .submenu button:hover {
      background-color: #f0f0f0;
    }

    #propertiesMenu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 4px;
      display: none;
      z-index: 3000;
      width: 220px;
    }
    #propertiesMenu p {
      margin: 4px 0;
    }
    .editable-field {
      border: 1px dashed transparent;
      padding: 2px;
      display: inline-block;
      min-width: 50px;
      cursor: text;
    }
    .editable-field:focus {
      outline: 1px dashed #888;
    }

    /* Legend area for colors */
    .legend {
      margin-top: 10px;
      padding: 6px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .legend .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
    }
    .legend-color-box {
      width: 20px;
      height: 20px;
      margin-right: 8px;
      cursor: pointer;
      border: 1px solid #ccc;
      border-radius: 3px;
    }

    /* Basic login form overlay */
    #loginOverlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0,0,0,0.5);
      display: none;
      z-index: 9999;
      align-items: center;
      justify-content: center;
    }
    #loginForm {
      background: #fff;
      padding: 20px;
      border-radius: 6px;
      min-width: 300px;
    }
    #loginForm input[type="email"],
    #loginForm input[type="password"] {
      width: 100%;
      margin-bottom: 10px;
      padding: 8px;
      box-sizing: border-box;
    }
    #loginError {
      color: red;
      margin-bottom: 8px;
    }

    /* Customization for the in-node text box padding + rounding */
    .mxGraph .mxCellEditor,
    .mxGraph .mxCellOverlay {
      background: transparent !important;
    }
    .mxCellEditor {
      background: #ffffff !important;
      border-radius: 12px !important;  /* round corners of the editor */
      overflow: visible !important;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15) !important;
      box-sizing: border-box !important;
    }
    .mxCellEditor div {
      padding: 16px !important;       /* extra padding inside the editable area */
      border: 1px solid #ccc !important;
      border-radius: 12px !important; /* also round corners here */
      background: #ffffff !important;
      min-width: 20px !important;
      min-height: 90px !important;
      box-sizing: border-box !important;
    }
    .mxCellEditor textarea {
      padding: 16px !important;       /* extra padding inside the text area */
      border: 1px solid #ccc !important;
      border-radius: 12px !important; /* round corners */
      background: #ffffff !important;
      min-width: 20px !important;
      min-height: 50px !important;
      resize: none;
      box-sizing: border-box !important;
    }
  </style>
</head>
<body>

<div id="loginOverlay">
  <div id="loginForm">
    <h3>Login</h3>
    <div id="loginError"></div>
    <input type="email" id="loginEmail" placeholder="Email" /><br/>
    <input type="password" id="loginPassword" placeholder="Password" /><br/>
    <button id="loginButton">Login</button>
    <button id="signupButton">Sign Up</button>
  </div>
</div>

<div class="toolbar">
  <h3>Shapes</h3>
  <!-- No auto-size or section data in these shapes -->
  <div
    class="shape"
    data-type="question"
    data-style="rounded=1;whiteSpace=wrap;html=1;nodeType=question;questionType=dropdown;nodeId=Question_node;"
  >
    Question Node
  </div>
  <div
    class="shape"
    data-type="options"
    data-style="rounded=1;whiteSpace=wrap;html=1;nodeType=options;questionType=dropdown;nodeId=Option_node;"
  >
    Options Node
  </div>

  <div class="button-bar">
    <button onclick="exportFlowchartJson()">Export Flowchart JSON</button>
    <button onclick="document.getElementById('importFlowchartFile').click()">Import Flowchart</button>
    <input
      type="file"
      id="importFlowchartFile"
      accept=".json"
      onchange="importFlowchartJson(event)"
    />
    <button onclick="exportGuiJson()">Export GUI JSON</button>
  </div>

  <div class="legend">
    <strong>Legend (Click color to change)</strong>
    <div class="legend-item">
      <div class="legend-color-box" id="colorText"></div>
      <span>Text</span>
    </div>
    <div class="legend-item">
      <div class="legend-color-box" id="colorCheckbox"></div>
      <span>Checkbox</span>
    </div>
    <div class="legend-item">
      <div class="legend-color-box" id="colorDropdown"></div>
      <span>Dropdown</span>
    </div>
    <div class="legend-item">
      <div class="legend-color-box" id="colorMoney"></div>
      <span>Money</span>
    </div>
    <div class="legend-item">
      <div class="legend-color-box" id="colorDate"></div>
      <span>Date</span>
    </div>
    <div class="legend-item">
      <div class="legend-color-box" id="colorBigParagraph"></div>
      <span>Big Paragraph</span>
    </div>
  </div>

  <!-- RESET button to restore default colors, then a LOGOUT button -->
  <button id="resetColorsBtn">Reset Colors</button>
  <button id="logoutBtn">Logout</button>
</div>

<div id="graphContainer"></div>

<div id="contextMenu" class="context-menu">
  <button id="deleteNode">Delete Node</button>
  <button id="jumpNode">Jump</button>
  <button id="changeType">Change Type &raquo;</button>
  <button id="propertiesButton">Properties</button>
  <button id="yesNoNode">Yes/No</button>
</div>

<div id="typeSubmenu" class="submenu">
  <button id="dropdownType">Drop Down</button>
  <button id="checkboxType">Checkbox</button>
  <button id="textType">Text</button>
  <button id="moneyType">Money</button>
  <button id="dateType">Date</button>
  <button id="bigParagraphType">Big Paragraph</button>
</div>

<div id="propertiesMenu">
  <p><strong>Node Text:</strong>
    <span id="propNodeText" class="editable-field" tabindex="0"></span>
  </p>
  <p><strong>Node ID:</strong>
    <span id="propNodeId" class="editable-field" tabindex="0"></span>
  </p>
  <p><strong>Node Type:</strong> <span id="propNodeType"></span></p>
</div>

<!-- Color pickers (hidden by default) -->
<input type="color" id="colorPickerText" style="display:none;" />
<input type="color" id="colorPickerCheckbox" style="display:none;" />
<input type="color" id="colorPickerDropdown" style="display:none;" />
<input type="color" id="colorPickerMoney" style="display:none;" />
<input type="color" id="colorPickerDate" style="display:none;" />
<input type="color" id="colorPickerBigParagraph" style="display:none;" />

<script>
  /*
   *********************************************************************
   **************       Firebase Config & Auth Setup       *************
   *********************************************************************
  */
  const firebaseConfig = {
    apiKey: "AIzaSyBlxFmFD-rz1V_Q9_oV0DkLsENbmyJ1k-U",
    authDomain: "flowchart-1eb90.firebaseapp.com",
    projectId: "flowchart-1eb90",
    storageBucket: "flowchart-1eb90.firebasestorage.app",
    messagingSenderId: "546103281533",
    appId: "1:546103281533:web:ae719cdbde727dcd94ee14",
    measurementId: "G-8VSXRFREY9"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
  let currentUser = null;

  /*
    Default color preferences: from light to dark blue, as requested.
    We'll store a separate "defaultColorPreferences" so we can reset easily.
  */
  const defaultColorPreferences = {
    text: "#cce6ff",         // lightest
    checkbox: "#b3daff",
    dropdown: "#99ccff",
    money: "#80bfff",
    date: "#4da6ff",
    bigParagraph: "#1a8cff"  // darkest
  };

  // We'll let colorPreferences start as a copy of defaults
  let colorPreferences = { ...defaultColorPreferences };

  const loginOverlay = document.getElementById("loginOverlay");
  const loginButton = document.getElementById("loginButton");
  const signupButton = document.getElementById("signupButton");
  const loginEmail = document.getElementById("loginEmail");
  const loginPassword = document.getElementById("loginPassword");
  const loginError = document.getElementById("loginError");

  function showLoginOverlay() {
    loginOverlay.style.display = "flex";
  }
  function hideLoginOverlay() {
    loginOverlay.style.display = "none";
  }
  function setCookie(name, value, days) {
    const d = new Date();
    d.setTime(d.getTime() + days*24*60*60*1000);
    const expires = "expires="+ d.toUTCString();
    document.cookie = name + "=" + value + ";" + expires + ";path=/";
  }
  function getCookie(name) {
    const ca = document.cookie.split(';');
    name = name + "=";
    for (let i=0; i < ca.length; i++) {
      let c = ca[i].trim();
      if (c.indexOf(name) === 0) {
        return c.substring(name.length, c.length);
      }
    }
    return "";
  }

  function checkForSavedLogin() {
    const savedUid = getCookie("flowchart_uid");
    if (savedUid) {
      firebase.auth().onAuthStateChanged((user) => {
        if (user && user.uid === savedUid) {
          currentUser = user;
          hideLoginOverlay();
          loadUserColorPrefs();
        } else {
          showLoginOverlay();
        }
      });
    } else {
      showLoginOverlay();
    }
  }

  loginButton.addEventListener("click", () => {
    const email = loginEmail.value.trim();
    const pass = loginPassword.value.trim();
    firebase.auth().signInWithEmailAndPassword(email, pass)
      .then((cred) => {
        currentUser = cred.user;
        setCookie("flowchart_uid", currentUser.uid, 7);
        hideLoginOverlay();
        loadUserColorPrefs();
      })
      .catch((err) => {
        loginError.textContent = err.message;
      });
  });
  signupButton.addEventListener("click", () => {
    const email = loginEmail.value.trim();
    const pass = loginPassword.value.trim();
    firebase.auth().createUserWithEmailAndPassword(email, pass)
      .then((cred) => {
        currentUser = cred.user;
        setCookie("flowchart_uid", currentUser.uid, 7);
        hideLoginOverlay();
        saveUserColorPrefs().then(() => {
          loadUserColorPrefs();
        });
      })
      .catch((err) => {
        loginError.textContent = err.message;
      });
  });

  function loadUserColorPrefs() {
    if (!currentUser) return;
    db.collection("users")
      .doc(currentUser.uid)
      .collection("preferences")
      .doc("colors")
      .get()
      .then(docSnap => {
        if (docSnap.exists) {
          const data = docSnap.data();
          // Merge them carefully
          for (let key in defaultColorPreferences) {
            if (data[key]) {
              colorPreferences[key] = data[key];
            } else {
              colorPreferences[key] = defaultColorPreferences[key];
            }
          }
        } else {
          // If doc doesn't exist, use the defaults
          colorPreferences = { ...defaultColorPreferences };
        }
        updateLegendColors();
        refreshAllCells();
      })
      .catch(err => {
        console.error("Error loading color prefs:", err);
      });
  }
  function saveUserColorPrefs() {
    if (!currentUser) return Promise.resolve();
    return db.collection("users")
      .doc(currentUser.uid)
      .collection("preferences")
      .doc("colors")
      .set(colorPreferences, { merge: true });
  }
</script>

<script>
  /*
   *********************************************************************
   **************       Initialize Graph & Context Menu     ************
   *********************************************************************
  */
  let graph = null;
  let selectedCell = null;
  let currentMouseEvent = null;
  let lastSelectedCell = null;
  let jumpModeNode = null;
  const jumpBorderStyle = ";strokeWidth=3;strokeColor=#ff0000;dashed=1;dashPattern=4 4;";

  document.addEventListener("DOMContentLoaded", function () {
    if (typeof mxGraph === "undefined") {
      alert("mxGraph library not found!");
      return;
    }
    checkForSavedLogin();

    const container = document.getElementById("graphContainer");
    const contextMenu = document.getElementById("contextMenu");
    const deleteNodeButton = document.getElementById("deleteNode");
    const jumpNodeButton = document.getElementById("jumpNode");
    const changeTypeButton = document.getElementById("changeType");
    const propertiesButton = document.getElementById("propertiesButton");
    const yesNoNodeButton = document.getElementById("yesNoNode");

    const typeSubmenu = document.getElementById("typeSubmenu");
    const dropdownTypeBtn = document.getElementById("dropdownType");
    const checkboxTypeBtn = document.getElementById("checkboxType");
    const textTypeBtn = document.getElementById("textType");
    const moneyTypeBtn = document.getElementById("moneyType");
    const dateTypeBtn = document.getElementById("dateType");
    const bigParagraphTypeBtn = document.getElementById("bigParagraphType");

    const propertiesMenu = document.getElementById("propertiesMenu");
    const propNodeText = document.getElementById("propNodeText");
    const propNodeId = document.getElementById("propNodeId");
    const propNodeType = document.getElementById("propNodeType");

    const colorBoxText = document.getElementById("colorText");
    const colorBoxCheckbox = document.getElementById("colorCheckbox");
    const colorBoxDropdown = document.getElementById("colorDropdown");
    const colorBoxMoney = document.getElementById("colorMoney");
    const colorBoxDate = document.getElementById("colorDate");
    const colorBoxBigParagraph = document.getElementById("colorBigParagraph");

    const colorPickerText = document.getElementById("colorPickerText");
    const colorPickerCheckbox = document.getElementById("colorPickerCheckbox");
    const colorPickerDropdown = document.getElementById("colorPickerDropdown");
    const colorPickerMoney = document.getElementById("colorPickerMoney");
    const colorPickerDate = document.getElementById("colorPickerDate");
    const colorPickerBigParagraph = document.getElementById("colorPickerBigParagraph");

    const resetColorsBtn = document.getElementById("resetColorsBtn");
    const logoutBtn = document.getElementById("logoutBtn");

    /*
      1) Create the graph.
         We do NOT call setAutoSizeCells(true) so it won't resize live.
    */
    graph = new mxGraph(container);

    // 2) We do NOT do auto sizing. So remove "autosize=1" from the style as well.

    // 3) Let it render raw HTML in cell values
    graph.setHtmlLabels(true);

    mxEvent.disableContextMenu(container);
    graph.setPanning(true);
    graph.panningHandler.useLeftButtonForPanning = true;
    graph.setCellsMovable(true);
    graph.setConnectable(true);
    graph.setCellsResizable(true);
    new mxRubberband(graph);

    // 4) Default vertex style
    const defStyle = graph.getStylesheet().getDefaultVertexStyle();
    defStyle["labelBackgroundColor"] = "#ffffff";
    defStyle["labelBorderColor"] = "#cccccc";
    defStyle["rounded"] = "1";
    defStyle["arcSize"] = "24";
    defStyle["whiteSpace"] = "wrap";
    defStyle["html"] = "1";
    // Remove "autosize" from default style
    // *** Center text in the node ***
    defStyle["align"] = mxConstants.ALIGN_CENTER;
    defStyle["verticalAlign"] = mxConstants.ALIGN_MIDDLE;
    // Extra internal padding
    defStyle["spacingTop"] = 20;
    defStyle["spacingBottom"] = 20;
    defStyle["spacingLeft"] = 20;
    defStyle["spacingRight"] = 20;

    // Enforce a minimum size if user tries to manually resize
    graph.getModel().addListener(mxEvent.CHANGE, (sender, evt) => {
      const changes = evt.getProperty("changes") || [];
      changes.forEach(change => {
        if (change.constructor.name === "mxGeometryChange") {
          const changedCell = change.cell;
          if (changedCell && changedCell.vertex) {
            const geo = changedCell.geometry;
            if (geo) {
              if (geo.width < 120) geo.width = 120;
              if (geo.height < 60) geo.height = 60;
            }
          }
        }
      });
    });

    /*
      Remove the real-time text update that calls updateCellSize while typing.
      We'll let the node remain the same size while you type, so it won't jump.
      If you wanted to auto-size AFTER editing is done, you could do it in stopEditing,
      but let's remove it entirely to keep the node from moving at all.
    */
    (function overrideCellEditorForRealTime() {
      // We'll just let the default run, no changes for input or stopEditing.
      // So we do NOT call graph.updateCellSize() at all here.
    })();

    // Keep track of last selection for auto node ID if needed
    graph.getSelectionModel().addListener(mxEvent.CHANGE, () => {
      if (lastSelectedCell) {
        autoUpdateNodeIdBasedOnLabel(lastSelectedCell);
      }
      lastSelectedCell = graph.getSelectionCell();
    });

    // DRAG FROM TOOLBAR
    const toolbarShapes = document.querySelectorAll(".shape");
    toolbarShapes.forEach((shapeEl) => {
      const baseStyle = shapeEl.dataset.style;
      mxUtils.makeDraggable(
        shapeEl,
        graph,
        function (graph, evt, targetCell, x, y) {
          const parent = graph.getDefaultParent();
          graph.getModel().beginUpdate();
          let newVertex;
          try {
            const label = shapeEl.dataset.type + " node";
            // We remove autosize=1 from here so it doesn't auto-resize
            newVertex = graph.insertVertex(
              parent,
              null,
              label,
              x,
              y,
              160,
              80,
              baseStyle
            );
          } finally {
            graph.getModel().endUpdate();
          }
          if (isQuestion(newVertex)) {
            refreshNodeIdFromLabel(newVertex);
          } else if (isOptions(newVertex)) {
            refreshOptionNodeId(newVertex);
          }
          refreshAllCells();
          return newVertex;
        }
      );
    });

    /*
      CONTEXT MENU + PROPERTIES
    */
    graph.popupMenuHandler.factoryMethod = function(menu, cell, evt) {
      selectedCell = cell;
      currentMouseEvent = evt;
      if (cell) {
        showContextMenu(evt);
      } else {
        hideContextMenu();
      }
    };
    function showContextMenu(evt) {
      contextMenu.style.display = "block";
      contextMenu.style.left = evt.clientX + "px";
      contextMenu.style.top = evt.clientY + "px";
      typeSubmenu.style.display = "none";
    }
    function hideContextMenu() {
      contextMenu.style.display = "none";
      typeSubmenu.style.display = "none";
    }
    document.addEventListener("click", (e) => {
      if (
        !contextMenu.contains(e.target) &&
        !typeSubmenu.contains(e.target) &&
        !propertiesMenu.contains(e.target)
      ) {
        hideContextMenu();
        propertiesMenu.style.display = "none";
      }
    });

    deleteNodeButton.addEventListener("click", () => {
      if (selectedCell) {
        graph.removeCells([selectedCell]);
        refreshAllCells();
      }
      hideContextMenu();
    });
    jumpNodeButton.addEventListener("click", () => {
      if (selectedCell) {
        if (jumpModeNode && jumpModeNode !== selectedCell) {
          removeJumpStyling(jumpModeNode);
        }
        jumpModeNode = selectedCell;
        addJumpStyling(jumpModeNode);
      }
      hideContextMenu();
    });
    changeTypeButton.addEventListener("click", () => {
      const rect = contextMenu.getBoundingClientRect();
      typeSubmenu.style.display = "block";
      typeSubmenu.style.left = rect.right + "px";
      typeSubmenu.style.top = rect.top + "px";
    });

    // Type submenu
    dropdownTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "dropdown");
        selectedCell.value = "Dropdown question node";
        refreshAllCells();
      }
      hideContextMenu();
    });
    checkboxTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "checkbox");
        selectedCell.value = "Checkbox question node";
        refreshAllCells();
      }
      hideContextMenu();
    });
    textTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "text");
        selectedCell.value = "Text question node";
        refreshAllCells();
      }
      hideContextMenu();
    });
    moneyTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "money");
        selectedCell.value = "Money question node";
        refreshAllCells();
      }
      hideContextMenu();
    });
    dateTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "date");
        selectedCell.value = "Date question node";
        refreshAllCells();
      }
      hideContextMenu();
    });
    bigParagraphTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "bigParagraph");
        selectedCell.value = "Big Paragraph question node";
        refreshAllCells();
      }
      hideContextMenu();
    });

    yesNoNodeButton.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        createYesNoOptions(selectedCell);
      }
      hideContextMenu();
    });
    function createYesNoOptions(parentCell) {
      const parentGeo = parentCell.geometry;
      if (!parentGeo) return;
      const parent = graph.getDefaultParent();
      graph.getModel().beginUpdate();
      try {
        const yesX = parentGeo.x - 80;
        const yesY = parentGeo.y + parentGeo.height + 50;
        const yesStyle = "rounded=1;whiteSpace=wrap;html=1;nodeType=options;questionType=dropdown;";
        const yesVertex = graph.insertVertex(parent, null, "Yes", yesX, yesY, 100, 60, yesStyle);
        refreshOptionNodeId(yesVertex);
        graph.insertEdge(parent, null, "", parentCell, yesVertex);

        const noX = parentGeo.x + parentGeo.width + 20;
        const noY = parentGeo.y + parentGeo.height + 50;
        const noStyle = "rounded=1;whiteSpace=wrap;html=1;nodeType=options;questionType=dropdown;";
        const noVertex = graph.insertVertex(parent, null, "No", noX, noY, 100, 60, noStyle);
        refreshOptionNodeId(noVertex);
        graph.insertEdge(parent, null, "", parentCell, noVertex);
      } finally {
        graph.getModel().endUpdate();
      }
      refreshAllCells();
    }

    // Properties
    function showPropertiesMenu(cell, evt) {
      if (!cell) return;
      propertiesMenu.style.display = "block";
      propertiesMenu.style.left = evt.clientX + 10 + "px";
      propertiesMenu.style.top = evt.clientY + 10 + "px";

      propNodeText.textContent = cell.value || "";
      propNodeId.textContent = getNodeId(cell) || "";
      if (isQuestion(cell)) {
        propNodeType.textContent = getQuestionType(cell);
      } else if (isOptions(cell)) {
        propNodeType.textContent = "options";
      } else {
        propNodeType.textContent = "other";
      }
    }
    propertiesButton.addEventListener("click", () => {
      if (selectedCell) {
        showPropertiesMenu(selectedCell, currentMouseEvent);
      }
    });

    // Make property fields editable
    makeEditableField(propNodeText, onNodeTextFieldChange);
    makeEditableField(propNodeId, onNodeIdFieldChange);
    function makeEditableField(spanEl, onChangeCb) {
      spanEl.addEventListener("dblclick", (e) => {
        e.stopPropagation();
        e.preventDefault();
        spanEl.contentEditable = "true";
        spanEl.focus();
      });
      spanEl.addEventListener("blur", () => {
        spanEl.contentEditable = "false";
        onChangeCb(spanEl.textContent);
      });
      spanEl.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter") {
          evt.preventDefault();
          spanEl.blur();
        }
      });
    }
    function onNodeTextFieldChange(newText) {
      if (!selectedCell) return;
      graph.getModel().beginUpdate();
      try {
        selectedCell.value = newText.trim();
        if (isQuestion(selectedCell)) {
          refreshNodeIdFromLabel(selectedCell);
        } else if (isOptions(selectedCell)) {
          refreshOptionNodeId(selectedCell);
        }
      } finally {
        graph.getModel().endUpdate();
      }
      refreshAllCells();
    }
    function onNodeIdFieldChange(newId) {
      if (!selectedCell) return;
      graph.getModel().beginUpdate();
      try {
        setNodeId(selectedCell, newId);
      } finally {
        graph.getModel().endUpdate();
      }
      refreshAllCells();
    }

    // Keyboard copy/paste
    const keyHandler = new mxKeyHandler(graph);
    keyHandler.bindControlKey(67, () => {
      mxClipboard.copy(graph);
    });
    keyHandler.bindControlKey(86, () => {
      const pasted = mxClipboard.paste(graph);
      if (pasted && pasted.length > 0) {
        graph.moveCells(pasted, 40, 40);
        refreshAllCells();
      }
    });

    // Auto question detection if ends with '?'
    graph.getModel().addListener(mxEvent.EVENT_CHANGE, function(sender, evt) {
      const changes = evt.getProperty("changes");
      if (!changes) return;
      changes.forEach((change) => {
        if (change.constructor.name === "mxValueChange") {
          const { cell, value } = change;
          if (value && typeof value === "string") {
            if (value.trim().endsWith("?")) {
              if (!isQuestion(cell)) {
                let style = cell.style || "";
                style += ";nodeType=question;";
                graph.getModel().setStyle(cell, style);
                refreshNodeIdFromLabel(cell);
              }
            }
          }
        }
      });
      refreshAllCells();
    });

    // On connect
    graph.connectionHandler.addListener(mxEvent.CONNECT, function(sender, evt) {
      const edge = evt.getProperty("cell");
      if (!edge) return;
      const parent = edge.source;
      const child = edge.target;

      // Jump mode check
      const parentIsJump = (parent && parent === jumpModeNode);
      let parentQuestion = null;
      if (parent && isOptions(parent)) {
        parentQuestion = parent.source;
      } else if (parent && isQuestion(parent)) {
        parentQuestion = parent;
      }
      const gpIsJump = (parentQuestion && parentQuestion === jumpModeNode);

      if (parentIsJump || gpIsJump) {
        addSkipReassign(child);
      }
      refreshAllCells();
    });

    // Initialize legend colors
    updateLegendColors();

    // When user clicks color box, set the color picker to that color, then open
    colorBoxText.addEventListener("click", () => {
      colorPickerText.value = colorPreferences.text;
      colorPickerText.click();
    });
    colorBoxCheckbox.addEventListener("click", () => {
      colorPickerCheckbox.value = colorPreferences.checkbox;
      colorPickerCheckbox.click();
    });
    colorBoxDropdown.addEventListener("click", () => {
      colorPickerDropdown.value = colorPreferences.dropdown;
      colorPickerDropdown.click();
    });
    colorBoxMoney.addEventListener("click", () => {
      colorPickerMoney.value = colorPreferences.money;
      colorPickerMoney.click();
    });
    colorBoxDate.addEventListener("click", () => {
      colorPickerDate.value = colorPreferences.date;
      colorPickerDate.click();
    });
    colorBoxBigParagraph.addEventListener("click", () => {
      colorPickerBigParagraph.value = colorPreferences.bigParagraph;
      colorPickerBigParagraph.click();
    });

    // Listen for user picking a new color
    colorPickerText.addEventListener("input", (e) => {
      colorPreferences.text = e.target.value;
      saveUserColorPrefs().then(()=>{
        updateLegendColors();
        refreshAllCells();
      });
    });
    colorPickerCheckbox.addEventListener("input", (e) => {
      colorPreferences.checkbox = e.target.value;
      saveUserColorPrefs().then(()=>{
        updateLegendColors();
        refreshAllCells();
      });
    });
    colorPickerDropdown.addEventListener("input", (e) => {
      colorPreferences.dropdown = e.target.value;
      saveUserColorPrefs().then(()=>{
        updateLegendColors();
        refreshAllCells();
      });
    });
    colorPickerMoney.addEventListener("input", (e) => {
      colorPreferences.money = e.target.value;
      saveUserColorPrefs().then(()=>{
        updateLegendColors();
        refreshAllCells();
      });
    });
    colorPickerDate.addEventListener("input", (e) => {
      colorPreferences.date = e.target.value;
      saveUserColorPrefs().then(()=>{
        updateLegendColors();
        refreshAllCells();
      });
    });
    colorPickerBigParagraph.addEventListener("input", (e) => {
      colorPreferences.bigParagraph = e.target.value;
      saveUserColorPrefs().then(()=>{
        updateLegendColors();
        refreshAllCells();
      });
    });

    // RESET button
    resetColorsBtn.addEventListener("click", () => {
      // restore defaults
      colorPreferences = { ...defaultColorPreferences };
      // then save, update UI
      saveUserColorPrefs().then(() => {
        updateLegendColors();
        refreshAllCells();
      });
    });

    // LOGOUT button
    logoutBtn.addEventListener("click", () => {
      firebase.auth().signOut()
        .then(() => {
          // Clear the cookie
          setCookie("flowchart_uid", "", -1);
          // Show login overlay
          showLoginOverlay();
        })
        .catch(err => console.error("Logout error:", err));
    });
  });
</script>

<script>
  /*
   *********************************************************************
   **************       Helper Functions / Styling       ***************
   *********************************************************************
  */
  function updateLegendColors() {
    document.getElementById("colorText").style.backgroundColor = colorPreferences.text;
    document.getElementById("colorCheckbox").style.backgroundColor = colorPreferences.checkbox;
    document.getElementById("colorDropdown").style.backgroundColor = colorPreferences.dropdown;
    document.getElementById("colorMoney").style.backgroundColor = colorPreferences.money;
    document.getElementById("colorDate").style.backgroundColor = colorPreferences.date;
    document.getElementById("colorBigParagraph").style.backgroundColor = colorPreferences.bigParagraph;
  }

  function autoUpdateNodeIdBasedOnLabel(cell) {
    if (!cell.vertex) return;
    const label = (cell.value || "").trim();
    if (!label) return;
    if (isQuestion(cell)) {
      refreshNodeIdFromLabel(cell);
    } else if (isOptions(cell)) {
      refreshOptionNodeId(cell);
    }
  }

  function setNodeId(cell, nodeId) {
    let style = cell.style || "";
    style = style.replace(/nodeId=[^;]+/, "");
    style += `;nodeId=${encodeURIComponent(nodeId)};`;
    graph.getModel().setStyle(cell, style);
  }
  function getNodeId(cell) {
    const style = cell.style || "";
    const m = style.match(/nodeId=([^;]+)/);
    return m ? decodeURIComponent(m[1]) : "";
  }

  function isQuestion(cell) {
    return cell && cell.style && cell.style.includes("nodeType=question");
  }
  function isOptions(cell) {
    return cell && cell.style && cell.style.includes("nodeType=options");
  }

  function refreshNodeIdFromLabel(cell) {
    const label = (cell.value || "").toString().trim();
    const nodeId = label.replace(/\s+/g, "_");
    setNodeId(cell, nodeId);
  }
  function refreshOptionNodeId(cell) {
    const edges = graph.getIncomingEdges(cell) || [];
    let parentNodeId = "ParentQuestion";
    for (let e of edges) {
      const p = e.source;
      if (isQuestion(p)) {
        parentNodeId = getNodeId(p) || "ParentQuestion";
        break;
      }
    }
    let label = (cell.value || "Option").toString().trim().replace(/\s+/g, "_");
    setNodeId(cell, parentNodeId + label);
  }

  function addSkipReassign(cell) {
    if (!cell) return;
    let style = cell.style || "";
    style = style.replace(/skipReassign=[^;]+/, "");
    style += ";skipReassign=true;";
    graph.getModel().setStyle(cell, style);
  }
  function hasSkipReassign(cell) {
    return cell && cell.style && cell.style.includes("skipReassign=true");
  }

  function addJumpStyling(cell) {
    if (!cell) return;
    let style = cell.style || "";
    style = style.replace(/strokeWidth=\d+;?/, "");
    style = style.replace(/strokeColor=[^;]+;?/, "");
    style = style.replace(/dashed=\d;?/, "");
    style = style.replace(/dashPattern=[^;]+;?/, "");
    style += jumpBorderStyle;
    graph.getModel().setStyle(cell, style);
  }
  function removeJumpStyling(cell) {
    if (!cell) return;
    let style = cell.style || "";
    style = style.replace(/strokeWidth=\d+;?/, "");
    style = style.replace(/strokeColor=[^;]+;?/, "");
    style = style.replace(/dashed=\d;?/, "");
    style = style.replace(/dashPattern=[^;]+;?/, "");
    graph.getModel().setStyle(cell, style);
  }

  function getQuestionType(cell) {
    const style = cell.style || "";
    const m = style.match(/questionType=([^;]+)/);
    return m ? m[1] : "dropdown";
  }
  function setQuestionType(cell, newType) {
    let style = cell.style || "";
    style = style.replace(/questionType=[^;]+/, "");
    style += `;questionType=${newType};`;
    graph.getModel().setStyle(cell, style);
  }

  function colorCell(cell) {
    if (!cell.vertex) return;
    let fillColor = "#ADD8E6"; // fallback
    if (isQuestion(cell)) {
      const qType = getQuestionType(cell);
      fillColor = getColorForQuestionType(qType);
    } else if (isOptions(cell)) {
      fillColor = "#ffffff";
    }
    let style = cell.style || "";
    style = style.replace(/fillColor=[^;]+/, "");
    style += `;fillColor=${fillColor};`;
    graph.getModel().setStyle(cell, style);
  }

  function getColorForQuestionType(qType) {
    switch (qType) {
      case "text":         return colorPreferences.text;
      case "checkbox":     return colorPreferences.checkbox;
      case "dropdown":     return colorPreferences.dropdown;
      case "money":        return colorPreferences.money;
      case "date":         return colorPreferences.date;
      case "bigParagraph": return colorPreferences.bigParagraph;
      default:             return "#ADD8E6"; // fallback
    }
  }

  function refreshAllCells() {
    const parent = graph.getDefaultParent();
    const vertices = graph.getChildVertices(parent);
    vertices.forEach(cell => {
      colorCell(cell);

      // If it's a question node with the default label, put the mini dropdown
      if (isQuestion(cell) && (cell.value === "question node" || cell.value === "Question Node")) {
        const cellId = cell.id;
        cell.value = `
          <select oninput="window.pickTypeForCell('${cellId}', this.value)">
            <option value="">-- Choose Type --</option>
            <option value="text">Text</option>
            <option value="checkbox">Checkbox</option>
            <option value="dropdown">Dropdown</option>
            <option value="money">Money</option>
            <option value="date">Date</option>
            <option value="bigParagraph">Big Paragraph</option>
          </select>
        `;
      }
    });
  }

  window.pickTypeForCell = function(cellId, val) {
    const c = graph.getModel().getCell(cellId);
    if (!c) return;
    graph.getModel().beginUpdate();
    try {
      setQuestionType(c, val);
      c.value = val.charAt(0).toUpperCase() + val.slice(1) + " question node";
    } finally {
      graph.getModel().endUpdate();
    }
    refreshAllCells();
  };
</script>

<script>
  /*
   *********************************************************************
   **************       Export / Import Functions         **************
   *********************************************************************
  */
  function downloadJson(str, filename) {
    const blob = new Blob([str], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  window.exportFlowchartJson = function () {
    const data = [];
    const cells = graph.getModel().cells;
    for (let id in cells) {
      if (id === "0" || id === "1") continue;
      const cell = cells[id];
      data.push({
        id: cell.id,
        value: cell.value,
        geometry: cell.geometry
          ? {
              x: cell.geometry.x,
              y: cell.geometry.y,
              width: cell.geometry.width,
              height: cell.geometry.height
            }
          : null,
        style: cell.style || "",
        vertex: !!cell.vertex,
        edge: !!cell.edge,
        source: cell.edge ? cell.source?.id : null,
        target: cell.edge ? cell.target?.id : null
      });
    }
    downloadJson(JSON.stringify(data, null, 2), "flowchart_data.json");
  };

  window.importFlowchartJson = function (evt) {
    const file = evt.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (e) {
      const jsonData = JSON.parse(e.target.result);
      loadFlowchartData(jsonData);
    };
    reader.readAsText(file);
  };

  function loadFlowchartData(data) {
    graph.getModel().beginUpdate();
    try {
      const parent = graph.getDefaultParent();
      graph.removeCells(graph.getChildVertices(parent));
      const createdCells = {};

      data.forEach((item) => {
        if (item.vertex) {
          const geo = new mxGeometry(
            item.geometry.x,
            item.geometry.y,
            item.geometry.width,
            item.geometry.height
          );
          const newCell = new mxCell(item.value, geo, item.style);
          newCell.vertex = true;
          newCell.id = item.id;
          graph.addCell(newCell, parent);
          createdCells[item.id] = newCell;
        }
      });

      data.forEach((item) => {
        if (item.edge) {
          const newEdge = new mxCell(item.value, new mxGeometry(), item.style);
          newEdge.edge = true;
          newEdge.id = item.id;
          const src = createdCells[item.source];
          const trg = createdCells[item.target];
          graph.addCell(newEdge, parent, undefined, src, trg);
        }
      });
    } finally {
      graph.getModel().endUpdate();
    }
    refreshAllCells();
  }

  window.exportGuiJson = function () {
    const model = graph.getModel();
    const allCells = model.cells;

    const questionsArr = [];
    let questionIdCounter = 1;

    function getNodeType(cell) {
      if (cell.style && cell.style.includes("nodeType=question")) return "question";
      if (cell.style && cell.style.includes("nodeType=options")) return "options";
      return "other";
    }

    // 1) Gather question nodes
    for (let id in allCells) {
      if (id === "0" || id === "1") continue;
      const cell = allCells[id];
      if (cell.vertex && getNodeType(cell) === "question") {
        const label = (cell.value || "").replace(/<[^>]+>/g, "").trim() || "Untitled";
        const qType = getQuestionType(cell);
        const qObj = {
          questionId: questionIdCounter,
          text: label,
          type: qType,
          logic: {
            enabled: false,
            conditions: []
          },
          jump: {
            enabled: false,
            option: "",
            to: ""
          },
          conditionalPDF: {
            enabled: false,
            pdfName: "",
            answer: "Yes"
          },
          conditionalAlert: {
            enabled: false,
            prevQuestion: "",
            prevAnswer: "",
            text: ""
          },
          options: [],
          labels: [],
          nameId: getNodeId(cell) || "",
          placeholder: ""
        };
        questionsArr.push(qObj);
        cell._questionId = questionIdCounter;
        questionIdCounter++;
      }
    }

    // 2) Connect options + logic
    for (let id in allCells) {
      if (id === "0" || id === "1") continue;
      const cell = allCells[id];
      if (!cell.vertex) continue;
      if (getNodeType(cell) !== "question") continue;

      const label = (cell.value || "").replace(/<[^>]+>/g, "").trim() || "Untitled";
      const qObj = questionsArr.find(q => q.text === label);
      if (!qObj) continue;

      const outEdges = graph.getOutgoingEdges(cell) || [];
      outEdges.forEach(edge => {
        const target = edge.target;
        if (!target) return;
        if (getNodeType(target) === "options") {
          const optLabel = (target.value || "Option").replace(/<[^>]+>/g, "").trim();
          const optNodeId = getNodeId(target);

          if (qObj.type === "checkbox") {
            qObj.options.push({
              label: capitalizeFirst(optLabel),
              nameId: optNodeId,
              value: ""
            });
          } else {
            qObj.options.push(capitalizeFirst(optLabel));
          }

          const nextEdges = graph.getOutgoingEdges(target) || [];
          nextEdges.forEach(ne => {
            const q2 = ne.target;
            if (q2 && getNodeType(q2) === "question") {
              if (!q2._questionId) return;
              if (q2._questionId < cell._questionId) {
                // jump backward
                qObj.jump.enabled = true;
                qObj.jump.option = capitalizeFirst(optLabel);
                qObj.jump.to = q2._questionId.toString();
              } else {
                // forward logic
                const q2Label = (q2.value||"").replace(/<[^>]+>/g, "").trim();
                const foundQ2 = questionsArr.find(o => o.text === q2Label);
                if (!foundQ2) return;
                foundQ2.logic.enabled = true;
                foundQ2.logic.conditions.push({
                  prevQuestion: qObj.questionId.toString(),
                  prevAnswer: capitalizeFirst(optLabel)
                });
              }
            }
          });
        }
      });
    }

    const guiData = {
      questions: questionsArr,
      hiddenFields: [],
      questionCounter: questionIdCounter,
      hiddenFieldCounter: 1,
      defaultPDFName: ""
    };

    downloadJson(JSON.stringify(guiData, null, 2), "gui_data.json");
  };

  function capitalizeFirst(str) {
    if (!str) return str;
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
</script>

</body>
</html>
