<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Flowchart Creator</title>
  <!-- mxGraph library -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mxgraph@4.2.2/javascript/mxClient.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
      user-select: none;
      /* If you want to see scrollbars, you can do overflow: auto; but we rely on panning. */
    }

    .toolbar {
      width: 220px;
      background: #f9f9f9;
      border-right: 1px solid #ccc;
      float: left;
      padding: 10px;
      box-sizing: border-box;
    }

    #graphContainer {
      position: absolute;
      left: 220px;
      right: 0;
      top: 0;
      bottom: 0;
      /* Panning will let us drag on whitespace */
      cursor: default;
    }

    .shape {
      background: #fff;
      border: 1px solid #999;
      margin-bottom: 8px;
      text-align: center;
      padding: 6px;
      border-radius: 4px;
      cursor: move;
    }
    .shape:hover {
      background: #e0e0e0;
    }

    .button-bar {
      margin-top: 15px;
    }
    button {
      margin-bottom: 6px;
      padding: 6px 10px;
      background-color: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: block;
      width: 100%;
      box-sizing: border-box;
    }
    button:hover {
      background-color: #0056b3;
    }

    input[type="file"] {
      display: none;
    }

    .context-menu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
      display: none;
      z-index: 1000;
      padding: 5px;
    }
    .context-menu button {
      border: none;
      background: none;
      color: #000;
      padding: 5px 10px;
      text-align: left;
      width: 100%;
      cursor: pointer;
    }
    .context-menu button:hover {
      background-color: #f0f0f0;
    }

    .submenu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      padding: 5px;
      display: none;
      z-index: 2000;
    }
    .submenu button {
      display: block;
      margin-bottom: 4px;
      border: none;
      background: none;
      color: #000;
      padding: 5px 10px;
      text-align: left;
      width: 100%;
      cursor: pointer;
    }
    .submenu button:hover {
      background-color: #f0f0f0;
    }

    /* A small properties dialog */
    #propertiesMenu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 4px;
      display: none;
      z-index: 3000; /* above context menus */
    }
    #propertiesMenu p {
      margin: 4px 0;
    }
  </style>
</head>

<body>
  <div class="toolbar">
    <h3>Shapes</h3>
    <!-- "Question Node" shape (default: dropdown, section=1) -->
    <div
      class="shape"
      data-type="question"
      data-style="rounded=1;whiteSpace=wrap;html=1;nodeType=question;questionType=dropdown;sectionId=1;"
    >
      Question Node
    </div>
    <!-- "Options Node" shape (default: dropdown, section=1) -->
    <div
      class="shape"
      data-type="options"
      data-style="rounded=1;whiteSpace=wrap;html=1;nodeType=options;questionType=dropdown;sectionId=1;"
    >
      Options Node
    </div>

    <div class="button-bar">
      <button onclick="exportFlowchartJson()">Export Flowchart JSON</button>
      <button onclick="document.getElementById('importFlowchartFile').click()">Import Flowchart</button>
      <input
        type="file"
        id="importFlowchartFile"
        accept=".json"
        onchange="importFlowchartJson(event)"
      />
      <button onclick="exportGuiJson()">Export GUI JSON</button>
    </div>
  </div>

  <div id="graphContainer"></div>

  <!-- Main context menu -->
  <div id="contextMenu" class="context-menu">
    <button id="deleteNode">Delete Node</button>
    <button id="duplicateNode">Duplicate Node</button>
    <button id="changeType">Change Type &raquo;</button>
    <button id="newSectionButton">New Section</button>
    <button id="propertiesButton">Properties</button>
  </div>

  <!-- Sub-menu for "Change Type" -->
  <div id="typeSubmenu" class="submenu">
    <button id="dropdownType">Drop Down</button>
    <button id="checkboxType">Checkbox</button>
    <button id="textType">Text</button>
  </div>

  <!-- Properties menu -->
  <div id="propertiesMenu">
    <p><strong>Node Type:</strong> <span id="propNodeType"></span></p>
    <p><strong>Section Name:</strong> <span id="propSectionName"></span></p>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      if (typeof mxGraph === "undefined") {
        alert("mxGraph library not found!");
        return;
      }

      const container = document.getElementById("graphContainer");
      const contextMenu = document.getElementById("contextMenu");
      const deleteNodeButton = document.getElementById("deleteNode");
      const duplicateNodeButton = document.getElementById("duplicateNode");
      const changeTypeButton = document.getElementById("changeType");
      const newSectionButton = document.getElementById("newSectionButton");
      const propertiesButton = document.getElementById("propertiesButton");

      const typeSubmenu = document.getElementById("typeSubmenu");
      const dropdownTypeBtn = document.getElementById("dropdownType");
      const checkboxTypeBtn = document.getElementById("checkboxType");
      const textTypeBtn = document.getElementById("textType");

      const propertiesMenu = document.getElementById("propertiesMenu");
      const propNodeType = document.getElementById("propNodeType");
      const propSectionName = document.getElementById("propSectionName");

      let selectedCell = null;

      // Setup mxGraph with panning
      mxEvent.disableContextMenu(container);
      const graph = new mxGraph(container);
      graph.setPanning(true);  // allow panning
      // This means left-click-drag on empty space moves the canvas
      graph.panningHandler.useLeftButtonForPanning = true;

      graph.setCellsMovable(true);
      graph.setConnectable(true);
      graph.setCellsResizable(true);

      // Rubberband for multi-select
      new mxRubberband(graph);

      function getSectionId(cell) {
        const style = cell.style || "";
        const match = style.match(/sectionId=([^;]+)/);
        return match ? parseInt(match[1]) : 1;
      }
      function setSectionId(cell, newSid) {
        let style = cell.style || "";
        style = style.replace(/sectionId=[^;]+/, "");
        style += `;sectionId=${newSid};`;
        graph.getModel().setStyle(cell, style);
      }
      function getQuestionType(cell) {
        const style = cell.style || "";
        const match = style.match(/questionType=([^;]+)/);
        return match ? match[1] : "dropdown";
      }
      function setQuestionType(cell, newType) {
        let style = cell.style || "";
        style = style.replace(/questionType=[^;]+/, "");
        style += `;questionType=${newType};`;
        graph.getModel().setStyle(cell, style);
      }
      function isQuestion(cell) {
        return cell && cell.style && cell.style.includes("nodeType=question");
      }
      function isOptions(cell) {
        return cell && cell.style && cell.style.includes("nodeType=options");
      }

      /**
       * Color-coding
       *  - dropdown => #ADD8E6
       *  - checkbox => #FFA07A
       *  - text => #90EE90
       *  - if it's the "first question" in that section and section>1 => pink (#FFC0CB)
       *  - options nodes adopt parent's color
       */
      function colorCell(cell) {
        if (!cell || !cell.vertex) return;

        const style = cell.style || "";
        const qType = getQuestionType(cell);
        const sId = getSectionId(cell);

        let fillColor = "#ADD8E6"; // default (dropdown)
        if (qType === "checkbox") {
          fillColor = "#FFA07A";
        } else if (qType === "text") {
          fillColor = "#90EE90";
        }

        // figure out if it's the "first question" in that section. We'll do:
        // "first question" = the question in that section with the lowest cell id
        // that might not be perfect, but it's a simple approach
        if (isQuestion(cell)) {
          if (sId > 1 && isFirstQuestionInSection(cell, sId)) {
            fillColor = "#FFC0CB"; // pink
          }
        }

        // If node is "options", adopt parent's color
        if (isOptions(cell)) {
          const edges = graph.getIncomingEdges(cell) || [];
          for (let e of edges) {
            if (isQuestion(e.source)) {
              fillColor = getQuestionColor(e.source);
              break;
            }
          }
        }

        // remove old fillColor=, add fillColor=...
        let newStyle = style.replace(/fillColor=[^;]+/, "");
        newStyle += `;fillColor=${fillColor};`;
        graph.getModel().setStyle(cell, newStyle);
      }

      function getQuestionColor(qCell) {
        // replicate the logic above, but for a question cell
        const qType = getQuestionType(qCell);
        let base = "#ADD8E6";
        if (qType === "checkbox") base = "#FFA07A";
        if (qType === "text") base = "#90EE90";

        const sId = getSectionId(qCell);
        if (sId>1 && isFirstQuestionInSection(qCell, sId)) {
          base = "#FFC0CB";
        }
        return base;
      }

      function isFirstQuestionInSection(cell, sId) {
        // find all question cells in the graph that have style: sectionId=sId
        // see if 'cell' has the smallest numeric cell.id
        let smallestId = parseInt(cell.id);
        const parent = graph.getDefaultParent();
        const allCells = graph.getChildVertices(parent);
        for (let c of allCells) {
          if (!c.style) continue;
          if (isQuestion(c) && getSectionId(c)===sId) {
            const cid = parseInt(c.id);
            if (cid < smallestId) {
              smallestId = cid;
            }
          }
        }
        return (parseInt(cell.id)===smallestId);
      }

      function refreshAllCells() {
        const parent = graph.getDefaultParent();
        const cells = graph.getChildVertices(parent);
        cells.forEach((c) => {
          colorCell(c);
          updateOverlay(c);
        });
      }

      function updateOverlay(cell) {
        // remove old overlays
        graph.removeCellOverlays(cell);
        if (!cell.vertex) return;

        const qType = getQuestionType(cell);
        // if it's question or options => we show the type
        let text = qType;
        if (isOptions(cell)) text = "options";

        const overlay = new mxCellOverlay(
          new mxImage("data:image/gif;base64,R0lGODlhAQABAAAAACw=",1,1),
          text
        );
        graph.addCellOverlay(cell, overlay);
      }

      // CONTEXT MENU
      let currentMouseEvent = null;
      graph.popupMenuHandler.factoryMethod = function(menu, cell, evt){
        selectedCell = cell;
        currentMouseEvent = evt;
        if (cell) {
          showContextMenu(evt);
        } else {
          hideContextMenu();
        }
      };
      function showContextMenu(evt){
        contextMenu.style.display="block";
        contextMenu.style.left=evt.clientX+"px";
        contextMenu.style.top=evt.clientY+"px";
        typeSubmenu.style.display="none";
      }
      function hideContextMenu(){
        contextMenu.style.display="none";
        typeSubmenu.style.display="none";
      }
      document.addEventListener("click",(e)=>{
        if (!contextMenu.contains(e.target) && !typeSubmenu.contains(e.target) && !propertiesMenu.contains(e.target)) {
          hideContextMenu();
          propertiesMenu.style.display="none";
        }
      });

      // Context menu items
      deleteNodeButton.addEventListener("click",()=>{
        if (selectedCell) {
          graph.removeCells([selectedCell]);
          refreshAllCells();
        }
        hideContextMenu();
      });
      duplicateNodeButton.addEventListener("click",()=>{
        if (selectedCell) {
          mxClipboard.setCells(mxClipboard.copyCells([selectedCell], false));
          let pasted = mxClipboard.paste(graph);
          if(pasted && pasted.length>0) {
            graph.moveCells(pasted,40,40);
          }
          refreshAllCells();
        }
        hideContextMenu();
      });
      changeTypeButton.addEventListener("click",()=>{
        const rect=contextMenu.getBoundingClientRect();
        typeSubmenu.style.display="block";
        typeSubmenu.style.left=rect.right+"px";
        typeSubmenu.style.top=rect.top+"px";
      });
      dropdownTypeBtn.addEventListener("click",()=>{
        if(selectedCell && isQuestion(selectedCell)){
          setQuestionType(selectedCell,"dropdown");
          // optionally rename label
          selectedCell.value="Dropdown question node";
          refreshAllCells();
        }
        hideContextMenu();
      });
      checkboxTypeBtn.addEventListener("click",()=>{
        if(selectedCell && isQuestion(selectedCell)){
          setQuestionType(selectedCell,"checkbox");
          selectedCell.value="Checkbox question node";
          refreshAllCells();
        }
        hideContextMenu();
      });
      textTypeBtn.addEventListener("click",()=>{
        if(selectedCell && isQuestion(selectedCell)){
          setQuestionType(selectedCell,"text");
          selectedCell.value="Text question node";
          refreshAllCells();
        }
        hideContextMenu();
      });
      newSectionButton.addEventListener("click",()=>{
        if(selectedCell && isQuestion(selectedCell)){
          // increment section
          let oldSid = getSectionId(selectedCell);
          let newSid = oldSid+1;
          setSectionId(selectedCell, newSid);
          refreshAllCells();
        }
        hideContextMenu();
      });
      propertiesButton.addEventListener("click",()=>{
        if (selectedCell) {
          showPropertiesMenu(selectedCell, currentMouseEvent);
        }
        hideContextMenu();
      });

      // Show a small "Properties" panel with Node Type & Section Name
      function showPropertiesMenu(cell, evt){
        if(!cell) return;
        // compute node type
        let nodeType = "unknown";
        if(isQuestion(cell)) {
          nodeType = getQuestionType(cell);
        } else if(isOptions(cell)) {
          nodeType = "options";
        }
        propNodeType.textContent = nodeType;

        let sId = getSectionId(cell);
        let sName = "Section "+ sId;
        propSectionName.textContent = sName;

        propertiesMenu.style.display = "block";
        propertiesMenu.style.left = (evt.clientX+10)+"px";
        propertiesMenu.style.top = (evt.clientY+10)+"px";
      }

      // SHIFT+ drag is omitted. We rely on panning in empty space.

      // Key handler: ctrl+c / ctrl+v
      const keyHandler = new mxKeyHandler(graph);
      keyHandler.bindControlKey(67,()=>{ mxClipboard.copy(graph); });
      keyHandler.bindControlKey(86,()=>{
        let pasted = mxClipboard.paste(graph);
        if(pasted && pasted.length>0) {
          graph.moveCells(pasted,40,40);
          refreshAllCells();
        }
      });

      // Drag & drop from the toolbar
      const toolbarShapes = document.querySelectorAll(".shape");
      toolbarShapes.forEach(shapeEl=>{
        const baseStyle = shapeEl.dataset.style;
        mxUtils.makeDraggable(
          shapeEl,
          graph,
          function(graph,evt,targetCell,x,y){
            const parent = graph.getDefaultParent();
            graph.getModel().beginUpdate();
            let newVertex;
            try{
              newVertex = graph.insertVertex(
                parent,
                null,
                shapeEl.dataset.type + " node",
                x,y,
                100,60,
                baseStyle
              );
            } finally {
              graph.getModel().endUpdate();
            }
            refreshAllCells();
            return newVertex;
          }
        );
      });

      // Label ends with '?', classify as question
      graph.getModel().addListener(mxEvent.EVENT_CHANGE, function(sender,evt){
        const changes = evt.getProperty("changes");
        if(!changes) return;
        changes.forEach(change=>{
          if(change.constructor.name==="mxValueChange"){
            const {cell,value} = change;
            if(value && typeof value==="string"){
              if(value.trim().endsWith("?")){
                if(!isQuestion(cell)){
                  let style=cell.style||"";
                  style += ";nodeType=question;";
                  graph.getModel().setStyle(cell,style);
                }
              }
            }
          }
        });
        refreshAllCells();
      });

      // If question => target is options
      graph.connectionHandler.addListener(mxEvent.CONNECT, function(sender,evt){
        const edge=evt.getProperty("cell");
        if(!edge) return;
        const source=edge.source;
        const target=edge.target;
        if(source && isQuestion(source)){
          // mark target as options
          if(!isOptions(target)){
            let style=target.style||"";
            style += ";nodeType=options;";
            graph.getModel().setStyle(target, style);
          }
        }
        refreshAllCells();
      });

      // For debugging
      window.exportFlowchartJson = function(){
        const data=[];
        const cells = graph.getModel().cells;
        for(let id in cells){
          if(id==="0"||id==="1") continue;
          const cell=cells[id];
          data.push({
            id:cell.id,
            value:cell.value,
            geometry:cell.geometry?{
              x: cell.geometry.x,
              y: cell.geometry.y,
              width: cell.geometry.width,
              height: cell.geometry.height
            }:null,
            style: cell.style||"",
            vertex: !!cell.vertex,
            edge: !!cell.edge,
            source: cell.edge ? cell.source?.id : null,
            target: cell.edge ? cell.target?.id : null
          });
        }
        downloadJson(JSON.stringify(data,null,2),"flowchart_data.json");
      };

      function downloadJson(jsonString,filename){
        const blob=new Blob([jsonString],{type:"application/json"});
        const url=URL.createObjectURL(blob);
        const link=document.createElement("a");
        link.href=url;
        link.download=filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }
      window.importFlowchartJson=function(evt){
        const file=evt.target.files[0];
        if(!file)return;
        const reader=new FileReader();
        reader.onload=function(e){
          const jsonData=JSON.parse(e.target.result);
          loadFlowchartData(jsonData);
        };
        reader.readAsText(file);
      };
      function loadFlowchartData(data){
        graph.getModel().beginUpdate();
        try{
          const parent = graph.getDefaultParent();
          graph.removeCells(graph.getChildVertices(parent));
          const createdCells={};
          // pass1: vertices
          data.forEach((item)=>{
            if(item.vertex){
              const geo=new mxGeometry(
                item.geometry.x,
                item.geometry.y,
                item.geometry.width,
                item.geometry.height
              );
              const newCell=new mxCell(item.value,geo,item.style);
              newCell.vertex=true;
              newCell.id=item.id;
              graph.addCell(newCell,parent);
              createdCells[item.id]=newCell;
            }
          });
          // pass2: edges
          data.forEach((item)=>{
            if(item.edge){
              const newEdge=new mxCell(item.value,new mxGeometry(),item.style);
              newEdge.edge=true;
              newEdge.id=item.id;
              const src=createdCells[item.source];
              const trg=createdCells[item.target];
              graph.addCell(newEdge,parent,undefined,src,trg);
            }
          });
        }finally{
          graph.getModel().endUpdate();
        }
        refreshAllCells();
      }

      // Export GUI JSON with multiple sections
      window.exportGuiJson = function(){
        const model=graph.getModel();
        const allCells=model.cells;

        // We'll store question nodes grouped by section
        const sectionsMap = {};
        let questionIdCounter=1;
        let maxSectionId=1;

        function getNodeType(cell){
          return (cell.style||"").includes("nodeType=question")?"question":
                 (cell.style||"").includes("nodeType=options")?"options":"other";
        }

        // 1) gather question nodes, grouping by section
        for(let id in allCells){
          if(id==="0"||id==="1") continue;
          const cell=allCells[id];
          if(cell.vertex && getNodeType(cell)==="question"){
            const sId = getSectionId(cell);
            if(sId>maxSectionId) maxSectionId=sId;
            const label=(cell.value||"").toString().trim()||"Untitled";
            const qType=getQuestionType(cell);

            // We'll build partial question obj
            // We'll fill in the 'options' in step2
            const questionObj={
              questionId: questionIdCounter,
              text: label,
              type: qType,
              logic: { enabled:false, prevQuestion:"", prevAnswer:"" },
              jump: { enabled:false, option:"", to:"" },
              conditionalPDF: {
                enabled:false,
                pdfName:"",
                answer:"Yes"
              },
              conditionalAlert: {
                enabled:false,
                prevQuestion:"",
                prevAnswer:"",
                text:""
              },
              options: [],
              labels: []
            };
            if(!sectionsMap[sId]) sectionsMap[sId]=[];
            sectionsMap[sId].push(questionObj);

            questionIdCounter++;
          }
        }

        // 2) For each question node, gather options from connected "options" nodes
        for(let id in allCells){
          if(id==="0"||id==="1") continue;
          const cell=allCells[id];
          if(cell.vertex && getNodeType(cell)==="question"){
            const sId=getSectionId(cell);
            const label=(cell.value||"").toString().trim()||"Untitled";
            // find that question object
            let questionList = sectionsMap[sId]||[];
            let qObj = questionList.find(q=>q.text===label);
            if(!qObj) continue;

            const outEdges=graph.getOutgoingEdges(cell)||[];
            outEdges.forEach(edge=>{
              const target=edge.target;
              if(!target) return;
              if(getNodeType(target)==="options"){
                const optLabel=(target.value||"").toString().trim()||"Option";
                if(qObj.type==="checkbox"){
                  qObj.options.push({
                    label: optLabel,
                    nameId:"",
                    value:""
                  });
                } else {
                  // for dropdown, text, etc => array of strings
                  qObj.options.push(optLabel);
                }

                // see if that option leads to another question => logic
                const nextEdges=graph.getOutgoingEdges(target)||[];
                nextEdges.forEach(ne=>{
                  const q2=ne.target;
                  if(q2 && getNodeType(q2)==="question"){
                    // find q2 in the appropriate section
                    const q2Sid=getSectionId(q2);
                    const q2Label=(q2.value||"").toString().trim()||"Untitled";
                    let q2List=sectionsMap[q2Sid]||[];
                    let q2Obj=q2List.find(o=>o.text===q2Label);
                    if(q2Obj){
                      q2Obj.logic.enabled=true;
                      q2Obj.logic.prevQuestion=qObj.questionId.toString();
                      q2Obj.logic.prevAnswer=optLabel;
                    }
                  }
                });
              }
            });
          }
        }

        // produce final array of sections
        const sectionsArr=[];
        for(let s=1; s<=maxSectionId; s++){
          const qList=sectionsMap[s]||[];
          sectionsArr.push({
            sectionId: s,
            sectionName: "Section "+s,
            questions: qList
          });
        }

        const guiData={
          sections: sectionsArr,
          hiddenFields: [],
          sectionCounter: maxSectionId+1,
          questionCounter: questionIdCounter,
          hiddenFieldCounter:1,
          defaultPDFName:""
        };

        downloadJson(JSON.stringify(guiData,null,2),"gui_data.json");
      };
    });
  </script>
</body>
</html>
