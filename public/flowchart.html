<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Flowchart Creator (Rounded, Larger Font, Sections JSON, Zoom Scroll, Saved Flowcharts)</title>
  <!-- mxGraph -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mxgraph@4.2.2/javascript/mxClient.min.js"></script>
  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
      user-select: none;
      /* Prevent default browser wheel scroll so we can do zoom */
      overflow: hidden;
    }
    .toolbar {
      width: 220px;
      background: #f9f9f9;
      border-right: 1px solid #ccc;
      float: left;
      padding: 10px;
      box-sizing: border-box;
      height: 100%;
      overflow-y: auto;
    }
    #graphContainer {
      position: absolute;
      left: 220px;
      right: 0;
      top: 0;
      bottom: 0;
      cursor: default;
      /* This container is where we do the wheel zoom */
      overflow: hidden;
    }
    .shape {
      background: #fff;
      border: 1px solid #999;
      margin-bottom: 8px;
      text-align: center;
      padding: 6px;
      border-radius: 4px;
      cursor: move;
    }
    .shape:hover {
      background: #e0e0e0;
    }
    .button-bar {
      margin-top: 15px;
    }
    button {
      margin-bottom: 6px;
      padding: 6px 10px;
      background-color: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: block;
      width: 100%;
      box-sizing: border-box;
    }
    button:hover {
      background-color: #0056b3;
    }
    input[type="file"] {
      display: none;
    }
    .context-menu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
      display: none;
      z-index: 1000;
      padding: 5px;
    }
    .context-menu button {
      border: none;
      background: none;
      color: #000;
      padding: 5px 10px;
      text-align: left;
      width: 100%;
      cursor: pointer;
    }
    .context-menu button:hover {
      background-color: #f0f0f0;
    }
    .submenu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      padding: 5px;
      display: none;
      z-index: 2000;
    }
    .submenu button {
      display: block;
      margin-bottom: 4px;
      border: none;
      background: none;
      color: #000;
      padding: 5px 10px;
      text-align: left;
      width: 100%;
      cursor: pointer;
    }
    .submenu button:hover {
      background-color: #f0f0f0;
    }

    #propertiesMenu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 4px;
      display: none;
      z-index: 3000;
      width: 220px;
    }
    #propertiesMenu p {
      margin: 4px 0;
    }
    .editable-field {
      border: 1px dashed transparent;
      padding: 2px;
      display: inline-block;
      min-width: 50px;
      cursor: text;
    }
    .editable-field:focus {
      outline: 1px dashed #888;
    }

    .legend {
      margin-top: 10px;
      padding: 6px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .legend .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
    }
    .legend-color-box {
      width: 20px;
      height: 20px;
      margin-right: 8px;
      cursor: pointer;
      border: 1px solid #ccc;
      border-radius: 3px;
    }

    #loginOverlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0,0,0,0.5);
      display: none;
      z-index: 9999;
      align-items: center;
      justify-content: center;
    }
    #loginForm {
      background: #fff;
      padding: 20px;
      border-radius: 6px;
      min-width: 300px;
    }
    #loginForm input[type="email"],
    #loginForm input[type="password"] {
      width: 100%;
      margin-bottom: 10px;
      padding: 8px;
      box-sizing: border-box;
    }
    #loginError {
      color: red;
      margin-bottom: 8px;
    }

    .mxGraph .mxCellEditor,
    .mxGraph .mxCellOverlay {
      background: transparent !important;
    }
    .mxCellEditor {
      background: #ffffff !important;
      border-radius: 12px !important;
      overflow: visible !important;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15) !important;
      box-sizing: border-box !important;
    }
    .mxCellEditor div {
      padding: 16px !important;
      border: 1px solid #ccc !important;
      border-radius: 12px !important;
      background: #ffffff !important;
      min-width: 20px !important;
      min-height: 60px !important;
      box-sizing: border-box !important;
    }
    .mxCellEditor textarea {
      padding: 16px !important;
      border: 1px solid #ccc !important;
      border-radius: 12px !important;
      background: #ffffff !important;
      min-width: 20px !important;
      min-height: 50px !important;
      resize: none;
      box-sizing: border-box !important;
    }

    /* Flowchart List Overlay (View Saved Flowcharts) */
    #flowchartListOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 9999;
      display: none;  /* hidden by default */
      justify-content: center;
      align-items: center;
    }
    #flowchartListPanel {
      background: #fff;
      padding: 20px;
      border-radius: 6px;
      min-width: 300px;
      text-align: center;
    }
    #flowchartListPanel h3 {
      margin-top: 0;
      text-align: center;
    }
    .flowchart-item {
      margin-bottom: 16px; /* More space below each item */
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 6px;
      text-align: center;
    }
    .flowchart-item strong {
      display: block;
      margin-bottom: 6px;
    }
    .flowchart-item button {
      margin-right: 6px;
    }
  </style>
</head>
<body>

<div id="loginOverlay">
  <div id="loginForm">
    <h3>Login</h3>
    <div id="loginError"></div>
    <input type="email" id="loginEmail" placeholder="Email" /><br/>
    <input type="password" id="loginPassword" placeholder="Password" /><br/>
    <button id="loginButton">Login</button>
    <button id="signupButton">Sign Up</button>
  </div>
</div>

<div id="flowchartListOverlay">
  <div id="flowchartListPanel">
    <h3>Saved Flowcharts</h3>
    <div id="flowchartList"></div>
    <br/>
    <button id="closeFlowchartListBtn">Close</button>
  </div>
</div>

<div class="toolbar">
  <h3>Shapes</h3>
  <div
    class="shape"
    data-type="question"
    data-style="shape=roundRect;rounded=1;arcSize=20;whiteSpace=wrap;html=1;nodeType=question;questionType=dropdown;nodeId=Question_node;section=1;spacing=12;fontSize=16;"
  >
    Question Node
  </div>
  <div
    class="shape"
    data-type="options"
    data-style="shape=roundRect;rounded=1;arcSize=20;whiteSpace=wrap;html=1;nodeType=options;questionType=dropdown;nodeId=Option_node;section=1;spacing=12;fontSize=16;"
  >
    Options Node
  </div>

  <div class="button-bar">
    <button onclick="exportFlowchartJson()">Export Flowchart JSON</button>
    <button onclick="document.getElementById('importFlowchartFile').click()">Import Flowchart</button>
    <input
      type="file"
      id="importFlowchartFile"
      accept=".json"
      onchange="importFlowchartJson(event)"
    />
    <button onclick="exportGuiJson()">Export GUI JSON</button>
  </div>

  <div class="legend">
    <strong>Legend</strong><br><p>
    <div class="legend-item">
      <div class="legend-color-box" id="colorText"></div>
      <span>Textbox</span>
    </div>
    <div class="legend-item">
      <div class="legend-color-box" id="colorCheckbox"></div>
      <span>Checkbox</span>
    </div>
    <div class="legend-item">
      <div class="legend-color-box" id="colorDropdown"></div>
      <span>Dropdown</span>
    </div>
    <div class="legend-item">
      <div class="legend-color-box" id="colorMoney"></div>
      <span>Money</span>
    </div>
    <div class="legend-item">
      <div class="legend-color-box" id="colorDate"></div>
      <span>Date</span>
    </div>
    <div class="legend-item">
      <div class="legend-color-box" id="colorBigParagraph"></div>
      <span>Big Paragraph</span>
    </div>
    <div class="legend-item">
      <div class="legend-color-box" id="colorTextColor"></div>
      <span>Text Color</span>
    </div>
	<button id="resetBtn">Reset Colors</button>
  </div>

  <!-- Below the legend -->
  
  <br>
  <button id="saveFlowchartBtn" onclick="saveFlowchart()">Save Flowchart</button>
  <button id="viewFlowchartBtn" onclick="viewSavedFlowcharts()">View Saved</button>

  <button id="logoutBtn">Logout</button>
</div>

<div id="graphContainer"></div>

<div id="contextMenu" class="context-menu">
  <button id="deleteNode">Delete Node</button>
  <button id="jumpNode">Jump</button>
  <button id="changeType">Change Type &raquo;</button>
  <button id="propertiesButton">Properties</button>
  <button id="yesNoNode">Yes/No</button>
  <button id="newSectionNode">New Section</button>
</div>

<div id="typeSubmenu" class="submenu">
  <button id="dropdownType">Drop Down</button>
  <button id="checkboxType">Checkbox</button>
  <button id="textType">Text</button>
  <button id="moneyType">Money</button>
  <button id="dateType">Date</button>
  <button id="bigParagraphType">Big Paragraph</button>
</div>

<div id="propertiesMenu">
  <p><strong>Node Text:</strong>
    <span id="propNodeText" class="editable-field" tabindex="0"></span>
  </p>
  <p><strong>Node ID:</strong>
    <span id="propNodeId" class="editable-field" tabindex="0"></span>
  </p>
  <p><strong>Section:</strong>
    <span id="propNodeSection" class="editable-field" tabindex="0"></span>
  </p>
  <p><strong>Node Type:</strong> <span id="propNodeType"></span></p>
</div>

<!-- Hidden color pickers -->
<input type="color" id="colorPickerText" style="display:none;" />
<input type="color" id="colorPickerCheckbox" style="display:none;" />
<input type="color" id="colorPickerDropdown" style="display:none;" />
<input type="color" id="colorPickerMoney" style="display:none;" />
<input type="color" id="colorPickerDate" style="display:none;" />
<input type="color" id="colorPickerBigParagraph" style="display:none;" />
<input type="color" id="colorPickerTextColor" style="display:none;" />

<script>
  /**************************************************
   ************ Firebase Config & Basic Auth ********
   **************************************************/
  const firebaseConfig = {
    apiKey: "AIzaSyBlxFmFD-rz1V_Q9_oV0DkLsENbmyJ1k-U",
    authDomain: "flowchart-1eb90.firebaseapp.com",
    projectId: "flowchart-1eb90",
    storageBucket: "flowchart-1eb90.firebasestorage.app",
    messagingSenderId: "546103281533",
    appId: "1:546103281533:web:ae719cdbde727dcd94ee14",
    measurementId: "G-8VSXRFREY9"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
  let currentUser = null;

  // For "Reset" button
  const defaultColors = {
    text: "#cce6ff",
    checkbox: "#b3daff",
    dropdown: "#99ccff",
    money: "#80bfff",
    date: "#4da6ff",
    bigParagraph: "#1a8cff",
    textColor: "#000000"
  };
  let colorPreferences = { ...defaultColors };

  // If user has opened a flowchart by name, store it here
  let currentFlowchartName = null;

  const loginOverlay = document.getElementById("loginOverlay");
  const loginButton = document.getElementById("loginButton");
  const signupButton = document.getElementById("signupButton");
  const loginEmail = document.getElementById("loginEmail");
  const loginPassword = document.getElementById("loginPassword");
  const loginError = document.getElementById("loginError");

  const flowchartListOverlay = document.getElementById("flowchartListOverlay");
  const flowchartListDiv = document.getElementById("flowchartList");
  const closeFlowchartListBtn = document.getElementById("closeFlowchartListBtn");

  const logoutBtn = document.getElementById("logoutBtn");

  function showLoginOverlay() {
    loginOverlay.style.display = "flex";
  }
  function hideLoginOverlay() {
    loginOverlay.style.display = "none";
  }
  function setCookie(name, value, days) {
    const d = new Date();
    d.setTime(d.getTime() + days*24*60*60*1000);
    const expires = "expires="+ d.toUTCString();
    document.cookie = name + "=" + value + ";" + expires + ";path=/";
  }
  function getCookie(name) {
    const ca = document.cookie.split(';');
    name = name + "=";
    for (let i=0; i < ca.length; i++) {
      let c = ca[i].trim();
      if (c.indexOf(name) === 0) {
        return c.substring(name.length, c.length);
      }
    }
    return "";
  }

  loginButton.addEventListener("click", () => {
    const email = loginEmail.value.trim();
    const pass = loginPassword.value.trim();
    firebase.auth().signInWithEmailAndPassword(email, pass)
      .then(cred => {
        currentUser = cred.user;
        setCookie("flowchart_uid", currentUser.uid, 7);
        hideLoginOverlay();
        loadUserColorPrefs();
      })
      .catch(err => {
        loginError.textContent = err.message;
      });
  });
  signupButton.addEventListener("click", () => {
    const email = loginEmail.value.trim();
    const pass = loginPassword.value.trim();
    firebase.auth().createUserWithEmailAndPassword(email, pass)
      .then(cred => {
        currentUser = cred.user;
        setCookie("flowchart_uid", currentUser.uid, 7);
        hideLoginOverlay();
        saveUserColorPrefs().then(() => loadUserColorPrefs());
      })
      .catch(err => {
        loginError.textContent = err.message;
      });
  });

  // Logout
  logoutBtn.addEventListener("click", () => {
    if (!currentUser) {
      alert("No user is logged in.");
      return;
    }
    firebase.auth().signOut()
      .then(() => {
        setCookie("flowchart_uid", "", -1); // clear the cookie
        currentUser = null;
        showLoginOverlay();
      })
      .catch(err => {
        console.error("Logout error:", err);
        alert("Error logging out: " + err);
      });
  });

  function checkForSavedLogin() {
    const savedUid = getCookie("flowchart_uid");
    if (savedUid) {
      firebase.auth().onAuthStateChanged(user => {
        if (user && user.uid === savedUid) {
          currentUser = user;
          hideLoginOverlay();
          loadUserColorPrefs();
        } else {
          showLoginOverlay();
        }
      });
    } else {
      showLoginOverlay();
    }
  }

  function loadUserColorPrefs() {
    if (!currentUser) return;
    db.collection("users")
      .doc(currentUser.uid)
      .collection("preferences")
      .doc("colors")
      .get()
      .then(docSnap => {
        if (docSnap.exists) {
          const data = docSnap.data();
          for (let key in defaultColors) {
            if (data[key] !== undefined) {
              colorPreferences[key] = data[key];
            } else {
              colorPreferences[key] = defaultColors[key];
            }
          }
        }
        updateLegendColors();
        refreshAllCells();
      })
      .catch(err => {
        console.error("Error loading color prefs:", err);
      });
  }
  
  // Function to handle color change when clicking legend boxes
function setupColorPicker(colorBoxId, colorPickerId, colorKey) {
    const colorBox = document.getElementById(colorBoxId);
    const colorPicker = document.getElementById(colorPickerId);

    colorBox.addEventListener("click", () => {
        // Set color picker value to the current color before opening
        colorPicker.value = colorPreferences[colorKey]; 
        colorPicker.click();
    });

    colorPicker.addEventListener("input", (e) => {
        colorPreferences[colorKey] = e.target.value;
        updateLegendColors();
        refreshAllCells();
        saveUserColorPrefs();
    });
}

// Attach event listeners for all color boxes
setupColorPicker("colorText", "colorPickerText", "text");
setupColorPicker("colorCheckbox", "colorPickerCheckbox", "checkbox");
setupColorPicker("colorDropdown", "colorPickerDropdown", "dropdown");
setupColorPicker("colorMoney", "colorPickerMoney", "money");
setupColorPicker("colorDate", "colorPickerDate", "date");
setupColorPicker("colorBigParagraph", "colorPickerBigParagraph", "bigParagraph");
setupColorPicker("colorTextColor", "colorPickerTextColor", "textColor");

  function saveUserColorPrefs() {
    if (!currentUser) return Promise.resolve();
    return db.collection("users")
      .doc(currentUser.uid)
      .collection("preferences")
      .doc("colors")
      .set(colorPreferences, { merge: true });
  }
</script>

<script>
  let graph = null;
  let selectedCell = null;
  let currentMouseEvent = null;
  let lastSelectedCell = null;
  let jumpModeNode = null;
  const jumpBorderStyle = ";strokeWidth=3;strokeColor=#ff0000;dashed=1;dashPattern=4 4;";

  // We define loadFlowchartData globally so "openSavedFlowchart" can call it
  function loadFlowchartData(data) {
    graph.getModel().beginUpdate();
    try {
      const parent = graph.getDefaultParent();
      graph.removeCells(graph.getChildVertices(parent));
      const createdCells = {};

      data.forEach((item) => {
        if (item.vertex) {
          const geo = new mxGeometry(
            item.geometry.x,
            item.geometry.y,
            item.geometry.width,
            item.geometry.height
          );
          const newCell = new mxCell(item.value, geo, item.style);
          newCell.vertex = true;
          newCell.id = item.id;
          graph.addCell(newCell, parent);
          createdCells[item.id] = newCell;
        }
      });

      data.forEach((item) => {
        if (item.edge) {
          const newEdge = new mxCell(item.value, new mxGeometry(), item.style);
          newEdge.edge = true;
          newEdge.id = item.id;
          const src = createdCells[item.source];
          const trg = createdCells[item.target];
          graph.addCell(newEdge, parent, undefined, src, trg);
        }
      });
    } finally {
      graph.getModel().endUpdate();
    }
    refreshAllCells();
  }

  document.addEventListener("DOMContentLoaded", function() {
    checkForSavedLogin();

    const container = document.getElementById("graphContainer");
    const contextMenu = document.getElementById("contextMenu");
    const deleteNodeButton = document.getElementById("deleteNode");
    const jumpNodeButton = document.getElementById("jumpNode");
    const changeTypeButton = document.getElementById("changeType");
    const propertiesButton = document.getElementById("propertiesButton");
    const yesNoNodeButton = document.getElementById("yesNoNode");
    const newSectionButton = document.getElementById("newSectionNode");

    const typeSubmenu = document.getElementById("typeSubmenu");
    const dropdownTypeBtn = document.getElementById("dropdownType");
    const checkboxTypeBtn = document.getElementById("checkboxType");
    const textTypeBtn = document.getElementById("textType");
    const moneyTypeBtn = document.getElementById("moneyType");
    const dateTypeBtn = document.getElementById("dateType");
    const bigParagraphTypeBtn = document.getElementById("bigParagraphType");

    const propertiesMenu = document.getElementById("propertiesMenu");
    const propNodeText = document.getElementById("propNodeText");
    const propNodeId = document.getElementById("propNodeId");
    const propNodeType = document.getElementById("propNodeType");
    const propNodeSection = document.getElementById("propNodeSection");

    const resetBtn = document.getElementById("resetBtn");

    // Create graph
    graph = new mxGraph(container);
    // Enter => newline
    graph.setEnterStopsCellEditing(false);
    graph.setHtmlLabels(true);

    // Enable left-button panning on whitespace:
    graph.setPanning(true);
    graph.panningHandler.useLeftButtonForPanning = true;

    mxEvent.disableContextMenu(container);
    graph.setCellsMovable(true);
    graph.setConnectable(true);
    graph.setCellsResizable(true);
    new mxRubberband(graph);

    // Default style
    const defStyle = graph.getStylesheet().getDefaultVertexStyle();
    defStyle["shape"] = mxConstants.SHAPE_ROUND_RECT;
    defStyle["rounded"] = "1";
    defStyle["arcSize"] = "20";
    defStyle["fontSize"] = "16";
    defStyle["spacing"] = "12";

    // Zoom with mouse wheel
    mxEvent.addMouseWheelListener(function(evt, up) {
      if (!mxEvent.isConsumed(evt)) {
        if (up) graph.zoomIn();
        else graph.zoomOut();
        mxEvent.consume(evt);
      }
    }, container);

    // Track selection
    graph.getSelectionModel().addListener(mxEvent.CHANGE, () => {
      if (lastSelectedCell) {
        autoUpdateNodeIdBasedOnLabel(lastSelectedCell);
      }
      lastSelectedCell = graph.getSelectionCell();
    });

    // Draggable shapes
    const toolbarShapes = document.querySelectorAll(".shape");
    toolbarShapes.forEach(shapeEl => {
      const baseStyle = shapeEl.dataset.style;
      mxUtils.makeDraggable(
        shapeEl,
        graph,
        function (graph, evt, targetCell, x, y) {
          const parent = graph.getDefaultParent();
          graph.getModel().beginUpdate();
          let newVertex;
          try {
            const label = shapeEl.dataset.type + " node";
            newVertex = graph.insertVertex(
              parent,
              null,
              label,
              x,
              y,
              160,
              80,
              baseStyle
            );
          } finally {
            graph.getModel().endUpdate();
          }
          if (isQuestion(newVertex)) {
            refreshNodeIdFromLabel(newVertex);
          } else if (isOptions(newVertex)) {
            refreshOptionNodeId(newVertex);
          }
          refreshAllCells();
          return newVertex;
        }
      );
    });

    // Context menu
    graph.popupMenuHandler.factoryMethod = function(menu, cell, evt) {
      selectedCell = cell;
      currentMouseEvent = evt;
      if (cell) showContextMenu(evt);
      else hideContextMenu();
    };
    function showContextMenu(evt) {
      contextMenu.style.display = "block";
      contextMenu.style.left = evt.clientX + "px";
      contextMenu.style.top = evt.clientY + "px";
      typeSubmenu.style.display = "none";
    }
    function hideContextMenu() {
      contextMenu.style.display = "none";
      typeSubmenu.style.display = "none";
    }
    document.addEventListener("click", e => {
      if (!contextMenu.contains(e.target)
          && !typeSubmenu.contains(e.target)
          && !propertiesMenu.contains(e.target)
      ) {
        hideContextMenu();
        propertiesMenu.style.display = "none";
      }
    });

    deleteNodeButton.addEventListener("click", () => {
      if (selectedCell) {
        graph.removeCells([selectedCell]);
        refreshAllCells();
      }
      hideContextMenu();
    });
    jumpNodeButton.addEventListener("click", () => {
      if (selectedCell) {
        if (jumpModeNode && jumpModeNode !== selectedCell) {
          removeJumpStyling(jumpModeNode);
        }
        jumpModeNode = selectedCell;
        addJumpStyling(jumpModeNode);
      }
      hideContextMenu();
    });
    changeTypeButton.addEventListener("click", () => {
      const rect = contextMenu.getBoundingClientRect();
      typeSubmenu.style.display = "block";
      typeSubmenu.style.left = rect.right + "px";
      typeSubmenu.style.top = rect.top + "px";
    });
    dropdownTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "dropdown");
        selectedCell.value = "Dropdown question node";
        refreshAllCells();
      }
      hideContextMenu();
    });
    checkboxTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "checkbox");
        selectedCell.value = "Checkbox question node";
        refreshAllCells();
      }
      hideContextMenu();
    });
    textTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "text");
        selectedCell.value = "Text question node";
        refreshAllCells();
      }
      hideContextMenu();
    });
    moneyTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "money");
        selectedCell.value = "Money question node";
        refreshAllCells();
      }
      hideContextMenu();
    });
    dateTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "date");
        selectedCell.value = "Date question node";
        refreshAllCells();
      }
      hideContextMenu();
    });
    bigParagraphTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "bigParagraph");
        selectedCell.value = "Big Paragraph question node";
        refreshAllCells();
      }
      hideContextMenu();
    });

    yesNoNodeButton.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        createYesNoOptions(selectedCell);
      }
      hideContextMenu();
    });
    // "New Section" => increments this node's section number by 1
    newSectionButton.addEventListener("click", () => {
      if (selectedCell) {
        const currentSection = parseInt(getSection(selectedCell) || "1", 10);
        setSection(selectedCell, currentSection + 1);
        refreshAllCells();
      }
      hideContextMenu();
    });

    function createYesNoOptions(parentCell) {
      // Place them further below the parent
      const geo = parentCell.geometry;
      if (!geo) return;
      const parent = graph.getDefaultParent();
      graph.getModel().beginUpdate();
      try {
        const parentSection = getSection(parentCell) || "1";

        // "No" node
        const noX = geo.x + geo.width - 50;
        const noY = geo.y + geo.height + 50;  // further below
        const noStyle = "shape=roundRect;rounded=1;arcSize=20;whiteSpace=wrap;html=1;nodeType=options;questionType=dropdown;spacing=12;fontSize=16;";
        const noNode = graph.insertVertex(parent, null, "No", noX, noY, 100, 60, noStyle);
        refreshOptionNodeId(noNode);

        // Inherit section if parent not in jump mode:
        if (parentCell !== jumpModeNode) {
          setSection(noNode, parentSection);
        }
        graph.insertEdge(parent, null, "", parentCell, noNode);

        // "Yes" node
        const yesX = geo.x - 40;
        const yesY = geo.y + geo.height + 50;  // further below
        const yesStyle = "shape=roundRect;rounded=1;arcSize=20;whiteSpace=wrap;html=1;nodeType=options;questionType=dropdown;spacing=12;fontSize=16;";
        const yesNode = graph.insertVertex(parent, null, "Yes", yesX, yesY, 100, 60, yesStyle);
        refreshOptionNodeId(yesNode);

        if (parentCell !== jumpModeNode) {
          setSection(yesNode, parentSection);
        }
        graph.insertEdge(parent, null, "", parentCell, yesNode);
      } finally {
        graph.getModel().endUpdate();
      }
      refreshAllCells();
    }

    function showPropertiesMenu(cell, evt) {
      if (!cell) return;
      propertiesMenu.style.display = "block";
      propertiesMenu.style.left = evt.clientX + 10 + "px";
      propertiesMenu.style.top = evt.clientY + 10 + "px";

      propNodeText.textContent = cell.value || "";
      propNodeId.textContent = getNodeId(cell) || "";
      propNodeSection.textContent = getSection(cell) || "1";

      if (isQuestion(cell)) {
        propNodeType.textContent = getQuestionType(cell);
      } else if (isOptions(cell)) {
        propNodeType.textContent = "options";
      } else {
        propNodeType.textContent = "other";
      }
    }
    propertiesButton.addEventListener("click", () => {
      if (selectedCell) {
        showPropertiesMenu(selectedCell, currentMouseEvent);
      }
    });

    makeEditableField(propNodeText, onNodeTextFieldChange);
    makeEditableField(propNodeId, onNodeIdFieldChange);
    makeEditableField(propNodeSection, onNodeSectionFieldChange);

    function makeEditableField(spanEl, onChangeCb) {
      spanEl.addEventListener("dblclick", e => {
        e.stopPropagation();
        e.preventDefault();
        spanEl.contentEditable = "true";
        spanEl.focus();
      });
      spanEl.addEventListener("blur", () => {
        spanEl.contentEditable = "false";
        onChangeCb(spanEl.textContent);
      });
      spanEl.addEventListener("keydown", evt => {
        if (evt.key === "Enter") {
          evt.preventDefault();
          spanEl.blur();
        }
      });
    }
    function onNodeTextFieldChange(newText) {
      if (!selectedCell) return;
      graph.getModel().beginUpdate();
      try {
        selectedCell.value = newText.trim();
        if (isQuestion(selectedCell)) {
          refreshNodeIdFromLabel(selectedCell);
        } else if (isOptions(selectedCell)) {
          refreshOptionNodeId(selectedCell);
        }
      } finally {
        graph.getModel().endUpdate();
      }
      refreshAllCells();
    }
    function onNodeIdFieldChange(newId) {
      if (!selectedCell) return;
      graph.getModel().beginUpdate();
      try {
        setNodeId(selectedCell, newId);
      } finally {
        graph.getModel().endUpdate();
      }
      refreshAllCells();
    }
    function onNodeSectionFieldChange(newSec) {
      if (!selectedCell) return;
      const num = parseInt(newSec.trim(), 10);
      if (isNaN(num)) return;
      graph.getModel().beginUpdate();
      try {
        setSection(selectedCell, num);
      } finally {
        graph.getModel().endUpdate();
      }
      refreshAllCells();
    }

    // Key combos
    const keyHandler = new mxKeyHandler(graph);
    keyHandler.bindControlKey(67, () => {
      mxClipboard.copy(graph);
    });
    keyHandler.bindControlKey(86, () => {
      const pasted = mxClipboard.paste(graph);
      if (pasted && pasted.length > 0) {
        graph.moveCells(pasted, 40, 40);
        refreshAllCells();
      }
    });

    // If user types '?' => question
    graph.getModel().addListener(mxEvent.EVENT_CHANGE, function(sender, evt) {
      const changes = evt.getProperty("changes");
      if (!changes) return;
      changes.forEach(change => {
        if (change.constructor.name === "mxValueChange") {
          const { cell, value } = change;
          if (value && typeof value === "string") {
            if (value.trim().endsWith("?")) {
              if (!isQuestion(cell)) {
                let style = cell.style || "";
                style += ";nodeType=question;";
                graph.getModel().setStyle(cell, style);
                refreshNodeIdFromLabel(cell);
              }
            }
          }
        }
      });
      refreshAllCells();
    });

    // On connect => if source is not jumpModeNode => child inherits parent's section
    graph.connectionHandler.addListener(mxEvent.CONNECT, function(sender, evt) {
      const edge = evt.getProperty("cell");
      if (!edge) return;
      const parent = edge.source;
      const child = edge.target;
      const parentIsJump = (parent && parent === jumpModeNode);

      // Inherit if not jump
      if (!parentIsJump && parent && child) {
        const parentSec = parseInt(getSection(parent) || "1", 10);
        setSection(child, parentSec);
      }

      let parentQuestion = null;
      if (parent && isOptions(parent)) {
        parentQuestion = parent.source;
      } else if (parent && isQuestion(parent)) {
        parentQuestion = parent;
      }
      const gpIsJump = (parentQuestion && parentQuestion === jumpModeNode);

      if (parentIsJump || gpIsJump) {
        addSkipReassign(child);
      }
      refreshAllCells();
    });

    // Reset colors
    resetBtn.addEventListener("click", () => {
      colorPreferences = { ...defaultColors };
      updateLegendColors();
      refreshAllCells();
      saveUserColorPrefs();
    });

    // Setup legend color click => open color pickers
    document.getElementById("colorText").addEventListener("click", () => {
      document.getElementById("colorPickerText").click();
    });
    document.getElementById("colorCheckbox").addEventListener("click", () => {
      document.getElementById("colorPickerCheckbox").click();
    });
    document.getElementById("colorDropdown").addEventListener("click", () => {
      document.getElementById("colorPickerDropdown").click();
    });
    document.getElementById("colorMoney").addEventListener("click", () => {
      document.getElementById("colorPickerMoney").click();
    });
    document.getElementById("colorDate").addEventListener("click", () => {
      document.getElementById("colorPickerDate").click();
    });
    document.getElementById("colorBigParagraph").addEventListener("click", () => {
      document.getElementById("colorPickerBigParagraph").click();
    });
    document.getElementById("colorTextColor").addEventListener("click", () => {
      document.getElementById("colorPickerTextColor").click();
    });

    // Hook color picker events
    document.getElementById("colorPickerText").addEventListener("input", e => {
      colorPreferences.text = e.target.value;
      updateLegendColors();
      refreshAllCells();
      saveUserColorPrefs();
    });
    document.getElementById("colorPickerCheckbox").addEventListener("input", e => {
      colorPreferences.checkbox = e.target.value;
      updateLegendColors();
      refreshAllCells();
      saveUserColorPrefs();
    });
    document.getElementById("colorPickerDropdown").addEventListener("input", e => {
      colorPreferences.dropdown = e.target.value;
      updateLegendColors();
      refreshAllCells();
      saveUserColorPrefs();
    });
    document.getElementById("colorPickerMoney").addEventListener("input", e => {
      colorPreferences.money = e.target.value;
      updateLegendColors();
      refreshAllCells();
      saveUserColorPrefs();
    });
    document.getElementById("colorPickerDate").addEventListener("input", e => {
      colorPreferences.date = e.target.value;
      updateLegendColors();
      refreshAllCells();
      saveUserColorPrefs();
    });
    document.getElementById("colorPickerBigParagraph").addEventListener("input", e => {
      colorPreferences.bigParagraph = e.target.value;
      updateLegendColors();
      refreshAllCells();
      saveUserColorPrefs();
    });
    document.getElementById("colorPickerTextColor").addEventListener("input", e => {
      colorPreferences.textColor = e.target.value;
      updateLegendColors();
      refreshAllCells();
      saveUserColorPrefs();
    });

    updateLegendColors();
  });
</script>

<script>
  /*******************************************************
   ************  HELPER / STYLING / JSON Exports  ********
   *******************************************************/
  function updateLegendColors() {
    document.getElementById("colorText").style.backgroundColor = colorPreferences.text;
    document.getElementById("colorCheckbox").style.backgroundColor = colorPreferences.checkbox;
    document.getElementById("colorDropdown").style.backgroundColor = colorPreferences.dropdown;
    document.getElementById("colorMoney").style.backgroundColor = colorPreferences.money;
    document.getElementById("colorDate").style.backgroundColor = colorPreferences.date;
    document.getElementById("colorBigParagraph").style.backgroundColor = colorPreferences.bigParagraph;
    document.getElementById("colorTextColor").style.backgroundColor = colorPreferences.textColor;
  }

  function autoUpdateNodeIdBasedOnLabel(cell) {
    if (!cell.vertex) return;
    const label = (cell.value || "").trim();
    if (!label) return;
    if (isQuestion(cell)) {
      refreshNodeIdFromLabel(cell);
    } else if (isOptions(cell)) {
      refreshOptionNodeId(cell);
    }
  }
  function isQuestion(cell) {
    return cell && cell.style && cell.style.includes("nodeType=question");
  }
  function isOptions(cell) {
    return cell && cell.style && cell.style.includes("nodeType=options");
  }

  function setNodeId(cell, nodeId) {
    let style = cell.style || "";
    style = style.replace(/nodeId=[^;]+/, "");
    style += `;nodeId=${encodeURIComponent(nodeId)};`;
    graph.getModel().setStyle(cell, style);
  }
  function getNodeId(cell) {
    const style = cell.style || "";
    const m = style.match(/nodeId=([^;]+)/);
    return m ? decodeURIComponent(m[1]) : "";
  }

  function setSection(cell, sectionNum) {
    let style = cell.style || "";
    // remove old section=... if present
    style = style.replace(/section=[^;]+/, "");
    style += `;section=${sectionNum};`;
    graph.getModel().setStyle(cell, style);
  }
  function getSection(cell) {
    const style = cell.style || "";
    const match = style.match(/section=([^;]+)/);
    return match ? match[1] : null;
  }

  function refreshNodeIdFromLabel(cell) {
    const label = (cell.value || "").toString().trim();
    const nodeId = label.replace(/\s+/g, "_");
    setNodeId(cell, nodeId);
  }
  function refreshOptionNodeId(cell) {
    const edges = graph.getIncomingEdges(cell) || [];
    let parentNodeId = "ParentQuestion";
    for (let e of edges) {
      const p = e.source;
      if (isQuestion(p)) {
        parentNodeId = getNodeId(p) || "ParentQuestion";
        break;
      }
    }
    let label = (cell.value || "Option").toString().trim().replace(/\s+/g, "_");
    setNodeId(cell, parentNodeId + label);
  }

  function addSkipReassign(cell) {
    if (!cell) return;
    let style = cell.style || "";
    style = style.replace(/skipReassign=[^;]+/, "");
    style += ";skipReassign=true;";
    graph.getModel().setStyle(cell, style);
  }
  function removeJumpStyling(cell) {
    if (!cell) return;
    let style = cell.style || "";
    style = style.replace(/strokeWidth=\d+;?/, "");
    style = style.replace(/strokeColor=[^;]+;?/, "");
    style = style.replace(/dashed=\d;?/, "");
    style = style.replace(/dashPattern=[^;]+;?/, "");
    graph.getModel().setStyle(cell, style);
  }
  function addJumpStyling(cell) {
    if (!cell) return;
    let style = cell.style || "";
    style = style.replace(/strokeWidth=\d+;?/, "");
    style = style.replace(/strokeColor=[^;]+;?/, "");
    style = style.replace(/dashed=\d;?/, "");
    style = style.replace(/dashPattern=[^;]+;?/, "");
    style += jumpBorderStyle;
    graph.getModel().setStyle(cell, style);
  }

  function getQuestionType(cell) {
    const style = cell.style || "";
    const m = style.match(/questionType=([^;]+)/);
    return m ? m[1] : "dropdown";
  }
  function setQuestionType(cell, newType) {
    let style = cell.style || "";
    style = style.replace(/questionType=[^;]+/, "");
    style += `;questionType=${newType};`;
    graph.getModel().setStyle(cell, style);
  }

  function colorCell(cell) {
    if (!cell.vertex) return;
    let fillColor = "#ADD8E6"; // fallback
    if (isQuestion(cell)) {
      const qType = getQuestionType(cell);
      fillColor = getColorForQuestionType(qType);
    } else if (isOptions(cell)) {
      fillColor = "#ffffff";
    }
    // Also apply fontColor from textColor
    const fontColor = colorPreferences.textColor;

    let style = cell.style || "";
    style = style.replace(/fillColor=[^;]+/, "");
    style = style.replace(/fontColor=[^;]+/, "");
    style += `;fillColor=${fillColor};fontColor=${fontColor};`;
    graph.getModel().setStyle(cell, style);
  }

  function getColorForQuestionType(qType) {
    switch (qType) {
      case "text":         return colorPreferences.text;
      case "checkbox":     return colorPreferences.checkbox;
      case "dropdown":     return colorPreferences.dropdown;
      case "money":        return colorPreferences.money;
      case "date":         return colorPreferences.date;
      case "bigParagraph": return colorPreferences.bigParagraph;
      default:             return "#ADD8E6";
    }
  }

  function refreshAllCells() {
    const parent = graph.getDefaultParent();
    const vertices = graph.getChildVertices(parent);
    vertices.forEach(cell => {
      colorCell(cell);
      if (isQuestion(cell) && (cell.value === "question node" || cell.value === "Question Node")) {
        const cellId = cell.id;
        cell.value =
          `<select oninput="window.pickTypeForCell('${cellId}', this.value)">
            <option value="">-- Choose Type --</option>
            <option value="text">Text</option>
            <option value="checkbox">Checkbox</option>
            <option value="dropdown">Dropdown</option>
            <option value="money">Money</option>
            <option value="date">Date</option>
            <option value="bigParagraph">Big Paragraph</option>
          </select>`;
      }
    });
  }

  window.pickTypeForCell = function(cellId, val) {
    const c = graph.getModel().getCell(cellId);
    if (!c) return;
    graph.getModel().beginUpdate();
    try {
      setQuestionType(c, val);
      c.value = val.charAt(0).toUpperCase() + val.slice(1) + " question node";
    } finally {
      graph.getModel().endUpdate();
    }
    refreshAllCells();
  };

  function downloadJson(str, filename) {
    const blob = new Blob([str], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  window.exportFlowchartJson = function () {
    const data = [];
    const cells = graph.getModel().cells;
    for (let id in cells) {
      if (id === "0" || id === "1") continue;
      const cell = cells[id];
      data.push({
        id: cell.id,
        value: cell.value,
        geometry: cell.geometry
          ? {
              x: cell.geometry.x,
              y: cell.geometry.y,
              width: cell.geometry.width,
              height: cell.geometry.height
            }
          : null,
        style: cell.style || "",
        vertex: !!cell.vertex,
        edge: !!cell.edge,
        source: cell.edge ? cell.source?.id : null,
        target: cell.edge ? cell.target?.id : null
      });
    }
    downloadJson(JSON.stringify(data, null, 2), "flowchart_data.json");
  };

  window.importFlowchartJson = function (evt) {
    const file = evt.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
      const jsonData = JSON.parse(e.target.result);
      loadFlowchartData(jsonData);
      // no name => new flowchart
      currentFlowchartName = null;
    };
    reader.readAsText(file);
  };

  // ---- EXPORT GUI JSON (WITH SECTIONS) ----
  window.exportGuiJson = function () {
    const allCells = graph.getModel().cells;
    const sectionMap = {}; // { [sectionNumber]: { sectionId, sectionName, questions: [] } }
    let questionIdCounter = 1;

    // 1) Gather question nodes; store by section
    for (let id in allCells) {
      if (id === "0" || id === "1") continue;
      const cell = allCells[id];
      if (!cell.vertex) continue;
      if (!isQuestion(cell)) continue;

      // read label, type, section
      const rawLabel = (cell.value || "").replace(/<[^>]+>/g, "").trim() || "Untitled";
      const qType = getQuestionType(cell);
      const sec = parseInt(getSection(cell) || "1", 10);

      // ensure there's a section entry in the map
      if (!sectionMap[sec]) {
        sectionMap[sec] = {
          sectionId: sec,
          sectionName: "Section " + sec,
          questions: []
        };
      }

      const questionObj = {
        questionId: questionIdCounter,
        text: rawLabel,
        type: qType,
        logic: {
          enabled: false,
          conditions: []
        },
        jump: {
          enabled: false,
          option: "",
          to: ""
        },
        conditionalPDF: {
          enabled: false,
          pdfName: "",
          answer: "Yes"
        },
        conditionalAlert: {
          enabled: false,
          prevQuestion: "",
          prevAnswer: "",
          text: ""
        },
        options: [],
        labels: [],
        // nameId is just the raw label
        nameId: rawLabel,
        placeholder: ""
      };

      questionIdCounter++;
      cell._questionId = questionObj.questionId;

      // push into that section
      sectionMap[sec].questions.push(questionObj);
    }

    // 2) For each question => check for option children => fill "options" + logic/jump
    for (let id in allCells) {
      if (id === "0" || id === "1") continue;
      const cell = allCells[id];
      if (!cell.vertex) continue;
      if (!isQuestion(cell)) continue;

      const myQId = cell._questionId;
      if (!myQId) continue;

      // find the question object in the map
      let qObjRef = null;
      for (let sKey in sectionMap) {
        const secObj = sectionMap[sKey];
        const foundQ = secObj.questions.find(q => q.questionId === myQId);
        if (foundQ) {
          qObjRef = foundQ;
          break;
        }
      }
      if (!qObjRef) continue;

      const outEdges = graph.getOutgoingEdges(cell) || [];
      outEdges.forEach(edge => {
        const target = edge.target;
        if (!target) return;
        if (!isOptions(target)) return;

        // Option node label
        const optLabel = (target.value || "Option").replace(/<[^>]+>/g, "").trim();
        if (qObjRef.type === "checkbox") {
          qObjRef.options.push({
            label: optLabel,
            nameId: "option_" + optLabel.replace(/\s+/g,"_"),
            value: ""
          });
        } else {
          qObjRef.options.push(optLabel);
        }

        // Possibly leads to another question => logic or jump
        const nextEdges = graph.getOutgoingEdges(target) || [];
        nextEdges.forEach(ne => {
          const q2 = ne.target;
          if (!q2 || !isQuestion(q2)) return;
          const q2Id = q2._questionId;
          if (!q2Id) return; // no question assigned

          if (q2Id < myQId) {
            // jump
            qObjRef.jump.enabled = true;
            qObjRef.jump.option = optLabel;
            qObjRef.jump.to = q2Id.toString();
          } else {
            // logic
            // means q2 is shown if we pick this option
            // so q2 has a condition referencing my question
            let q2Ref = null;
            for (let sKey2 in sectionMap) {
              const secObj2 = sectionMap[sKey2];
              const foundQ2 = secObj2.questions.find(q => q.questionId === q2Id);
              if (foundQ2) {
                q2Ref = foundQ2;
                break;
              }
            }
            if (q2Ref) {
              q2Ref.logic.enabled = true;
              q2Ref.logic.conditions.push({
                prevQuestion: myQId.toString(),
                prevAnswer: optLabel
              });
            }
          }
        });
      });
    }

    // 3) Convert sectionMap to an array sorted by sectionId
    const sortedSectionNumbers = Object.keys(sectionMap)
      .map(x => parseInt(x, 10))
      .sort((a, b) => a - b);

    const sectionsArr = sortedSectionNumbers.map(secNum => sectionMap[secNum]);

    // 4) The sectionCounter is largest section + 1
    const sectionCounter = sortedSectionNumbers.length > 0
      ? Math.max(...sortedSectionNumbers) + 1
      : 2;

    const finalJson = {
      sections: sectionsArr,
      hiddenFields: [],
      sectionCounter: sectionCounter,
      questionCounter: questionIdCounter,
      hiddenFieldCounter: 1,
      defaultPDFName: ""
    };

    downloadJson(JSON.stringify(finalJson, null, 2), "gui_data.json");
  };
</script>

<script>
  /***********************************************
   *           SAVE & VIEW FLOWCHARTS           *
   ***********************************************/
  function saveFlowchart() {
    if (!currentUser) {
      alert("Please log in first.");
      return;
    }

    let flowchartName = currentFlowchartName;

    if (!flowchartName) {
      // If no existing name => ask
      flowchartName = prompt("Enter a name for this flowchart:");
      if (!flowchartName || !flowchartName.trim()) return;
      currentFlowchartName = flowchartName;
    }

    // Gather raw flowchart data
    const data = [];
    const cells = graph.getModel().cells;
    for (let id in cells) {
      if (id === "0" || id === "1") continue;
      const cell = cells[id];
      data.push({
        id: cell.id,
        value: cell.value,
        geometry: cell.geometry
          ? {
              x: cell.geometry.x,
              y: cell.geometry.y,
              width: cell.geometry.width,
              height: cell.geometry.height
            }
          : null,
        style: cell.style || "",
        vertex: !!cell.vertex,
        edge: !!cell.edge,
        source: cell.edge ? cell.source?.id : null,
        target: cell.edge ? cell.target?.id : null
      });
    }

    db.collection("users")
      .doc(currentUser.uid)
      .collection("flowcharts")
      .doc(flowchartName)
      .set({ flowchart: data })
      .then(() => {
        alert("Flowchart saved as: " + flowchartName);
      })
      .catch(err => {
        console.error("Error saving flowchart:", err);
        alert("Error saving flowchart: " + err);
      });
  }

  function viewSavedFlowcharts() {
    if (!currentUser) {
      alert("Please log in first.");
      return;
    }
    db.collection("users")
      .doc(currentUser.uid)
      .collection("flowcharts")
      .get()
      .then(snapshot => {
        let html = "";
        if (snapshot.empty) {
          html = "<p>You currently have no saved flowcharts.</p>";
        } else {
          snapshot.forEach(doc => {
            const name = doc.id; // doc id is the flowchart name
            html += `
              <div class="flowchart-item">
                <strong>${name}</strong>
                <button onclick="openSavedFlowchart('${name}')">Open</button>
                <button onclick="deleteSavedFlowchart('${name}')">Delete</button>
              </div>
            `;
          });
        }
        flowchartListDiv.innerHTML = html;
        showFlowchartListOverlay();
      })
      .catch(err => {
        console.error("Error fetching flowcharts:", err);
        alert("Error fetching flowcharts: " + err);
      });
  }
  function showFlowchartListOverlay() {
    document.getElementById("flowchartListOverlay").style.display = "flex";
  }
  function hideFlowchartListOverlay() {
    document.getElementById("flowchartListOverlay").style.display = "none";
  }
  document.getElementById("closeFlowchartListBtn").addEventListener("click", hideFlowchartListOverlay);

  // Open existing flowchart => set name => user can overwrite
  window.openSavedFlowchart = function(name) {
    if (!currentUser) return;
    db.collection("users")
      .doc(currentUser.uid)
      .collection("flowcharts")
      .doc(name)
      .get()
      .then(docSnap => {
        if (!docSnap.exists) {
          alert("No flowchart named " + name);
          return;
        }
        const data = docSnap.data();
        if (!data.flowchart) {
          alert("No flowchart data found for " + name);
          return;
        }
        loadFlowchartData(data.flowchart);
        currentFlowchartName = name;
        hideFlowchartListOverlay();
      })
      .catch(err => {
        console.error("Error loading flowchart:", err);
        alert("Error loading flowchart: " + err);
      });
  };

  // Delete saved flowchart
  window.deleteSavedFlowchart = function(name) {
    if (!currentUser) return;
    const confirmDel = confirm("Are you sure you want to delete '" + name + "'?");
    if (!confirmDel) return;

    db.collection("users")
      .doc(currentUser.uid)
      .collection("flowcharts")
      .doc(name)
      .delete()
      .then(() => {
        alert("Deleted flowchart: " + name);
        if (currentFlowchartName === name) {
          currentFlowchartName = null;
        }
        viewSavedFlowcharts();
      })
      .catch(err => {
        console.error("Error deleting flowchart:", err);
        alert("Error deleting flowchart: " + err);
      });
  };
</script>

</body>
</html>
