<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Flowchart Creator</title>
  <!-- mxGraph library from jsDelivr -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mxgraph@4.2.2/javascript/mxClient.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
      user-select: none;
    }

    .toolbar {
      width: 220px;
      background: #f9f9f9;
      border-right: 1px solid #ccc;
      box-sizing: border-box;
      float: left;
      padding: 10px;
    }

    #graphContainer {
      position: absolute;
      left: 220px;
      right: 0;
      top: 0;
      bottom: 0;
      overflow: hidden;
      cursor: default;
    }

    .shape {
      background: #fff;
      border: 1px solid #999;
      margin-bottom: 8px;
      text-align: center;
      padding: 6px;
      border-radius: 4px;
      cursor: move;
    }
    .shape:hover {
      background: #e0e0e0;
    }
    .button-bar {
      margin-top: 15px;
    }
    button {
      margin-bottom: 6px;
      padding: 6px 10px;
      background-color: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: block;
      width: 100%;
      box-sizing: border-box;
    }
    button:hover {
      background-color: #0056b3;
    }
    input[type="file"] {
      display: none; /* hidden by default; we trigger it via button click */
    }
  </style>
</head>
<body>
  <!-- Toolbar Area -->
  <div class="toolbar">
    <h3>Shapes</h3>
    <!-- Question Node (rectangle) -->
    <div
      class="shape"
      data-type="question"
      data-style="shape=rectangle;whiteSpace=wrap;html=1;"
    >
      Question Node
    </div>
    <!-- Options Node (ellipse) -->
    <div
      class="shape"
      data-type="options"
      data-style="ellipse;whiteSpace=wrap;html=1;"
    >
      Options Node
    </div>

    <!-- Buttons to export and import the flowchart JSON -->
    <div class="button-bar">
      <button onclick="exportFlowchartJson()">Export Flowchart JSON</button>
      <button onclick="document.getElementById('importFlowchartFile').click()">Import Flowchart</button>
      <input
        type="file"
        id="importFlowchartFile"
        accept=".json"
        onchange="importFlowchartJson(event)"
      />

      <!-- Export to GUI JSON (for your Custom Form Builder) -->
      <button onclick="exportGuiJson()">Export GUI JSON</button>
    </div>
  </div>

  <!-- Graph Container -->
  <div id="graphContainer"></div>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      if (typeof mxGraph === "undefined") {
        alert("mxGraph library not found!");
        return;
      }

      const container = document.getElementById("graphContainer");
      // Disable context menu
      mxEvent.disableContextMenu(container);

      // Create graph
      const graph = new mxGraph(container);
      // Basic setup
      graph.setCellsMovable(true);
      graph.setConnectable(true);
      graph.setCellsResizable(true);

      // Rubberband selection
      new mxRubberband(graph);

      // Prevent deleting text while editing a label
      document.addEventListener("keydown", function (evt) {
        // Only allow Delete/Backspace if NOT editing label text
        if (
          (evt.key === "Delete" || evt.key === "Backspace") &&
          !graph.cellEditor.isEditing()
        ) {
          const selectedCells = graph.getSelectionCells();
          if (selectedCells && selectedCells.length) {
            graph.removeCells(selectedCells);
            evt.preventDefault();
          }
        }
      });

      // Draggable shapes from toolbar
      const toolbarShapes = document.querySelectorAll(".shape");
      toolbarShapes.forEach((shapeEl) => {
        const nodeType = shapeEl.dataset.type;
        const styleStr = shapeEl.dataset.style;

        mxUtils.makeDraggable(
          shapeEl,
          graph,
          function (graph, evt, targetCell, x, y) {
            const model = graph.getModel();
            let newVertex;
            model.beginUpdate();
            try {
              newVertex = graph.insertVertex(
                graph.getDefaultParent(),
                null,
                nodeType + " node", // default label
                x,
                y,
                100,
                60,
                styleStr + `;nodeType=${nodeType};`
              );
            } finally {
              model.endUpdate();
            }
            return newVertex;
          }
        );
      });

      /**
       * Export Flowchart JSON
       */
      window.exportFlowchartJson = function () {
        const data = [];
        const cells = graph.getModel().cells;
        for (let id in cells) {
          if (id === "0" || id === "1") continue; // skip root/layer
          const cell = cells[id];
          const cellData = {
            id: cell.id,
            value: cell.value,
            geometry: cell.geometry
              ? {
                  x: cell.geometry.x,
                  y: cell.geometry.y,
                  width: cell.geometry.width,
                  height: cell.geometry.height
                }
              : null,
            style: cell.style || "",
            vertex: !!cell.vertex,
            edge: !!cell.edge,
            source: cell.edge ? cell.source?.id : null,
            target: cell.edge ? cell.target?.id : null
          };
          data.push(cellData);
        }
        downloadJson(JSON.stringify(data, null, 2), "flowchart_data.json");
      };

      /**
       * Import Flowchart JSON
       * Rebuilds the graph from a previously exported JSON
       */
      window.importFlowchartJson = function (evt) {
        const file = evt.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          const jsonData = JSON.parse(e.target.result);
          loadFlowchartData(jsonData);
        };
        reader.readAsText(file);
      };

      function loadFlowchartData(data) {
        // Clear existing graph
        graph.getModel().beginUpdate();
        try {
          graph.removeCells(graph.getChildVertices(graph.getDefaultParent()), true);

          // We'll store references to newly created cells by their old IDs
          const createdCells = {};

          // First pass: create vertices
          data.forEach((item) => {
            if (item.vertex) {
              const parent = graph.getDefaultParent();
              const geo = new mxGeometry(item.geometry.x, item.geometry.y, item.geometry.width, item.geometry.height);
              const newCell = new mxCell(item.value, geo, item.style);
              newCell.vertex = true;
              // Insert cell
              newCell.id = item.id; // reuse the old ID
              graph.addCell(newCell, parent);
              createdCells[item.id] = newCell;
            }
          });

          // Second pass: create edges
          data.forEach((item) => {
            if (item.edge) {
              const parent = graph.getDefaultParent();
              const newEdge = new mxCell(item.value, new mxGeometry(), item.style);
              newEdge.edge = true;
              newEdge.id = item.id; // reuse old ID
              const sourceCell = createdCells[item.source];
              const targetCell = createdCells[item.target];
              graph.addCell(newEdge, parent, undefined, sourceCell, targetCell);
            }
          });

        } finally {
          graph.getModel().endUpdate();
        }
      }

      /**
       * Export GUI JSON
       * Single section -> each "question node" is a dropdown question
       * "options node" shapes connected to that question become the question's dropdown options
       * Conditional logic: If an "options node" leads to another question, we enable logic.
       */
      window.exportGuiJson = function () {
        const model = graph.getModel();
        const allCells = model.cells;

        // We'll track question nodes in an array
        // questionData = { questionId, text, options: [], logic: {enabled, prevQuestion, prevAnswer} }
        let questionIdCounter = 1;
        const questionMap = {}; // oldCellId -> question object
        const questionCells = []; // store the actual question cell references

        // A function to get nodeType from cell.style
        function getNodeType(cell) {
          if (cell.style && cell.style.indexOf("nodeType=question") >= 0) return "question";
          if (cell.style && cell.style.indexOf("nodeType=options") >= 0) return "options";
          return null;
        }

        // 1) Identify all question nodes & assign them incremental question IDs
        for (let id in allCells) {
          if (id === "0" || id === "1") continue;
          const cell = allCells[id];
          if (cell.vertex && getNodeType(cell) === "question") {
            // Use label minus "question node" if user hasn't changed it
            const label = cell.value.toString().replace(/question node/i, "").trim() || "Untitled";
            const qObj = {
              questionId: questionIdCounter,
              text: label,
              type: "dropdown",
              logic: { enabled: false, prevQuestion: "", prevAnswer: "" },
              jump: { enabled: false, option: "", to: "" },
              conditionalPDF: { enabled: false, pdfName: "", answer: "" },
              options: [],
              labels: []
            };
            questionMap[id] = qObj;
            questionCells.push(cell);
            questionIdCounter++;
          }
        }

        // 2) For each question node, gather "options nodes" from outgoing edges
        questionCells.forEach((qCell) => {
          const qObj = questionMap[qCell.id];
          // Outgoing edges to "options" nodes
          const outEdges = graph.getOutgoingEdges(qCell);
          if (!outEdges) return;

          outEdges.forEach((edge) => {
            const target = edge.target;
            if (!target) return;
            const targetType = getNodeType(target);
            if (targetType === "options") {
              // If it's an options node, add the label to the question's options
              const optLabel = target.value.toString().replace(/options node/i, "").trim() || "Option";
              qObj.options.push(optLabel);

              // Also check if that options node leads to a *question node*
              const nextEdges = graph.getOutgoingEdges(target);
              if (nextEdges) {
                // If there's a question node on the other side, that question node is conditional
                nextEdges.forEach((nEdge) => {
                  const q2 = nEdge.target;
                  if (q2 && getNodeType(q2) === "question") {
                    // We want to enable logic on q2:
                    // Show q2 if the user picks 'optLabel' on qObj's questionId
                    const q2Obj = questionMap[q2.id];
                    if (q2Obj) {
                      q2Obj.logic.enabled = true;
                      q2Obj.logic.prevQuestion = qObj.questionId.toString();
                      q2Obj.logic.prevAnswer = optLabel;
                    }
                  }
                });
              }
            }
          });
        });

        // 3) Build the final single-section structure
        const section = {
          sectionId: 1,
          sectionName: "Flowchart Section",
          questions: Object.values(questionMap) // all question objects
        };

        const guiData = {
          sections: [section],
          hiddenFields: [],
          sectionCounter: 2,
          questionCounter: questionIdCounter,
          hiddenFieldCounter: 1,
          defaultPDFName: ""
        };

        const jsonStr = JSON.stringify(guiData, null, 2);
        downloadJson(jsonStr, "gui_data.json");
      };

      /**
       * Utility to download JSON as a file
       */
      function downloadJson(jsonString, filename) {
        const blob = new Blob([jsonString], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }
    });
  </script>
</body>
</html>
