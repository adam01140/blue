<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Flowchart Creator (Fixed)</title>
  <!-- mxGraph -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mxgraph@4.2.2/javascript/mxClient.min.js"></script>
  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

  <!--
  ************************************************************************************************************
  ************************************************************************************************************
  ***                                                                                                      ***
  ***      S E C T I O N 1:   G E N E R A L   S T Y L E   &   L A Y O U T                                  ***
  ***                                                                                                      ***
  ************************************************************************************************************
  ************************************************************************************************************
  -->
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
      user-select: none;
    }
    .toolbar {
      width: 220px;
      background: #f9f9f9;
      border-right: 1px solid #ccc;
      float: left;
      padding: 10px;
      box-sizing: border-box;
    }
    #graphContainer {
      position: absolute;
      left: 220px;
      right: 0;
      top: 0;
      bottom: 0;
      cursor: default;
    }
    .shape {
      background: #fff;
      border: 1px solid #999;
      margin-bottom: 8px;
      text-align: center;
      padding: 6px;
      border-radius: 4px;
      cursor: move;
    }
    .shape:hover {
      background: #e0e0e0;
    }
    .button-bar {
      margin-top: 15px;
    }
    button {
      margin-bottom: 6px;
      padding: 6px 10px;
      background-color: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: block;
      width: 100%;
      box-sizing: border-box;
    }
    button:hover {
      background-color: #0056b3;
    }
    input[type="file"] {
      display: none;
    }
    .context-menu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
      display: none;
      z-index: 1000;
      padding: 5px;
    }
    .context-menu button {
      border: none;
      background: none;
      color: #000;
      padding: 5px 10px;
      text-align: left;
      width: 100%;
      cursor: pointer;
    }
    .context-menu button:hover {
      background-color: #f0f0f0;
    }
    .submenu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      padding: 5px;
      display: none;
      z-index: 2000;
    }
    .submenu button {
      display: block;
      margin-bottom: 4px;
      border: none;
      background: none;
      color: #000;
      padding: 5px 10px;
      text-align: left;
      width: 100%;
      cursor: pointer;
    }
    .submenu button:hover {
      background-color: #f0f0f0;
    }

    /* Properties menu */
    #propertiesMenu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 4px;
      display: none;
      z-index: 3000;
      width: 220px;
    }
    #propertiesMenu p {
      margin: 4px 0;
    }
    .editable-field {
      border: 1px dashed transparent;
      padding: 2px;
      display: inline-block;
      min-width: 50px;
      cursor: text;
    }
    .editable-field:focus {
      outline: 1px dashed #888;
    }

    /* Legend area for colors */
    .legend {
      margin-top: 10px;
      padding: 6px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .legend .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
    }
    .legend-color-box {
      width: 20px;
      height: 20px;
      margin-right: 8px;
      cursor: pointer;
      border: 1px solid #ccc;
      border-radius: 3px;
    }

    /* Basic login form overlay */
    #loginOverlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0,0,0,0.5);
      display: none;
      z-index: 9999;
      align-items: center;
      justify-content: center;
    }
    #loginForm {
      background: #fff;
      padding: 20px;
      border-radius: 6px;
      min-width: 300px;
    }
    #loginForm input[type="email"],
    #loginForm input[type="password"] {
      width: 100%;
      margin-bottom: 10px;
      padding: 8px;
      box-sizing: border-box;
    }
    #loginError {
      color: red;
      margin-bottom: 8px;
    }

    /* Node label backgrounds */
    .mxGraph .mxCellEditor,
    .mxGraph .mxCellOverlay {
      background: transparent !important;
    }

    /*
    ************************************************************************************************************
    ************************************************************************************************************
    ***                                                                                                      ***
    ***      S E C T I O N 2:   C U S T O M   C E L L   E D I T O R   S T Y L I N G                          ***
    ***                                                                                                      ***
    ************************************************************************************************************
    ************************************************************************************************************
    */
    .mxCellEditor {
      background: #ffffff !important;
      border-radius: 12px !important;
      overflow: visible !important;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15) !important;
      min-width: 120px !important;
      min-height: 10px !important;
      box-sizing: border-box !important;
    }
 
  </style>
</head>
<body>

<!--
###########################################################################################################
###########################################################################################################
###                                                                                                     ###
###     S E C T I O N 3:  L O G I N   O V E R L A Y   &   T O O L B A R                                  ###
###                                                                                                     ###
###########################################################################################################
###########################################################################################################
-->
<div id="loginOverlay">
  <div id="loginForm">
    <h3>Login</h3>
    <div id="loginError"></div>
    <input type="email" id="loginEmail" placeholder="Email" /><br/>
    <input type="password" id="loginPassword" placeholder="Password" /><br/>
    <button id="loginButton">Login</button>
    <button id="signupButton">Sign Up</button>
  </div>
</div>

<div class="toolbar">
  <h3>Shapes</h3>
  <div
    class="shape"
    data-type="question"
    data-style="rounded=1;whiteSpace=wrap;html=1;nodeType=question;questionType=dropdown;sectionId=1;nodeId=Question_node;"
  >
    Question Node
  </div>
  <div
    class="shape"
    data-type="options"
    data-style="rounded=1;whiteSpace=wrap;html=1;nodeType=options;questionType=dropdown;sectionId=1;nodeId=Option_node;"
  >
    Options Node
  </div>

  <div class="button-bar">
    <button onclick="exportFlowchartJson()">Export Flowchart JSON</button>
    <button onclick="document.getElementById('importFlowchartFile').click()">Import Flowchart</button>
    <input
      type="file"
      id="importFlowchartFile"
      accept=".json"
      onchange="importFlowchartJson(event)"
    />
    <button onclick="exportGuiJson()">Export GUI JSON</button>
  </div>

  <div class="legend">
    <strong>Legend (Click color to change)</strong>
    <div class="legend-item">
      <div class="legend-color-box" id="colorText"></div>
      <span>Text</span>
    </div>
    <div class="legend-item">
      <div class="legend-color-box" id="colorCheckbox"></div>
      <span>Checkbox</span>
    </div>
    <div class="legend-item">
      <div class="legend-color-box" id="colorDropdown"></div>
      <span>Dropdown</span>
    </div>
    <div class="legend-item">
      <div class="legend-color-box" id="colorMoney"></div>
      <span>Money</span>
    </div>
  </div>
</div>

<div id="graphContainer"></div>

<div id="contextMenu" class="context-menu">
  <button id="deleteNode">Delete Node</button>
  <button id="jumpNode">Jump</button>
  <button id="changeType">Change Type &raquo;</button>
  <button id="newSectionButton">New Section</button>
  <button id="propertiesButton">Properties</button>
  <button id="yesNoNode">Yes/No</button>
</div>

<div id="typeSubmenu" class="submenu">
  <button id="dropdownType">Drop Down</button>
  <button id="checkboxType">Checkbox</button>
  <button id="textType">Text</button>
  <button id="moneyType">Money</button>
</div>

<div id="propertiesMenu">
  <p><strong>Node Text:</strong>
    <span id="propNodeText" class="editable-field" tabindex="0"></span>
  </p>
  <p><strong>Node ID:</strong>
    <span id="propNodeId" class="editable-field" tabindex="0"></span>
  </p>
  <p><strong>Node Type:</strong> <span id="propNodeType"></span></p>
  <p><strong>Section Name:</strong> <span id="propSectionName"></span></p>
</div>

<input type="color" id="colorPickerText" style="display:none;" />
<input type="color" id="colorPickerCheckbox" style="display:none;" />
<input type="color" id="colorPickerDropdown" style="display:none;" />
<input type="color" id="colorPickerMoney" style="display:none;" />

<!--
###########################################################################################################
###########################################################################################################
###                                                                                                     ###
###     S E C T I O N 5:   F I R E B A S E   &   A U T H                                                ###
###                                                                                                     ###
###########################################################################################################
###########################################################################################################
-->
<script>
  const firebaseConfig = {
    apiKey: "AIzaSyBlxFmFD-rz1V_Q9_oV0DkLsENbmyJ1k-U",
    authDomain: "flowchart-1eb90.firebaseapp.com",
    projectId: "flowchart-1eb90",
    storageBucket: "flowchart-1eb90.firebasestorage.app",
    messagingSenderId: "546103281533",
    appId: "1:546103281533:web:ae719cdbde727dcd94ee14",
    measurementId: "G-8VSXRFREY9"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
  let currentUser = null;

  let colorPreferences = {
    text: "#749FFE",
    checkbox: "#A1B8FE",
    dropdown: "#C5D4FE",
    money: "#E2EAFF"
  };

  const loginOverlay = document.getElementById("loginOverlay");
  const loginButton = document.getElementById("loginButton");
  const signupButton = document.getElementById("signupButton");
  const loginEmail = document.getElementById("loginEmail");
  const loginPassword = document.getElementById("loginPassword");
  const loginError = document.getElementById("loginError");

  function showLoginOverlay() {
    loginOverlay.style.display = "flex";
  }
  function hideLoginOverlay() {
    loginOverlay.style.display = "none";
  }
  function setCookie(name, value, days) {
    const d = new Date();
    d.setTime(d.getTime() + days*24*60*60*1000);
    const expires = "expires="+ d.toUTCString();
    document.cookie = name + "=" + value + ";" + expires + ";path=/";
  }
  function getCookie(name) {
    const ca = document.cookie.split(';');
    name = name + "=";
    for (let i=0; i < ca.length; i++) {
      let c = ca[i].trim();
      if (c.indexOf(name) === 0) {
        return c.substring(name.length, c.length);
      }
    }
    return "";
  }

  function checkForSavedLogin() {
    const savedUid = getCookie("flowchart_uid");
    if (savedUid) {
      firebase.auth().onAuthStateChanged((user) => {
        if (user && user.uid === savedUid) {
          currentUser = user;
          hideLoginOverlay();
          loadUserColorPrefs();
        } else {
          showLoginOverlay();
        }
      });
    } else {
      showLoginOverlay();
    }
  }

  loginButton.addEventListener("click", () => {
    const email = loginEmail.value.trim();
    const pass = loginPassword.value.trim();
    firebase.auth().signInWithEmailAndPassword(email, pass)
      .then((cred) => {
        currentUser = cred.user;
        setCookie("flowchart_uid", currentUser.uid, 7);
        hideLoginOverlay();
        loadUserColorPrefs();
      })
      .catch((err) => {
        loginError.textContent = err.message;
      });
  });
  signupButton.addEventListener("click", () => {
    const email = loginEmail.value.trim();
    const pass = loginPassword.value.trim();
    firebase.auth().createUserWithEmailAndPassword(email, pass)
      .then((cred) => {
        currentUser = cred.user;
        setCookie("flowchart_uid", currentUser.uid, 7);
        hideLoginOverlay();
        saveUserColorPrefs().then(() => {
          loadUserColorPrefs();
        });
      })
      .catch((err) => {
        loginError.textContent = err.message;
      });
  });

  function loadUserColorPrefs() {
    if (!currentUser) return;
    db.collection("users")
      .doc(currentUser.uid)
      .collection("preferences")
      .doc("colors")
      .get()
      .then(docSnap => {
        if (docSnap.exists) {
          const data = docSnap.data();
          if (data.text) colorPreferences.text = data.text;
          if (data.checkbox) colorPreferences.checkbox = data.checkbox;
          if (data.dropdown) colorPreferences.dropdown = data.dropdown;
          if (data.money) colorPreferences.money = data.money;
        }
        updateLegendColors();
        refreshAllCells();
      })
      .catch(err => {
        console.error("Error loading color prefs:", err);
      });
  }
  function saveUserColorPrefs() {
    if (!currentUser) return Promise.resolve();
    return db.collection("users")
      .doc(currentUser.uid)
      .collection("preferences")
      .doc("colors")
      .set(colorPreferences, { merge: true });
  }
</script>

<!--
###########################################################################################################
###########################################################################################################
###                                                                                                     ###
###     S E C T I O N 6:   G R A P H   I N I T   &   C O N T E X T   M E N U                            ###
###                                                                                                     ###
###########################################################################################################
###########################################################################################################
-->
<script>
  let graph = null;
  let selectedCell = null;
  let currentMouseEvent = null;
  let lastSelectedCell = null;
  let jumpModeNode = null;
  const jumpBorderStyle = ";strokeWidth=3;strokeColor=#ff0000;dashed=1;dashPattern=4 4;";

  document.addEventListener("DOMContentLoaded", function () {
    if (typeof mxGraph === "undefined") {
      alert("mxGraph library not found!");
      return;
    }
    checkForSavedLogin();

    const container = document.getElementById("graphContainer");
    const contextMenu = document.getElementById("contextMenu");
    const deleteNodeButton = document.getElementById("deleteNode");
    const jumpNodeButton = document.getElementById("jumpNode");
    const changeTypeButton = document.getElementById("changeType");
    const newSectionButton = document.getElementById("newSectionButton");
    const propertiesButton = document.getElementById("propertiesButton");
    const yesNoNodeButton = document.getElementById("yesNoNode");

    const typeSubmenu = document.getElementById("typeSubmenu");
    const dropdownTypeBtn = document.getElementById("dropdownType");
    const checkboxTypeBtn = document.getElementById("checkboxType");
    const textTypeBtn = document.getElementById("textType");
    const moneyTypeBtn = document.getElementById("moneyType");

    const propertiesMenu = document.getElementById("propertiesMenu");
    const propNodeText = document.getElementById("propNodeText");
    const propNodeId = document.getElementById("propNodeId");
    const propNodeType = document.getElementById("propNodeType");
    const propSectionName = document.getElementById("propSectionName");

    const colorBoxText = document.getElementById("colorText");
    const colorBoxCheckbox = document.getElementById("colorCheckbox");
    const colorBoxDropdown = document.getElementById("colorDropdown");
    const colorBoxMoney = document.getElementById("colorMoney");
    const colorPickerText = document.getElementById("colorPickerText");
    const colorPickerCheckbox = document.getElementById("colorPickerCheckbox");
    const colorPickerDropdown = document.getElementById("colorPickerDropdown");
    const colorPickerMoney = document.getElementById("colorPickerMoney");

    // 1) Create the graph
    graph = new mxGraph(container);
    // 2) Let it auto-size to text, as user types
    graph.setAutoSizeCells(true);
    // 3) So raw HTML in cell values actually renders as HTML
    graph.setHtmlLabels(true);

    mxEvent.disableContextMenu(container);
    graph.setPanning(true);
    graph.panningHandler.useLeftButtonForPanning = true;
    graph.setCellsMovable(true);
    graph.setConnectable(true);
    graph.setCellsResizable(true);
    new mxRubberband(graph);

    // 4) Default vertex style
    const defStyle = graph.getStylesheet().getDefaultVertexStyle();
    defStyle["labelBackgroundColor"] = "#ffffff";
    defStyle["labelBorderColor"] = "#cccccc";
    defStyle["rounded"] = "1";      // round corners
    defStyle["arcSize"] = "24";     // bigger corner radius
    defStyle["whiteSpace"] = "wrap";
    defStyle["html"] = "1";
    defStyle["autosize"] = "1";

    // 5) Give each node more internal padding
    defStyle["spacingTop"] = 16;
    defStyle["spacingBottom"] = 16;
    defStyle["spacingLeft"] = 16;
    defStyle["spacingRight"] = 16;

    // 6) If you need a min size so node doesn't collapse too small:
    graph.getModel().addListener(mxEvent.CHANGE, (sender, evt) => {
      const changes = evt.getProperty("changes") || [];
      changes.forEach(change => {
        if (change.constructor.name === "mxGeometryChange") {
          const changedCell = change.cell;
          if (changedCell && changedCell.vertex) {
            const geo = changedCell.geometry;
            if (geo) {
              // Example: enforce min 120 wide, 60 tall
              if (geo.width < 120) geo.width = 120;
              if (geo.height < 60) geo.height = 60;
            }
          }
        }
      });
    });

    /*
      Real-time text update inside the node
      so we can keep it sized properly
    */
    (function overrideCellEditorForRealTime() {
      const oldInstallListeners = mxCellEditor.prototype.installListeners;
      mxCellEditor.prototype.installListeners = function(elt) {
        oldInstallListeners.apply(this, arguments);
        mxEvent.addListener(elt, 'input', (evt) => {
          if (this.editingCell) {
            graph.getModel().beginUpdate();
            try {
              let newVal = elt.innerText || "";
              this.editingCell.value = newVal;
              graph.updateCellSize(this.editingCell);
            } finally {
              graph.getModel().endUpdate();
            }
          }
        });
      };
      const oldStopEditing = mxCellEditor.prototype.stopEditing;
      mxCellEditor.prototype.stopEditing = function(cancel) {
        if (!cancel && this.editingCell != null) {
          graph.updateCellSize(this.editingCell);
        }
        oldStopEditing.apply(this, arguments);
      };
    })();

    // Keep track
    graph.getSelectionModel().addListener(mxEvent.CHANGE, () => {
      if (lastSelectedCell) {
        autoUpdateNodeIdBasedOnLabel(lastSelectedCell);
      }
      lastSelectedCell = graph.getSelectionCell();
    });

    // DRAG FROM TOOLBAR
    const toolbarShapes = document.querySelectorAll(".shape");
    toolbarShapes.forEach((shapeEl) => {
      const baseStyle = shapeEl.dataset.style;
      mxUtils.makeDraggable(
        shapeEl,
        graph,
        function (graph, evt, targetCell, x, y) {
          const parent = graph.getDefaultParent();
          graph.getModel().beginUpdate();
          let newVertex;
          try {
            const label = shapeEl.dataset.type + " node";
            // Start them at 160x80
            newVertex = graph.insertVertex(
              parent,
              null,
              label,
              x,
              y,
              160,
              80,
              baseStyle + ";autosize=1;"
            );
          } finally {
            graph.getModel().endUpdate();
          }
          if (isQuestion(newVertex)) {
            refreshNodeIdFromLabel(newVertex);
          } else if (isOptions(newVertex)) {
            refreshOptionNodeId(newVertex);
          }
          refreshAllCells();
          return newVertex;
        }
      );
    });

    /*
      CONTEXT MENU + PROPERTIES
    */
    graph.popupMenuHandler.factoryMethod = function(menu, cell, evt) {
      selectedCell = cell;
      currentMouseEvent = evt;
      if (cell) {
        showContextMenu(evt);
      } else {
        hideContextMenu();
      }
    };

    function showContextMenu(evt) {
      contextMenu.style.display = "block";
      contextMenu.style.left = evt.clientX + "px";
      contextMenu.style.top = evt.clientY + "px";
      typeSubmenu.style.display = "none";
    }
    function hideContextMenu() {
      contextMenu.style.display = "none";
      typeSubmenu.style.display = "none";
    }
    document.addEventListener("click", (e) => {
      if (
        !contextMenu.contains(e.target) &&
        !typeSubmenu.contains(e.target) &&
        !propertiesMenu.contains(e.target)
      ) {
        hideContextMenu();
        propertiesMenu.style.display = "none";
      }
    });

    deleteNodeButton.addEventListener("click", () => {
      if (selectedCell) {
        graph.removeCells([selectedCell]);
        refreshAllCells();
      }
      hideContextMenu();
    });
    jumpNodeButton.addEventListener("click", () => {
      if (selectedCell) {
        if (jumpModeNode && jumpModeNode !== selectedCell) {
          removeJumpStyling(jumpModeNode);
        }
        jumpModeNode = selectedCell;
        addJumpStyling(jumpModeNode);
      }
      hideContextMenu();
    });
    changeTypeButton.addEventListener("click", () => {
      const rect = contextMenu.getBoundingClientRect();
      typeSubmenu.style.display = "block";
      typeSubmenu.style.left = rect.right + "px";
      typeSubmenu.style.top = rect.top + "px";
    });
    dropdownTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "dropdown");
        selectedCell.value = "Dropdown question node";
        refreshAllCells();
      }
      hideContextMenu();
    });
    checkboxTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "checkbox");
        selectedCell.value = "Checkbox question node";
        refreshAllCells();
      }
      hideContextMenu();
    });
    textTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "text");
        selectedCell.value = "Text question node";
        refreshAllCells();
      }
      hideContextMenu();
    });
    moneyTypeBtn.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        setQuestionType(selectedCell, "money");
        selectedCell.value = "Money question node";
        refreshAllCells();
      }
      hideContextMenu();
    });
    newSectionButton.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        const oldSec = getSectionId(selectedCell);
        const newSec = oldSec + 1;
        setSectionId(selectedCell, newSec);
        markAsNewSection(selectedCell);
        refreshAllCells();
      }
      hideContextMenu();
    });
    propertiesButton.addEventListener("click", () => {
      if (selectedCell) {
        showPropertiesMenu(selectedCell, currentMouseEvent);
      }
      hideContextMenu();
    });
    yesNoNodeButton.addEventListener("click", () => {
      if (selectedCell && isQuestion(selectedCell)) {
        createYesNoOptions(selectedCell);
      }
      hideContextMenu();
    });

    function createYesNoOptions(parentCell) {
      const parentGeo = parentCell.geometry;
      if (!parentGeo) return;
      const parent = graph.getDefaultParent();
      graph.getModel().beginUpdate();
      try {
        const yesX = parentGeo.x - 80;
        const yesY = parentGeo.y + parentGeo.height + 50;
        const yesStyle = "rounded=1;whiteSpace=wrap;html=1;nodeType=options;questionType=dropdown;";
        const yesVertex = graph.insertVertex(parent, null, "Yes", yesX, yesY, 100, 60, yesStyle);
        refreshOptionNodeId(yesVertex);
        graph.insertEdge(parent, null, "", parentCell, yesVertex);

        const noX = parentGeo.x + parentGeo.width + 20;
        const noY = parentGeo.y + parentGeo.height + 50;
        const noStyle = "rounded=1;whiteSpace=wrap;html=1;nodeType=options;questionType=dropdown;";
        const noVertex = graph.insertVertex(parent, null, "No", noX, noY, 100, 60, noStyle);
        refreshOptionNodeId(noVertex);
        graph.insertEdge(parent, null, "", parentCell, noVertex);
      } finally {
        graph.getModel().endUpdate();
      }
      refreshAllCells();
    }

    function showPropertiesMenu(cell, evt) {
      if (!cell) return;
      propertiesMenu.style.display = "block";
      propertiesMenu.style.left = evt.clientX + 10 + "px";
      propertiesMenu.style.top = evt.clientY + 10 + "px";

      propNodeText.textContent = cell.value || "";
      propNodeId.textContent = getNodeId(cell) || "";
      if (isQuestion(cell)) {
        propNodeType.textContent = getQuestionType(cell);
      } else if (isOptions(cell)) {
        propNodeType.textContent = "options";
      } else {
        propNodeType.textContent = "other";
      }
      propSectionName.textContent = "Section " + getSectionId(cell);
    }
    makeEditableField(propNodeText, onNodeTextFieldChange);
    makeEditableField(propNodeId, onNodeIdFieldChange);

    function makeEditableField(spanEl, onChangeCb) {
      spanEl.addEventListener("dblclick", (e) => {
        e.stopPropagation();
        e.preventDefault();
        spanEl.contentEditable = "true";
        spanEl.focus();
      });
      spanEl.addEventListener("blur", () => {
        spanEl.contentEditable = "false";
        onChangeCb(spanEl.textContent);
      });
      spanEl.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter") {
          evt.preventDefault();
          spanEl.blur();
        }
      });
    }
    function onNodeTextFieldChange(newText) {
      if (!selectedCell) return;
      graph.getModel().beginUpdate();
      try {
        selectedCell.value = newText.trim();
        if (isQuestion(selectedCell)) {
          refreshNodeIdFromLabel(selectedCell);
        } else if (isOptions(selectedCell)) {
          refreshOptionNodeId(selectedCell);
        }
      } finally {
        graph.getModel().endUpdate();
      }
      refreshAllCells();
    }
    function onNodeIdFieldChange(newId) {
      if (!selectedCell) return;
      graph.getModel().beginUpdate();
      try {
        setNodeId(selectedCell, newId);
      } finally {
        graph.getModel().endUpdate();
      }
      refreshAllCells();
    }

    // Keyboard copy/paste
    const keyHandler = new mxKeyHandler(graph);
    keyHandler.bindControlKey(67, () => {
      mxClipboard.copy(graph);
    });
    keyHandler.bindControlKey(86, () => {
      const pasted = mxClipboard.paste(graph);
      if (pasted && pasted.length > 0) {
        graph.moveCells(pasted, 40, 40);
        refreshAllCells();
      }
    });

    // Auto question detection if ends with '?'
    graph.getModel().addListener(mxEvent.EVENT_CHANGE, function(sender, evt) {
      const changes = evt.getProperty("changes");
      if (!changes) return;
      changes.forEach((change) => {
        if (change.constructor.name === "mxValueChange") {
          const { cell, value } = change;
          if (value && typeof value === "string") {
            if (value.trim().endsWith("?")) {
              if (!isQuestion(cell)) {
                let style = cell.style || "";
                style += ";nodeType=question;";
                graph.getModel().setStyle(cell, style);
                refreshNodeIdFromLabel(cell);
              }
            }
          }
        }
      });
      refreshAllCells();
    });

    // On connect
    graph.connectionHandler.addListener(mxEvent.CONNECT, function(sender, evt) {
      const edge = evt.getProperty("cell");
      if (!edge) return;
      const parent = edge.source;
      const child = edge.target;

      const parentIsJump = (parent && parent === jumpModeNode);
      let parentQuestion = null;
      if (parent && isOptions(parent)) {
        parentQuestion = parent.source;
      } else if (parent && isQuestion(parent)) {
        parentQuestion = parent;
      }
      const gpIsJump = (parentQuestion && parentQuestion === jumpModeNode);

      if (parentIsJump || gpIsJump) {
        addSkipReassign(child);
      } else {
        const parentSec = getSectionId(parent);
        setSectionId(child, parentSec);
      }
      refreshAllCells();
    });

    // Initialize legend
    updateLegendColors();

    colorBoxText.addEventListener("click", () => colorPickerText.click());
    colorBoxCheckbox.addEventListener("click", () => colorPickerCheckbox.click());
    colorBoxDropdown.addEventListener("click", () => colorPickerDropdown.click());
    colorBoxMoney.addEventListener("click", () => colorPickerMoney.click());

    colorPickerText.addEventListener("input", (e) => {
      colorPreferences.text = e.target.value;
      saveUserColorPrefs().then(()=>{
        updateLegendColors();
        refreshAllCells();
      });
    });
    colorPickerCheckbox.addEventListener("input", (e) => {
      colorPreferences.checkbox = e.target.value;
      saveUserColorPrefs().then(()=>{
        updateLegendColors();
        refreshAllCells();
      });
    });
    colorPickerDropdown.addEventListener("input", (e) => {
      colorPreferences.dropdown = e.target.value;
      saveUserColorPrefs().then(()=>{
        updateLegendColors();
        refreshAllCells();
      });
    });
    colorPickerMoney.addEventListener("input", (e) => {
      colorPreferences.money = e.target.value;
      saveUserColorPrefs().then(()=>{
        updateLegendColors();
        refreshAllCells();
      });
    });
  });
</script>

<!--
###########################################################################################################
###########################################################################################################
###                                                                                                     ###
###     S E C T I O N 7:   H E L P E R   F U N C T I O N S                                               ###
###                                                                                                     ###
###########################################################################################################
###########################################################################################################
-->
<script>
  function updateLegendColors() {
    document.getElementById("colorText").style.backgroundColor = colorPreferences.text;
    document.getElementById("colorCheckbox").style.backgroundColor = colorPreferences.checkbox;
    document.getElementById("colorDropdown").style.backgroundColor = colorPreferences.dropdown;
    document.getElementById("colorMoney").style.backgroundColor = colorPreferences.money;
  }
  function autoUpdateNodeIdBasedOnLabel(cell) {
    if (!cell.vertex) return;
    const label = (cell.value || "").trim();
    if (!label) return;
    if (isQuestion(cell)) {
      refreshNodeIdFromLabel(cell);
    } else if (isOptions(cell)) {
      refreshOptionNodeId(cell);
    }
  }
  function setNodeId(cell, nodeId) {
    let style = cell.style || "";
    style = style.replace(/nodeId=[^;]+/, "");
    style += `;nodeId=${encodeURIComponent(nodeId)};`;
    graph.getModel().setStyle(cell, style);
  }
  function getNodeId(cell) {
    const style = cell.style || "";
    const m = style.match(/nodeId=([^;]+)/);
    return m ? decodeURIComponent(m[1]) : "";
  }
  function isQuestion(cell) {
    return cell && cell.style && cell.style.includes("nodeType=question");
  }
  function isOptions(cell) {
    return cell && cell.style && cell.style.includes("nodeType=options");
  }
  function refreshNodeIdFromLabel(cell) {
    const label = (cell.value || "").toString().trim();
    const nodeId = label.replace(/\s+/g, "_");
    setNodeId(cell, nodeId);
  }
  function refreshOptionNodeId(cell) {
    const edges = graph.getIncomingEdges(cell) || [];
    let parentNodeId = "ParentQuestion";
    for (let e of edges) {
      const p = e.source;
      if (isQuestion(p)) {
        parentNodeId = getNodeId(p) || "ParentQuestion";
        break;
      }
    }
    let label = (cell.value || "Option").toString().trim().replace(/\s+/g, "_");
    setNodeId(cell, parentNodeId + label);
  }
  function setSectionId(cell, sid) {
    if (!cell) return;
    let style = cell.style || "";
    style = style.replace(/sectionId=[^;]+/, "");
    style += `;sectionId=${sid};`;
    graph.getModel().setStyle(cell, style);
  }
  function getSectionId(cell) {
    const style = cell.style || "";
    const m = style.match(/sectionId=([^;]+)/);
    return m ? parseInt(m[1], 10) : 1;
  }
  function hasSkipReassign(cell) {
    return cell && cell.style && cell.style.includes("skipReassign=true");
  }
  function addSkipReassign(cell) {
    if (!cell) return;
    let style = cell.style || "";
    style = style.replace(/skipReassign=[^;]+/, "");
    style += ";skipReassign=true;";
    graph.getModel().setStyle(cell, style);
  }
  function markAsNewSection(cell) {
    if (!cell) return;
    let style = cell.style || "";
    style = style.replace(/newSection=[^;]+/, "");
    style += ";newSection=true;";
    graph.getModel().setStyle(cell, style);
  }
  function addJumpStyling(cell) {
    if (!cell) return;
    let style = cell.style || "";
    style = style.replace(/strokeWidth=\d+;?/, "");
    style = style.replace(/strokeColor=[^;]+;?/, "");
    style = style.replace(/dashed=\d;?/, "");
    style = style.replace(/dashPattern=[^;]+;?/, "");
    style += jumpBorderStyle;
    graph.getModel().setStyle(cell, style);
  }
  function removeJumpStyling(cell) {
    if (!cell) return;
    let style = cell.style || "";
    style = style.replace(/strokeWidth=\d+;?/, "");
    style = style.replace(/strokeColor=[^;]+;?/, "");
    style = style.replace(/dashed=\d;?/, "");
    style = style.replace(/dashPattern=[^;]+;?/, "");
    graph.getModel().setStyle(cell, style);
  }
  function colorCell(cell) {
    if (!cell.vertex) return;
    let fillColor = "#ADD8E6"; // fallback
    if (isQuestion(cell)) {
      const qType = getQuestionType(cell);
      fillColor = getColorForQuestionType(qType);
    } else if (isOptions(cell)) {
      fillColor = "#ffffff";
    }
    let style = cell.style || "";
    style = style.replace(/fillColor=[^;]+/, "");
    style += `;fillColor=${fillColor};`;
    graph.getModel().setStyle(cell, style);
  }
  function getColorForQuestionType(qType) {
    switch (qType) {
      case "text":     return colorPreferences.text;
      case "checkbox": return colorPreferences.checkbox;
      case "dropdown": return colorPreferences.dropdown;
      case "money":    return colorPreferences.money;
      default:         return "#ADD8E6";
    }
  }
  function getQuestionType(cell) {
    const style = cell.style || "";
    const m = style.match(/questionType=([^;]+)/);
    return m ? m[1] : "dropdown";
  }
  function setQuestionType(cell, newType) {
    let style = cell.style || "";
    style = style.replace(/questionType=[^;]+/, "");
    style += `;questionType=${newType};`;
    graph.getModel().setStyle(cell, style);
  }
  function refreshAllCells() {
    const parent = graph.getDefaultParent();
    const vertices = graph.getChildVertices(parent);
    vertices.forEach(cell => {
      if (!hasSkipReassign(cell)) {
        if (isOptions(cell)) {
          const incomingEdges = graph.getIncomingEdges(cell) || [];
          if (incomingEdges.length > 0) {
            const parentCell = incomingEdges[0].source;
            if (parentCell && isQuestion(parentCell)) {
              setSectionId(cell, getSectionId(parentCell));
            }
          }
        }
        if (isQuestion(cell)) {
          const thisSection = getSectionId(cell);
          const incomingEdges = graph.getIncomingEdges(cell) || [];
          const incomingOptions = (incomingEdges||[]).filter(e => e.source && isOptions(e.source));
          if (
            !cell.style.includes("newSection=true") &&
            (thisSection <= 1) &&
            incomingOptions.length > 0
          ) {
            const parentOpt = incomingOptions[0].source;
            setSectionId(cell, getSectionId(parentOpt));
          }
        }
      }
      colorCell(cell);
      if (isQuestion(cell) && (cell.value === "question node" || cell.value === "Question Node")) {
        const cellId = cell.id;
        cell.value = `
          <select oninput="window.pickTypeForCell('${cellId}', this.value)">
            <option value="">-- Choose Type --</option>
            <option value="text">Text</option>
            <option value="checkbox">Checkbox</option>
            <option value="dropdown">Dropdown</option>
            <option value="money">Money</option>
          </select>
        `;
      }
    });
  }

  window.pickTypeForCell = function(cellId, val) {
    const c = graph.getModel().getCell(cellId);
    if (!c) return;
    graph.getModel().beginUpdate();
    try {
      setQuestionType(c, val);
      c.value = val.charAt(0).toUpperCase() + val.slice(1) + " question node";
    } finally {
      graph.getModel().endUpdate();
    }
    refreshAllCells();
  };
</script>

<!--
###########################################################################################################
###########################################################################################################
###                                                                                                     ###
###     S E C T I O N 8:   E X P O R T / I M P O R T                                                    ###
###                                                                                                     ###
###########################################################################################################
###########################################################################################################
-->
<script>
  function downloadJson(str, filename) {
    const blob = new Blob([str], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  window.exportFlowchartJson = function () {
    const data = [];
    const cells = graph.getModel().cells;
    for (let id in cells) {
      if (id === "0" || id === "1") continue;
      const cell = cells[id];
      data.push({
        id: cell.id,
        value: cell.value,
        geometry: cell.geometry
          ? {
              x: cell.geometry.x,
              y: cell.geometry.y,
              width: cell.geometry.width,
              height: cell.geometry.height
            }
          : null,
        style: cell.style || "",
        vertex: !!cell.vertex,
        edge: !!cell.edge,
        source: cell.edge ? cell.source?.id : null,
        target: cell.edge ? cell.target?.id : null
      });
    }
    downloadJson(JSON.stringify(data, null, 2), "flowchart_data.json");
  };

  window.importFlowchartJson = function (evt) {
    const file = evt.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (e) {
      const jsonData = JSON.parse(e.target.result);
      loadFlowchartData(jsonData);
    };
    reader.readAsText(file);
  };

  function loadFlowchartData(data) {
    graph.getModel().beginUpdate();
    try {
      const parent = graph.getDefaultParent();
      graph.removeCells(graph.getChildVertices(parent));
      const createdCells = {};

      data.forEach((item) => {
        if (item.vertex) {
          const geo = new mxGeometry(
            item.geometry.x,
            item.geometry.y,
            item.geometry.width,
            item.geometry.height
          );
          const newCell = new mxCell(item.value, geo, item.style);
          newCell.vertex = true;
          newCell.id = item.id;
          graph.addCell(newCell, parent);
          createdCells[item.id] = newCell;
        }
      });

      data.forEach((item) => {
        if (item.edge) {
          const newEdge = new mxCell(item.value, new mxGeometry(), item.style);
          newEdge.edge = true;
          newEdge.id = item.id;
          const src = createdCells[item.source];
          const trg = createdCells[item.target];
          graph.addCell(newEdge, parent, undefined, src, trg);
        }
      });
    } finally {
      graph.getModel().endUpdate();
    }
    refreshAllCells();
  }

  window.exportGuiJson = function () {
    const model = graph.getModel();
    const allCells = model.cells;
    const sectionsMap = {};
    let questionIdCounter = 1;
    let maxSectionId = 1;

    function getNodeType(cell) {
      if (cell.style && cell.style.includes("nodeType=question")) return "question";
      if (cell.style && cell.style.includes("nodeType=options")) return "options";
      return "other";
    }

    for (let id in allCells) {
      if (id === "0" || id === "1") continue;
      const cell = allCells[id];
      if (cell.vertex && getNodeType(cell) === "question") {
        const sId = getSectionId(cell);
        if (sId > maxSectionId) maxSectionId = sId;
        const label = (cell.value || "").replace(/<[^>]+>/g, "").trim() || "Untitled";
        const qType = getQuestionType(cell);

        const questionObj = {
          questionId: questionIdCounter,
          nameId: getNodeId(cell) || "",
          placeholder: "",
          text: label,
          type: qType,
          logic: {
            enabled: false,
            conditions: []
          },
          jump: {
            enabled: false,
            option: "",
            to: ""
          },
          conditionalPDF: {
            enabled: false,
            pdfName: "",
            answer: "Yes"
          },
          conditionalAlert: {
            enabled: false,
            prevQuestion: "",
            prevAnswer: "",
            text: ""
          },
          options: [],
          labels: []
        };
        if (!sectionsMap[sId]) sectionsMap[sId] = [];
        sectionsMap[sId].push(questionObj);
        cell._questionId = questionIdCounter;
        questionIdCounter++;
      }
    }

    for (let id in allCells) {
      if (id === "0" || id === "1") continue;
      const cell = allCells[id];
      if (cell.vertex && getNodeType(cell) === "question") {
        const sId = getSectionId(cell);
        const label = (cell.value || "").replace(/<[^>]+>/g, "").trim() || "Untitled";
        const questionList = sectionsMap[sId] || [];
        const qObj = questionList.find(q => q.text === label);
        if (!qObj) continue;

        const outEdges = graph.getOutgoingEdges(cell) || [];
        outEdges.forEach(edge => {
          const target = edge.target;
          if (!target) return;
          if (getNodeType(target) === "options") {
            const optLabel = (target.value || "Option").replace(/<[^>]+>/g, "").trim();
            const optNodeId = getNodeId(target);

            if (qObj.type === "checkbox") {
              qObj.options.push({
                label: capitalizeFirst(optLabel),
                nameId: optNodeId,
                value: ""
              });
            } else {
              qObj.options.push(capitalizeFirst(optLabel));
            }

            const nextEdges = graph.getOutgoingEdges(target) || [];
            nextEdges.forEach(ne => {
              const q2 = ne.target;
              if (q2 && getNodeType(q2) === "question") {
                const q2Sid = getSectionId(q2);
                const questionList2 = sectionsMap[q2Sid] || [];
                const q2Obj = questionList2.find(o => o.text === (q2.value||"").replace(/<[^>]+>/g, "").trim());
                if (!q2Obj) return;

                if (q2._questionId < cell._questionId) {
                  qObj.jump.enabled = true;
                  qObj.jump.option = capitalizeFirst(optLabel);
                  qObj.jump.to = q2._questionId.toString();
                } else {
                  q2Obj.logic.enabled = true;
                  q2Obj.logic.conditions.push({
                    prevQuestion: qObj.questionId.toString(),
                    prevAnswer: capitalizeFirst(optLabel)
                  });
                }
              }
            });
          }
        });
      }
    }

    const sectionsArr = [];
    for (let s = 1; s <= maxSectionId; s++) {
      const qList = sectionsMap[s] || [];
      sectionsArr.push({
        sectionId: s,
        sectionName: "Section " + s,
        questions: qList
      });
    }

    const guiData = {
      sections: sectionsArr,
      hiddenFields: [],
      sectionCounter: maxSectionId + 1,
      questionCounter: questionIdCounter,
      hiddenFieldCounter: 1,
      defaultPDFName: ""
    };
    downloadJson(JSON.stringify(guiData, null, 2), "gui_data.json");
  };
  function capitalizeFirst(str) {
    if (!str) return str;
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
</script>

</body>
</html>
