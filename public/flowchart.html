<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Flowchart Creator</title>

  <!-- Include Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore-compat.js"></script>

  <!-- Include MXGraph -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mxgraph@4.2.2/javascript/mxClient.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
      user-select: none;
      overflow: hidden;
    }

    /* Simple login overlay styling */
    #loginOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.3);
      display: none; /* hidden by default */
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    #loginModal {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      width: 300px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.4);
      display: flex;
      flex-direction: column;
    }
    #loginModal h2 {
      margin: 0 0 10px;
    }
    #loginModal input {
      margin-bottom: 10px;
      padding: 8px;
      font-size: 14px;
    }
    #loginModal button {
      padding: 8px;
      font-size: 14px;
      cursor: pointer;
    }
    #logoutButton {
      margin-bottom: 10px;
      padding: 6px 10px;
      background-color: #dc3545;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: none; /* hidden until logged in */
    }
    #logoutButton:hover {
      background-color: #c82333;
    }

    /* Main layout */
    .toolbar {
      width: 220px;
      background: #f9f9f9;
      border-right: 1px solid #ccc;
      float: left;
      padding: 10px;
      box-sizing: border-box;
      height: 100%;
      overflow-y: auto;
    }
    #graphContainer {
      position: absolute;
      left: 220px;
      right: 0;
      top: 0;
      bottom: 0;
      cursor: default;
    }
    .shape {
      background: #fff;
      border: 1px solid #999;
      margin-bottom: 8px;
      text-align: center;
      padding: 6px;
      border-radius: 4px;
      cursor: move;
    }
    .shape:hover {
      background: #e0e0e0;
    }
    .button-bar {
      margin-top: 15px;
    }
    button {
      margin-bottom: 6px;
      padding: 6px 10px;
      background-color: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: block;
      width: 100%;
      box-sizing: border-box;
    }
    button:hover {
      background-color: #0056b3;
    }
    input[type="file"] {
      display: none;
    }

    /* Right-click context menu */
    .context-menu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
      display: none;
      z-index: 1000;
      padding: 5px;
    }
    .context-menu button {
      border: none;
      background: none;
      color: #000;
      padding: 5px 10px;
      text-align: left;
      width: 100%;
      cursor: pointer;
    }
    .context-menu button:hover {
      background-color: #f0f0f0;
    }
    .submenu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      padding: 5px;
      display: none;
      z-index: 2000;
    }
    .submenu button {
      display: block;
      margin-bottom: 4px;
      border: none;
      background: none;
      color: #000;
      padding: 5px 10px;
      text-align: left;
      width: 100%;
      cursor: pointer;
    }
    .submenu button:hover {
      background-color: #f0f0f0;
    }

    /* Properties menu */
    #propertiesMenu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 4px;
      display: none;
      z-index: 3000;
      width: 220px;
    }
    #propertiesMenu p {
      margin: 4px 0;
    }
    .editable-field {
      border: 1px dashed transparent;
      padding: 2px;
      display: inline-block;
      min-width: 50px;
      cursor: text;
    }
    .editable-field:focus {
      outline: 1px dashed #888;
    }

    /* Legend for question-type colors */
    .legend {
      margin-top: 10px;
      padding: 5px;
      background: #f0f0f0;
      border-radius: 4px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
      cursor: pointer;
    }
    .color-block {
      width: 20px;
      height: 20px;
      margin-right: 8px;
      border: 1px solid #333;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- LOGIN OVERLAY -->
  <div id="loginOverlay">
    <div id="loginModal">
      <h2>Login</h2>
      <input type="email" id="loginEmail" placeholder="Email" />
      <input type="password" id="loginPassword" placeholder="Password" />
      <button id="loginButton">Login</button>
      <button id="signupButton">Sign Up</button>
    </div>
  </div>

  <!-- Main toolbar -->
  <div class="toolbar">
    <h3>Shapes</h3>
    <!-- Default question node -->
    <div
      class="shape"
      data-type="question"
      data-style="rounded=1;whiteSpace=wrap;html=1;nodeType=question;questionType=dropdown;sectionId=1;nodeId=Question_node;"
    >
      Question Node
    </div>
    <!-- Default options node -->
    <div
      class="shape"
      data-type="options"
      data-style="rounded=1;whiteSpace=wrap;html=1;nodeType=options;questionType=dropdown;sectionId=1;nodeId=Option_node;"
    >
      Options Node
    </div>

    <div class="button-bar">
      <button onclick="exportFlowchartJson()">Export Flowchart JSON</button>
      <button onclick="document.getElementById('importFlowchartFile').click()">Import Flowchart</button>
      <input
        type="file"
        id="importFlowchartFile"
        accept=".json"
        onchange="importFlowchartJson(event)"
      />
      <button onclick="exportGuiJson()">Export GUI JSON</button>
      <button id="logoutButton">Logout</button>
    </div>

    <!-- Legend for question-type colors -->
    <div class="legend">
      <strong>Legend (Question Colors)</strong>
      <div class="legend-item" data-type="text">
        <div class="color-block" id="colorBlockText"></div> Text
      </div>
      <div class="legend-item" data-type="checkbox">
        <div class="color-block" id="colorBlockCheckbox"></div> Checkbox
      </div>
      <div class="legend-item" data-type="dropdown">
        <div class="color-block" id="colorBlockDropdown"></div> Dropdown
      </div>
      <div class="legend-item" data-type="money">
        <div class="color-block" id="colorBlockMoney"></div> Money
      </div>
    </div>
  </div>

  <div id="graphContainer"></div>

  <!-- Main context menu -->
  <div id="contextMenu" class="context-menu">
    <button id="deleteNode">Delete Node</button>
    <!-- Replaced “Duplicate Node” with “Jump” -->
    <button id="jumpNode">Jump</button>
    <button id="changeType">Change Type &raquo;</button>
    <button id="newSectionButton">New Section</button>
    <button id="yesNoButton">Yes/No</button>
    <button id="propertiesButton">Properties</button>
  </div>

  <!-- Sub-menu for "Change Type" -->
  <div id="typeSubmenu" class="submenu">
    <button id="dropdownType">Drop Down</button>
    <button id="checkboxType">Checkbox</button>
    <button id="textType">Text</button>
    <button id="moneyType">Money</button>
  </div>

  <!-- Properties menu -->
  <div id="propertiesMenu">
    <p><strong>Node Text:</strong>
      <span id="propNodeText" class="editable-field" tabindex="0"></span>
    </p>
    <p><strong>Node ID:</strong>
      <span id="propNodeId" class="editable-field" tabindex="0"></span>
    </p>
    <p><strong>Node Type:</strong> <span id="propNodeType"></span></p>
    <p><strong>Section Name:</strong> <span id="propSectionName"></span></p>
  </div>

  <script>
    /************************************************************/
    /*  1) FIREBASE SETUP                                       */
    /************************************************************/
    const firebaseConfig = {
      apiKey: "AIzaSyBlxFmFD-rz1V_Q9_oV0DkLsENbmyJ1k-U",
      authDomain: "flowchart-1eb90.firebaseapp.com",
      projectId: "flowchart-1eb90",
      storageBucket: "flowchart-1eb90.firebasestorage.app",
      messagingSenderId: "546103281533",
      appId: "1:546103281533:web:ae719cdbde727dcd94ee14",
      measurementId: "G-8VSXRFREY9"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // We'll store color preferences in user document, e.g. "colorPreferences"
    let currentUser = null;
    let colorPreferences = {
      text: "#4B82D5",      // Example default: darker light blue
      checkbox: "#79AFFF", // Example default: a bit lighter
      dropdown: "#ADD8E6", // Example default: light blue
      money: "#E0FFFF"     // Example default: very light blue
    };

    // Try to read color prefs from localStorage/cookie as a fallback
    // (But the main source of truth will be Firestore once logged in)
    let storedPrefs = localStorage.getItem('colorPreferences');
    if (storedPrefs) {
      try {
        colorPreferences = JSON.parse(storedPrefs);
      } catch(e){}
    }

    // Simple function to set a cookie (for demonstration)
    function setCookie(name, value, days=7) {
      const d = new Date();
      d.setTime(d.getTime() + (days*24*60*60*1000));
      let expires = "expires="+ d.toUTCString();
      document.cookie = name + "=" + value + ";" + expires + ";path=/";
    }
    // Simple function to get a cookie
    function getCookie(name) {
      let decodedCookie = decodeURIComponent(document.cookie);
      let ca = decodedCookie.split(';');
      let prefix = name + "=";
      for(let i = 0; i < ca.length; i++) {
        let c = ca[i].trim();
        if (c.indexOf(prefix) == 0) {
          return c.substring(prefix.length, c.length);
        }
      }
      return "";
    }

    // Listen for Auth changes
    auth.onAuthStateChanged(async (user) => {
      if (user) {
        currentUser = user;
        // Save userId in cookie so we know user is logged in
        setCookie("flowchartUserId", user.uid);

        // Load color preferences from Firestore
        await loadColorPreferences();
        // Hide login overlay
        document.getElementById("loginOverlay").style.display = "none";
        document.getElementById("logoutButton").style.display = "block";

        // Refresh the blocks in the legend
        updateLegendBlocks();
        // Recolor existing cells
        if (window.graph) refreshAllCells();

      } else {
        // If not logged in, check if we have a cookie
        let cookieUser = getCookie("flowchartUserId");
        if (cookieUser) {
          // Attempt silent login or do something
          // For simplicity, let's just show the login page if we truly have no Firebase user
          // Clear cookie
          setCookie("flowchartUserId", "", -1);
        }
        document.getElementById("logoutButton").style.display = "none";
        // Show login overlay
        document.getElementById("loginOverlay").style.display = "flex";
      }
    });

    async function loadColorPreferences() {
      if (!currentUser) return;
      const docRef = db.collection("users").doc(currentUser.uid);
      const docSnap = await docRef.get();
      if (docSnap.exists) {
        const data = docSnap.data();
        if (data.colorPreferences) {
          colorPreferences = data.colorPreferences;
          // store locally
          localStorage.setItem('colorPreferences', JSON.stringify(colorPreferences));
        }
      }
    }

    async function saveColorPreferences() {
      if (!currentUser) return;
      // Store in Firestore
      const docRef = db.collection("users").doc(currentUser.uid);
      await docRef.set({ colorPreferences }, { merge: true });
      // Also store in localStorage
      localStorage.setItem('colorPreferences', JSON.stringify(colorPreferences));
    }

    document.addEventListener("DOMContentLoaded", function () {
      /* ----- LOGIN / SIGNUP ----- */
      const loginButton = document.getElementById("loginButton");
      const signupButton = document.getElementById("signupButton");
      const logoutButton = document.getElementById("logoutButton");

      loginButton.addEventListener("click", async () => {
        const email = (document.getElementById("loginEmail").value || "").trim();
        const pass = (document.getElementById("loginPassword").value || "").trim();
        if (!email || !pass) return alert("Please fill in email/password");
        try {
          await auth.signInWithEmailAndPassword(email, pass);
        } catch (err) {
          alert("Login failed: " + err.message);
        }
      });

      signupButton.addEventListener("click", async () => {
        const email = (document.getElementById("loginEmail").value || "").trim();
        const pass = (document.getElementById("loginPassword").value || "").trim();
        if (!email || !pass) return alert("Please fill in email/password");
        try {
          await auth.createUserWithEmailAndPassword(email, pass);
        } catch (err) {
          alert("Sign up failed: " + err.message);
        }
      });

      logoutButton.addEventListener("click", async () => {
        await auth.signOut();
        setCookie("flowchartUserId", "", -1);
        // Show login
        document.getElementById("loginOverlay").style.display = "flex";
      });

      /************************************************************/
      /*  2) INITIALIZE GRAPH & LOGIC                            */
      /************************************************************/
      const container = document.getElementById("graphContainer");

      const contextMenu = document.getElementById("contextMenu");
      const deleteNodeButton = document.getElementById("deleteNode");
      const jumpNodeButton = document.getElementById("jumpNode");
      const changeTypeButton = document.getElementById("changeType");
      const newSectionButton = document.getElementById("newSectionButton");
      const yesNoButton = document.getElementById("yesNoButton");
      const propertiesButton = document.getElementById("propertiesButton");

      const typeSubmenu = document.getElementById("typeSubmenu");
      const dropdownTypeBtn = document.getElementById("dropdownType");
      const checkboxTypeBtn = document.getElementById("checkboxType");
      const textTypeBtn = document.getElementById("textType");
      const moneyTypeBtn = document.getElementById("moneyType");

      const propertiesMenu = document.getElementById("propertiesMenu");
      const propNodeText = document.getElementById("propNodeText");
      const propNodeId = document.getElementById("propNodeId");
      const propNodeType = document.getElementById("propNodeType");
      const propSectionName = document.getElementById("propSectionName");

      let selectedCell = null;
      let currentMouseEvent = null;
      let lastSelectedCell = null;

      let jumpModeNode = null;
      const jumpBorderStyle = ";strokeWidth=3;strokeColor=#ff0000;dashed=1;dashPattern=4 4;";

      mxEvent.disableContextMenu(container);

      const graph = new mxGraph(container);
      window.graph = graph; // so we can call refreshAllCells from outside
      graph.setPanning(true);
      graph.panningHandler.useLeftButtonForPanning = true;
      graph.setCellsMovable(true);
      graph.setConnectable(true);
      graph.setCellsResizable(true);
      new mxRubberband(graph);

      graph.getSelectionModel().addListener(mxEvent.CHANGE, () => {
        if (lastSelectedCell) {
          autoUpdateNodeIdBasedOnLabel(lastSelectedCell);
        }
        lastSelectedCell = graph.getSelectionCell();
      });

      function autoUpdateNodeIdBasedOnLabel(cell) {
        if (!cell.vertex) return;
        const label = (cell.value || "").trim();
        if (!label) return;
        if (isQuestion(cell)) {
          refreshNodeIdFromLabel(cell);
        } else if (isOptions(cell)) {
          refreshOptionNodeId(cell);
        }
      }

      // ---------- ID & Style Helpers ----------
      function setSectionId(cell, sid) {
        if (!cell) return;
        let style = cell.style || "";
        style = style.replace(/sectionId=[^;]+/, "");
        style += `;sectionId=${sid};`;
        graph.getModel().setStyle(cell, style);
      }
      function getSectionId(cell) {
        const style = cell.style || "";
        const m = style.match(/sectionId=([^;]+)/);
        return m ? parseInt(m[1], 10) : 1;
      }
      function addSkipReassign(cell) {
        if (!cell) return;
        let style = cell.style || "";
        style = style.replace(/skipReassign=[^;]+/, "");
        style += ";skipReassign=true;";
        graph.getModel().setStyle(cell, style);
      }
      function hasSkipReassign(cell) {
        return cell && cell.style && cell.style.includes("skipReassign=true");
      }

      // Color for each question type pulled from colorPreferences
      function getColorForQuestionType(qType) {
        switch(qType) {
          case "text":     return colorPreferences.text;
          case "checkbox": return colorPreferences.checkbox;
          case "dropdown": return colorPreferences.dropdown;
          case "money":    return colorPreferences.money;
          default:         return "#ADD8E6"; // fallback
        }
      }

      function getQuestionType(cell) {
        const style = cell.style || "";
        const m = style.match(/questionType=([^;]+)/);
        return m ? m[1] : "dropdown";
      }
      function setQuestionType(cell, newType) {
        let style = cell.style || "";
        style = style.replace(/questionType=[^;]+/, "");
        style += `;questionType=${newType};`;
        graph.getModel().setStyle(cell, style);
      }

      function getNodeId(cell) {
        const style = cell.style || "";
        const m = style.match(/nodeId=([^;]+)/);
        return m ? decodeURIComponent(m[1]) : "";
      }
      function setNodeId(cell, nodeId) {
        let style = cell.style || "";
        style = style.replace(/nodeId=[^;]+/, "");
        style += `;nodeId=${encodeURIComponent(nodeId)};`;
        graph.getModel().setStyle(cell, style);
      }

      function isQuestion(cell) {
        return cell && cell.style && cell.style.includes("nodeType=question");
      }
      function isOptions(cell) {
        return cell && cell.style && cell.style.includes("nodeType=options");
      }

      // ---------- refresh logic ----------
      window.refreshAllCells = function() {
        const parent = graph.getDefaultParent();
        const vertices = graph.getChildVertices(parent);

        graph.getModel().beginUpdate();
        try {
          vertices.forEach((cell) => {
            if (!hasSkipReassign(cell)) {
              if (isOptions(cell)) {
                const incomingEdges = graph.getIncomingEdges(cell) || [];
                if (incomingEdges.length > 0) {
                  const parentCell = incomingEdges[0].source;
                  if (parentCell && isQuestion(parentCell)) {
                    const pSec = getSectionId(parentCell);
                    setSectionId(cell, pSec);
                  }
                }
              }
              if (isQuestion(cell)) {
                const thisSection = getSectionId(cell);
                const incomingEdges = graph.getIncomingEdges(cell) || [];
                const incomingOptions = incomingEdges.filter(e => {
                  return e.source && isOptions(e.source);
                });
                if (
                  !cell.style.includes("newSection=true") &&
                  (thisSection === 1 || thisSection === 0) &&
                  incomingOptions.length > 0
                ) {
                  const parentOpt = incomingOptions[0].source;
                  const parentSectionId = getSectionId(parentOpt);
                  setSectionId(cell, parentSectionId);
                }
              }
            }
            colorCell(cell);
            updateOverlay(cell);
          });
        } finally {
          graph.getModel().endUpdate();
        }
      }

      function colorCell(cell) {
        if (!cell.vertex) return;
        if (isQuestion(cell)) {
          const qType = getQuestionType(cell);
          let fillColor = getColorForQuestionType(qType);

          // If also "newSection=true", you might want a border or something.
          if (cell.style.includes("newSection=true")) {
            // We won't override fillColor, but you can do something else if needed
          }

          let style = cell.style || "";
          style = style.replace(/fillColor=[^;]+/, "");
          style += `;fillColor=${fillColor};`;
          graph.getModel().setStyle(cell, style);

        } else if (isOptions(cell)) {
          // For options, let's just keep it as is or a default color.
          let style = cell.style || "";
          style = style.replace(/fillColor=[^;]+/, "");
          style += ";fillColor=#ffffff;";
          graph.getModel().setStyle(cell, style);
        }
      }

      function markAsNewSection(cell) {
        if (!cell) return;
        let style = cell.style || "";
        style = style.replace(/newSection=[^;]+/, "");
        style += ";newSection=true;";
        graph.getModel().setStyle(cell, style);
      }

      function updateOverlay(cell) {
        graph.removeCellOverlays(cell);
        if (!cell.vertex) return;
        let text = "node";
        if (isQuestion(cell)) text = getQuestionType(cell);
        else if (isOptions(cell)) text = "options";
        const overlay = new mxCellOverlay(
          new mxImage("data:image/gif;base64,R0lGODlhAQABAAAAACw=", 1, 1),
          text
        );
        graph.addCellOverlay(cell, overlay);
      }

      function refreshNodeIdFromLabel(cell) {
        const label = (cell.value || "").toString().trim();
        const nodeId = label.replace(/\s+/g, "_");
        setNodeId(cell, nodeId);
      }
      function refreshOptionNodeId(cell) {
        const edges = graph.getIncomingEdges(cell) || [];
        let parentNodeId = "ParentQuestion";
        for (let e of edges) {
          const p = e.source;
          if (isQuestion(p)) {
            parentNodeId = getNodeId(p) || "ParentQuestion";
            break;
          }
        }
        let label = (cell.value || "Option").toString().trim().replace(/\s+/g, "_");
        setNodeId(cell, parentNodeId + label);
      }

      // ---------- Context Menu & handlers ----------
      graph.popupMenuHandler.factoryMethod = function (menu, cell, evt) {
        selectedCell = cell;
        currentMouseEvent = evt;
        if (cell) {
          showContextMenu(evt);
        } else {
          hideContextMenu();
        }
      };

      function showContextMenu(evt) {
        contextMenu.style.display = "block";
        contextMenu.style.left = evt.clientX + "px";
        contextMenu.style.top = evt.clientY + "px";
        typeSubmenu.style.display = "none";
      }
      function hideContextMenu() {
        contextMenu.style.display = "none";
        typeSubmenu.style.display = "none";
      }
      document.addEventListener("click", (e) => {
        if (
          !contextMenu.contains(e.target) &&
          !typeSubmenu.contains(e.target) &&
          !propertiesMenu.contains(e.target)
        ) {
          hideContextMenu();
          propertiesMenu.style.display = "none";
        }
      });

      deleteNodeButton.addEventListener("click", () => {
        if (selectedCell) {
          graph.removeCells([selectedCell]);
          refreshAllCells();
        }
        hideContextMenu();
      });

      jumpNodeButton.addEventListener("click", () => {
        if (selectedCell) {
          if (jumpModeNode && jumpModeNode !== selectedCell) {
            removeJumpStyling(jumpModeNode);
          }
          jumpModeNode = selectedCell;
          addJumpStyling(jumpModeNode);
        }
        hideContextMenu();
      });
      function addJumpStyling(cell) {
        if (!cell) return;
        let style = cell.style || "";
        style = style.replace(/strokeWidth=\d+;?/, "");
        style = style.replace(/strokeColor=[^;]+;?/, "");
        style = style.replace(/dashed=\d;?/, "");
        style = style.replace(/dashPattern=[^;]+;?/, "");
        style += jumpBorderStyle;
        graph.getModel().setStyle(cell, style);
      }
      function removeJumpStyling(cell) {
        if (!cell) return;
        let style = cell.style || "";
        style = style.replace(/strokeWidth=\d+;?/, "");
        style = style.replace(/strokeColor=[^;]+;?/, "");
        style = style.replace(/dashed=\d;?/, "");
        style = style.replace(/dashPattern=[^;]+;?/, "");
        graph.getModel().setStyle(cell, style);
      }

      changeTypeButton.addEventListener("click", () => {
        const rect = contextMenu.getBoundingClientRect();
        typeSubmenu.style.display = "block";
        typeSubmenu.style.left = rect.right + "px";
        typeSubmenu.style.top = rect.top + "px";
      });

      dropdownTypeBtn.addEventListener("click", () => {
        if (selectedCell && isQuestion(selectedCell)) {
          setQuestionType(selectedCell, "dropdown");
          selectedCell.value = "Dropdown question node";
          refreshAllCells();
        }
        hideContextMenu();
      });
      checkboxTypeBtn.addEventListener("click", () => {
        if (selectedCell && isQuestion(selectedCell)) {
          setQuestionType(selectedCell, "checkbox");
          selectedCell.value = "Checkbox question node";
          refreshAllCells();
        }
        hideContextMenu();
      });
      textTypeBtn.addEventListener("click", () => {
        if (selectedCell && isQuestion(selectedCell)) {
          setQuestionType(selectedCell, "text");
          selectedCell.value = "Text question node";
          refreshAllCells();
        }
        hideContextMenu();
      });
      moneyTypeBtn.addEventListener("click", () => {
        if (selectedCell && isQuestion(selectedCell)) {
          setQuestionType(selectedCell, "money");
          selectedCell.value = "Money question node";
          refreshAllCells();
        }
        hideContextMenu();
      });

      newSectionButton.addEventListener("click", () => {
        if (selectedCell && isQuestion(selectedCell)) {
          const oldSec = getSectionId(selectedCell);
          const newSec = oldSec + 1;
          setSectionId(selectedCell, newSec);
          markAsNewSection(selectedCell);
          refreshAllCells();
        }
        hideContextMenu();
      });

      // The NEW "Yes/No" context menu item
      yesNoButton.addEventListener("click", () => {
        if (selectedCell && isQuestion(selectedCell)) {
          createYesNoOptions(selectedCell);
        }
        hideContextMenu();
      });

      function createYesNoOptions(parentCell) {
        graph.getModel().beginUpdate();
        try {
          const parentGeo = parentCell.geometry;
          const parentX = parentGeo.x;
          const parentY = parentGeo.y;

          // Create a "Yes" options node (below to the left)
          let yesVertex = graph.insertVertex(
            graph.getDefaultParent(),
            null,
            "Yes",
            parentX - 80,
            parentY + 80,
            80,
            40,
            "rounded=1;whiteSpace=wrap;html=1;nodeType=options;questionType=dropdown;"
          );
          refreshOptionNodeId(yesVertex);

          // Create a "No" options node (below to the right)
          let noVertex = graph.insertVertex(
            graph.getDefaultParent(),
            null,
            "No",
            parentX + 80,
            parentY + 80,
            80,
            40,
            "rounded=1;whiteSpace=wrap;html=1;nodeType=options;questionType=dropdown;"
          );
          refreshOptionNodeId(noVertex);

          // Create edges
          let yesEdge = graph.insertEdge(
            graph.getDefaultParent(),
            null,
            "",
            parentCell,
            yesVertex
          );
          let noEdge = graph.insertEdge(
            graph.getDefaultParent(),
            null,
            "",
            parentCell,
            noVertex
          );

        } finally {
          graph.getModel().endUpdate();
        }
        refreshAllCells();
      }

      propertiesButton.addEventListener("click", () => {
        if (selectedCell) {
          showPropertiesMenu(selectedCell, currentMouseEvent);
        }
        hideContextMenu();
      });

      // ---------- Properties Menu ----------
      function showPropertiesMenu(cell, evt) {
        if (!cell) return;
        propertiesMenu.style.display = "block";
        propertiesMenu.style.left = evt.clientX + 10 + "px";
        propertiesMenu.style.top = evt.clientY + 10 + "px";

        propNodeText.textContent = cell.value || "";
        propNodeId.textContent = getNodeId(cell) || "";
        if (isQuestion(cell)) {
          propNodeType.textContent = getQuestionType(cell);
        } else if (isOptions(cell)) {
          propNodeType.textContent = "options";
        } else {
          propNodeType.textContent = "other";
        }
        const sid = getSectionId(cell);
        propSectionName.textContent = "Section " + sid;
      }
      makeEditableField(propNodeText, onNodeTextFieldChange);
      makeEditableField(propNodeId, onNodeIdFieldChange);

      function makeEditableField(spanEl, onChangeCb) {
        spanEl.addEventListener("dblclick", (e) => {
          e.stopPropagation();
          e.preventDefault();
          spanEl.contentEditable = "true";
          spanEl.focus();
        });
        spanEl.addEventListener("blur", () => {
          spanEl.contentEditable = "false";
          onChangeCb(spanEl.textContent);
        });
        spanEl.addEventListener("keydown", (evt) => {
          if (evt.key === "Enter") {
            evt.preventDefault();
            spanEl.blur();
          }
        });
      }

      function onNodeTextFieldChange(newText) {
        if (!selectedCell) return;
        graph.getModel().beginUpdate();
        try {
          selectedCell.value = newText.trim();
          if (isQuestion(selectedCell)) {
            refreshNodeIdFromLabel(selectedCell);
          } else if (isOptions(selectedCell)) {
            refreshOptionNodeId(selectedCell);
          }
        } finally {
          graph.getModel().endUpdate();
        }
        refreshAllCells();
      }
      function onNodeIdFieldChange(newId) {
        if (!selectedCell) return;
        graph.getModel().beginUpdate();
        try {
          setNodeId(selectedCell, newId);
        } finally {
          graph.getModel().endUpdate();
        }
        refreshAllCells();
      }

      // Copy/Paste
      const keyHandler = new mxKeyHandler(graph);
      keyHandler.bindControlKey(67, () => {
        mxClipboard.copy(graph);
      });
      keyHandler.bindControlKey(86, () => {
        const pasted = mxClipboard.paste(graph);
        if (pasted && pasted.length > 0) {
          graph.moveCells(pasted, 40, 40);
          refreshAllCells();
        }
      });

      // Drag from shapes
      const toolbarShapes = document.querySelectorAll(".shape");
      toolbarShapes.forEach((shapeEl) => {
        const baseStyle = shapeEl.dataset.style;
        mxUtils.makeDraggable(
          shapeEl,
          graph,
          function (graph, evt, targetCell, x, y) {
            const parent = graph.getDefaultParent();
            graph.getModel().beginUpdate();
            let newVertex;
            try {
              newVertex = graph.insertVertex(
                parent,
                null,
                shapeEl.dataset.type + " node",
                x,
                y,
                100,
                60,
                baseStyle
              );
            } finally {
              graph.getModel().endUpdate();
            }
            if (isQuestion(newVertex)) {
              refreshNodeIdFromLabel(newVertex);
            } else if (isOptions(newVertex)) {
              refreshOptionNodeId(newVertex);
            }
            refreshAllCells();
            return newVertex;
          }
        );
      });

      // If label ends with '?', auto question
      graph.getModel().addListener(mxEvent.EVENT_CHANGE, function (sender, evt) {
        const changes = evt.getProperty("changes");
        if (!changes) return;
        changes.forEach((change) => {
          if (change.constructor.name === "mxValueChange") {
            const { cell, value } = change;
            if (value && typeof value === "string") {
              if (value.trim().endsWith("?")) {
                if (!isQuestion(cell)) {
                  let style = cell.style || "";
                  style += ";nodeType=question;";
                  graph.getModel().setStyle(cell, style);
                  refreshNodeIdFromLabel(cell);
                }
              }
            }
          }
        });
        refreshAllCells();
      });

      // CONNECT child inherits parent's section UNLESS parent is jump
      graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty("cell");
        if (!edge) return;
        const parent = edge.source;
        const child = edge.target;

        const parentIsJump = (parent && parent === jumpModeNode);

        let parentQuestion = null;
        if (parent && isOptions(parent)) {
          parentQuestion = parent.source;
        } else if (parent && isQuestion(parent)) {
          parentQuestion = parent;
        }
        const gpIsJump = (parentQuestion && parentQuestion === jumpModeNode);

        if (parentIsJump || gpIsJump) {
          addSkipReassign(child);
        } else {
          const parentSec = getSectionId(parent);
          setSectionId(child, parentSec);
        }
        refreshAllCells();
      });

      // ---------- Export / Import Flowchart JSON ----------
      window.exportFlowchartJson = function () {
        const data = [];
        const cells = graph.getModel().cells;
        for (let id in cells) {
          if (id === "0" || id === "1") continue;
          const cell = cells[id];
          data.push({
            id: cell.id,
            value: cell.value,
            geometry: cell.geometry
              ? {
                  x: cell.geometry.x,
                  y: cell.geometry.y,
                  width: cell.geometry.width,
                  height: cell.geometry.height
                }
              : null,
            style: cell.style || "",
            vertex: !!cell.vertex,
            edge: !!cell.edge,
            source: cell.edge ? cell.source?.id : null,
            target: cell.edge ? cell.target?.id : null
          });
        }
        downloadJson(JSON.stringify(data, null, 2), "flowchart_data.json");
      };

      window.importFlowchartJson = function (evt) {
        const file = evt.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
          const jsonData = JSON.parse(e.target.result);
          loadFlowchartData(jsonData);
        };
        reader.readAsText(file);
      };

      function loadFlowchartData(data) {
        graph.getModel().beginUpdate();
        try {
          const parent = graph.getDefaultParent();
          graph.removeCells(graph.getChildVertices(parent));
          const createdCells = {};
          // pass1: vertices
          data.forEach((item) => {
            if (item.vertex) {
              const geo = new mxGeometry(
                item.geometry.x,
                item.geometry.y,
                item.geometry.width,
                item.geometry.height
              );
              const newCell = new mxCell(item.value, geo, item.style);
              newCell.vertex = true;
              newCell.id = item.id;
              graph.addCell(newCell, parent);
              createdCells[item.id] = newCell;
            }
          });
          // pass2: edges
          data.forEach((item) => {
            if (item.edge) {
              const newEdge = new mxCell(item.value, new mxGeometry(), item.style);
              newEdge.edge = true;
              newEdge.id = item.id;
              const src = createdCells[item.source];
              const trg = createdCells[item.target];
              graph.addCell(newEdge, parent, undefined, src, trg);
            }
          });
        } finally {
          graph.getModel().endUpdate();
        }
        refreshAllCells();
      }

      function downloadJson(str, filename) {
        const blob = new Blob([str], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // ---------- Export GUI JSON ----------
      window.exportGuiJson = function () {
        const model = graph.getModel();
        const allCells = model.cells;
        const sectionsMap = {};
        let questionIdCounter = 1;
        let maxSectionId = 1;

        function getNodeType(cell) {
          if (cell.style && cell.style.includes("nodeType=question")) return "question";
          if (cell.style && cell.style.includes("nodeType=options")) return "options";
          return "other";
        }

        for (let id in allCells) {
          if (id === "0" || id === "1") continue;
          const cell = allCells[id];
          if (cell.vertex && getNodeType(cell) === "question") {
            const sId = getSectionId(cell);
            if (sId > maxSectionId) maxSectionId = sId;
            const label = (cell.value || "").trim() || "Untitled";
            const qType = getQuestionType(cell);

            const questionObj = {
              questionId: questionIdCounter,
              nameId: getNodeId(cell) || "",
              placeholder: "",
              text: label,
              type: qType,
              logic: {
                enabled: false,
                conditions: []
              },
              jump: {
                enabled: false,
                option: "",
                to: ""
              },
              conditionalPDF: {
                enabled: false,
                pdfName: "",
                answer: "Yes"
              },
              conditionalAlert: {
                enabled: false,
                prevQuestion: "",
                prevAnswer: "",
                text: ""
              },
              options: [],
              labels: []
            };
            if (!sectionsMap[sId]) sectionsMap[sId] = [];
            sectionsMap[sId].push(questionObj);

            cell._questionId = questionIdCounter;
            questionIdCounter++;
          }
        }

        for (let id in allCells) {
          if (id === "0" || id === "1") continue;
          const cell = allCells[id];
          if (cell.vertex && getNodeType(cell) === "question") {
            const sId = getSectionId(cell);
            const label = (cell.value || "").trim() || "Untitled";
            const questionList = sectionsMap[sId] || [];
            const qObj = questionList.find(q => q.text === label);
            if (!qObj) continue;

            const outEdges = graph.getOutgoingEdges(cell) || [];
            outEdges.forEach(edge => {
              const target = edge.target;
              if (!target) return;
              if (getNodeType(target) === "options") {
                const optLabel = (target.value || "Option").trim();
                const optNodeId = getNodeId(target);

                if (qObj.type === "checkbox") {
                  qObj.options.push({
                    label: capitalizeFirst(optLabel),
                    nameId: optNodeId,
                    value: ""
                  });
                } else {
                  qObj.options.push(capitalizeFirst(optLabel));
                }

                const nextEdges = graph.getOutgoingEdges(target) || [];
                nextEdges.forEach(ne => {
                  const q2 = ne.target;
                  if (q2 && getNodeType(q2) === "question") {
                    const q2Sid = getSectionId(q2);
                    const questionList2 = sectionsMap[q2Sid] || [];
                    const q2Obj = questionList2.find(o => o.text === (q2.value || "").trim());
                    if (!q2Obj) return;

                    // If it references an earlier question => jump
                    if (q2._questionId < cell._questionId) {
                      qObj.jump.enabled = true;
                      qObj.jump.option = capitalizeFirst(optLabel);
                      qObj.jump.to = q2._questionId.toString();
                    } else {
                      // Later question => logic
                      q2Obj.logic.enabled = true;
                      q2Obj.logic.conditions.push({
                        prevQuestion: qObj.questionId.toString(),
                        prevAnswer: capitalizeFirst(optLabel)
                      });
                    }
                  }
                });
              }
            });
          }
        }

        const sectionsArr = [];
        for (let s = 1; s <= maxSectionId; s++) {
          const qList = sectionsMap[s] || [];
          sectionsArr.push({
            sectionId: s,
            sectionName: "Section " + s,
            questions: qList
          });
        }

        const guiData = {
          sections: sectionsArr,
          hiddenFields: [],
          sectionCounter: maxSectionId + 1,
          questionCounter: questionIdCounter,
          hiddenFieldCounter: 1,
          defaultPDFName: ""
        };
        downloadJson(JSON.stringify(guiData, null, 2), "gui_data.json");
      };

      function capitalizeFirst(str) {
        if (!str) return str;
        return str.charAt(0).toUpperCase() + str.slice(1);
      }

      // Load the legend color blocks
      initLegendColorPickers();

      function initLegendColorPickers() {
        const colorBlockText = document.getElementById("colorBlockText");
        const colorBlockCheckbox = document.getElementById("colorBlockCheckbox");
        const colorBlockDropdown = document.getElementById("colorBlockDropdown");
        const colorBlockMoney = document.getElementById("colorBlockMoney");

        updateLegendBlocks();

        // For each color block, attach an event that opens an <input type="color">
        colorBlockText.addEventListener("click", () => onColorBlockClick("text"));
        colorBlockCheckbox.addEventListener("click", () => onColorBlockClick("checkbox"));
        colorBlockDropdown.addEventListener("click", () => onColorBlockClick("dropdown"));
        colorBlockMoney.addEventListener("click", () => onColorBlockClick("money"));
      }

      function onColorBlockClick(questionType) {
        // Create a hidden <input type="color">, click it
        const colorInput = document.createElement("input");
        colorInput.type = "color";
        colorInput.value = colorPreferences[questionType] || "#ADD8E6";
        colorInput.style.display = "none";

        colorInput.addEventListener("input", async (e) => {
          colorPreferences[questionType] = e.target.value;
          await saveColorPreferences();
          updateLegendBlocks();
          refreshAllCells();
        });

        document.body.appendChild(colorInput);
        colorInput.click();
        document.body.removeChild(colorInput);
      }

      function updateLegendBlocks() {
        document.getElementById("colorBlockText").style.backgroundColor = colorPreferences.text;
        document.getElementById("colorBlockCheckbox").style.backgroundColor = colorPreferences.checkbox;
        document.getElementById("colorBlockDropdown").style.backgroundColor = colorPreferences.dropdown;
        document.getElementById("colorBlockMoney").style.backgroundColor = colorPreferences.money;
      }

    }); // end DOMContentLoaded
  </script>
</body>
</html>
