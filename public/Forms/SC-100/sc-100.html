<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Example Form</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="generate.css">
    <link rel="stylesheet" href="generate2.css">
    <style>
        .entry-container { border: 1px solid #e1e5e9 !important; border-radius: 12px; padding: 20px; margin: 10px 0; background-color: #ffffff; box-shadow: 0 2px 6px rgba(0,0,0,0.05); transition: all 0.3s ease; display: block; width: 100%; box-sizing: border-box; }
        .question-container { background-color: #ffffff; border: 1px solid #bcd8ff; border-radius: 16px; padding: 24px 28px; margin: 12px auto; box-shadow: 0 4px 12px rgba(30,73,150,0.08); transition: box-shadow 0.3s ease; box-sizing: border-box; max-width: 737px; width: 100%; }
        .question-container .question-text { margin-top: 0; }
        .question-container .question-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
        .question-nav { display: flex; align-items: center; justify-content: center; gap: 12px; margin: 56px auto 0; max-width: 737px; }
        .question-nav-btn { width: 48px; height: 55px; border-radius: 50%; border: none; background: linear-gradient(135deg, #2f7bff, #0d4ed8); color: #ffffff; font-size: 22px; font-weight: 800; cursor: pointer; box-shadow: 0 8px 20px rgba(30,73,150,0.22); display: inline-flex; align-items: center; justify-content: center; transition: transform 0.2s ease, box-shadow 0.2s ease; line-height: 1; padding-top: 1px; }
        .question-nav-btn.submit-mode { background: linear-gradient(135deg, #0acffe, #495aff); box-shadow: 0 10px 24px rgba(9, 132, 227, 0.35); }
        .question-nav-btn:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(28,126,214,0.25); }
        .question-nav-btn:disabled { background: #dfe6f3; color: #7c8ca8; cursor: not-allowed; box-shadow: none; }
        .question-progress { font-weight: 600; color: #1f3a60; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; letter-spacing: 0.01em; }
        .question-step-hidden { display: none !important; }
        #box { padding-top: 100px; margin: 50px; }
        @media (max-width: 600px) {
            body { padding: 0 !important; }
            #box { margin: 12px !important; max-width: none !important; }
            .question-container { margin: 6px auto !important; padding: 20px 18px !important; }
            .question-nav { margin: 40px auto 0 !important; }
        }
        .address-field { margin: 4px auto; }
        .address-input { width: 80%; max-width: 400px; padding: 12px 16px; border: 1px solid #d1d1d6 !important; border-radius: 8px; font-size: 16px; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background-color: #ffffff !important; transition: all 0.2s ease; box-sizing: border-box; text-align: center; height: 44px; line-height: 20px; }
        .address-input:focus, .address-select:focus, .address-select-main:focus, .address-select-trigger:focus { outline: none; box-shadow: 0 0 0 3px rgba(0,0,0,0.06); }
        .address-input::placeholder { color: #6c757d; opacity: 1; }
        .address-select { width: 93%; max-width: 465px; cursor: pointer; background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e"); background-repeat: no-repeat; background-position: right 12px center; background-size: 16px; padding: 12px 44px 12px 16px; appearance: none; -webkit-appearance: none; text-align: center; height: 44px; line-height: 20px; border: 1px solid #d1d1d6 !important; border-radius: 8px; font-size: 16px; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background-color: #ffffff !important; transition: all 0.2s ease; box-sizing: border-box; overflow: visible; }
        .address-select-main { width: 160px; cursor: pointer; background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e"); background-repeat: no-repeat; background-position: right 8px center; background-size: 16px; padding: 12px 24px 12px 8px; appearance: none; -webkit-appearance: none; text-align: center; height: 44px; line-height: 20px; border: 1px solid #d1d1d6 !important; border-radius: 8px; font-size: 16px; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background-color: #ffffff !important; transition: all 0.2s ease; box-sizing: border-box; overflow: visible; }
        .address-select-trigger { width: 160px; cursor: pointer; background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e"); background-repeat: no-repeat; background-position: right 2px center; background-size: 12px; padding: 0; appearance: none; -webkit-appearance: none; text-align: center; height: 44px; line-height: 20px; border: 1px solid #d1d1d6 !important; border-radius: 8px; font-size: 16px; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background-color: #ffffff !important; transition: all 0.2s ease; box-sizing: border-box; overflow: visible; }
        .address-field:first-child { margin-top: 2px; }
        .address-field:last-child { margin-bottom: 2px; }
        .hidden { display: none !important; }
        .file-upload-container { margin: 20px 0; }
        .file-upload-dropzone { border: 2px dashed #2f7bff; border-radius: 12px; padding: 40px 20px; text-align: center; background-color: #f8f9fa; cursor: pointer; transition: all 0.3s ease; }
        .file-upload-dropzone:hover { background-color: #e9ecef; border-color: #0d4ed8; }
        .file-upload-dropzone.file-upload-dragover { background-color: #e3f2fd; border-color: #0d4ed8; border-style: solid; }
        .file-upload-content { pointer-events: none; }
        .file-upload-text { margin: 8px 0; color: #2c3e50; font-size: 16px; font-weight: 500; }
        .file-upload-link { color: #2f7bff; text-decoration: underline; cursor: pointer; pointer-events: auto; }
        .file-upload-link:hover { color: #0d4ed8; }
        .file-upload-hint { margin: 4px 0 0 0; color: #6c757d; font-size: 14px; }
        .file-upload-preview { margin-top: 20px; border: 1px solid #dee2e6; border-radius: 8px; background-color: #ffffff; padding: 16px; }
        .file-upload-preview-body { margin-bottom: 12px; }
        .file-upload-cancel { background: #dc3545; color: white; border: none; border-radius: 6px; padding: 8px 20px; cursor: pointer; font-size: 14px; font-weight: 500; display: block; margin: 0 auto; transition: background 0.2s ease; }
        .file-upload-cancel:hover { background: #c82333; }
        .file-upload-preview-body img { max-width: 100%; max-height: 400px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .file-upload-preview-body iframe { width: 100%; height: 500px; border: 1px solid #dee2e6; border-radius: 8px; }
        .signin-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 10000; display: none; align-items: center; justify-content: center; }
        .signin-modal { background-color: #ffffff; border-radius: 12px; padding: 32px; max-width: 500px; width: 90%; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); text-align: center; position: relative; }
        .signin-modal h2 { margin: 0 0 16px 0; color: #2c3e50; font-size: 24px; font-weight: 700; }
        .signin-modal p { margin: 0 0 24px 0; color: #5a6c7d; font-size: 16px; line-height: 1.5; }
        .signin-modal-button { background: linear-gradient(135deg, #2f7bff, #0d4ed8); color: #ffffff; border: none; padding: 14px 32px; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(47, 123, 255, 0.3); transition: transform 0.2s ease, box-shadow 0.2s ease; }
        .signin-modal-button:hover { transform: translateY(-1px); box-shadow: 0 6px 16px rgba(47, 123, 255, 0.4); }
        .signin-modal-button:active { transform: translateY(0); }
    </style>
    <script>
      // Phone formatter: Phone Number
      window.formatPhoneInput = window.formatPhoneInput || function(inputEl) {
        if (!inputEl) return;
        const digits = (inputEl.value || "").replace(/\D/g, "").slice(0, 10);
        let formatted = "";
        if (digits.length > 0) {
          formatted += "(" + digits.slice(0, Math.min(3, digits.length));
          if (digits.length >= 3) formatted += ")";
        }
        if (digits.length > 3) {
          formatted += "-" + digits.slice(3, Math.min(6, digits.length));
        }
        if (digits.length > 6) {
          formatted += "-" + digits.slice(6, 10);
        }
        inputEl.value = formatted;
      };
    </script>
</head>
<body>
<header>
    <img src="logo.png" alt="FormStar Logo" width="130" height="80" onclick="location.href='../../index.html';">
    <nav>
        <a href="../../index.html">Home
            <span class="nav-chevron"><svg viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 1L5 5L9 1" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
        </a>
        <div class="nav-dropdown-wrapper" id="forms-dropdown-wrapper">
            <a href="#" id="forms-nav-link">Forms
                <span class="nav-chevron forms-chevron"><svg viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 1L5 5L9 1" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
            </a>
            <div class="dropdown-menu" id="forms-dropdown-menu">
                <a href="../../Pages/forms.html">My Forms</a>
                <a href="../../Pages/FreeForm.html">Free Form</a>
                <a href="../../Pages/Family.html">Family</a>
                <a href="../../Pages/Property.html">Property</a>
                <a href="../../Pages/Immigration.html">Immigration</a>
                <a href="../../Pages/smallclaims.html">Small Claims</a>
                <a href="../../Pages/Other.html">Other</a>
            </div>
        </div>
        <a href="../../Pages/about.html">About Us
            <span class="nav-chevron"><svg viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 1L5 5L9 1" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
        </a>
        <a href="../../Pages/contact.html">Contact Us
            <span class="nav-chevron"><svg viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 1L5 5L9 1" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
        </a>
        <a href="../../Pages/FAQ.html">FAQ
            <span class="nav-chevron"><svg viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 1L5 5L9 1" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
        </a>
    </nav>
    <div class="header-actions">
        <a href="../../Pages/account.html" class="sign-in-btn" id="sign-in-btn">Sign In</a>
        <a href="#" class="sign-in-btn" id="logout-btn" style="display:none;">Log Out</a>
        <a href="#" id="cart-icon-link" style="margin-left: -10px; display: inline-flex; align-items: center; text-decoration: none; position: relative;">
            <span class="cart-circle">
                <svg id="cart-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="10" cy="21" r="1.5"/>
                    <circle cx="18" cy="21" r="1.5"/>
                    <path d="M2.5 4H5l2.68 13.39a2 2 0 0 0 2 1.61h7.72a2 2 0 0 0 2-1.61L21.5 7H6.16"/>
                </svg>
                <span id="cart-count-badge" style="display: none; position: absolute; top: -8px; right: -8px; width: 24px; height: 24px; background: #e74c3c; color: #fff; border-radius: 50%; font-size: 1em; font-weight: bold; display: flex; align-items: center; justify-content: center; box-shadow: 0 1px 4px rgba(44,62,80,0.13); z-index: 2; text-align: center;"></span>
            </span>
        </a>
    </div>
</header>

    <!-- Sliding Cart Menu -->
    <div class="cart-overlay" id="cart-overlay">
        <div class="cart-side-menu" id="cart-side-menu" style="max-height: 100vh; overflow-y: auto;">
            <div class="cart-header" style="background:#2c3e50;color:#fff;padding:20px 0 20px 20px;display:flex;justify-content:space-between;align-items:center;">
                <h2 style="margin:0;font-size:1.5em;font-weight:700;">ðŸ›’ Cart</h2>
                <button class="cart-close-btn" id="cart-close-btn" style="background:none;border:none;color:#fff;font-size:1.5em;cursor:pointer;padding:0;width:30px;height:30px;display:flex;align-items:center;justify-content:center;border-radius:50%;transition:background 0.2s;margin-right:8px;">&times;</button>
            </div>
            <div class="cart-content" id="cart-content">
                <div class="cart-icon-large">ðŸ›’</div>
                <div class="cart-message" id="cart-message">Create an account to start shopping!</div>
                <div class="cart-description" id="cart-description">
                    To add forms to your cart and make purchases, you\'ll need to create a FormStar account. 
                    Sign up now to access our complete library of legal forms and start simplifying your paperwork.
                </div>
                <a href="../Pages/account.html" class="cart-signup-btn" id="cart-signup-btn">Sign Up</a>
                <div class="cart-items-list" id="cart-items-list" style="display:none;"></div>
                <button class="cart-checkout-btn" id="cart-checkout-btn" style="display:none;margin-top:24px;background:#2980b9;color:#fff;padding:15px 40px;font-size:1.1em;font-weight:700;border:none;border-radius:8px;cursor:pointer;">Checkout</button>
            </div>
        </div>
    </div>

<div id="pdfPreview" style="display:none;">
    <iframe id="pdfFrame" style="display:none"></iframe>
</div>

<!-- Firebase includes -->
<script src="https://js.stripe.com/v3/"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script src="cart.js"></script>

<script>
// Firebase Configuration
const firebaseConfig = {
    apiKey: "AIzaSyDS-tSSn7fdLBgwzfHQ_1MPG1w8S_4qb04",
    authDomain: "formwiz-3f4fd.firebaseapp.com",
    projectId: "formwiz-3f4fd",
    storageBucket: "formwiz-3f4fd.firebasestorage.app",
    messagingSenderId: "404259212529",
    appId: "1:404259212529:web:15a33bce82383b21cfed50",
    measurementId: "G-P07YEN0HPD"
};

// Initialize Firebase
if (typeof firebase !== "undefined" && !firebase.apps.length) {
    firebase.initializeApp(firebaseConfig);
}
const auth = firebase.auth();

// Auth state management
if (typeof firebase !== "undefined" && firebase.apps.length > 0) {
    auth.onAuthStateChanged(function(user) {
        isUserLoggedIn = !!user;
        userId = user ? user.uid : null;
        updateAuthButtons(user);
        updateCartCountBadge();
    });
} else {
    // Fallback for when Firebase is not available
}

// Function to update button display based on auth state
function updateAuthButtons(user) {
    const signInBtn = document.getElementById("sign-in-btn");
    const logoutBtn = document.getElementById("logout-btn");
    
    if (user) {
        if (signInBtn) signInBtn.style.display = "none";
        if (logoutBtn) logoutBtn.style.display = "inline-block";
    } else {
        if (signInBtn) signInBtn.style.display = "inline-block";
        if (logoutBtn) logoutBtn.style.display = "none";
    }
}

// Update cart count badge in header
function updateCartCountBadge() {
    const cartCountElement = document.getElementById("cart-count-badge");
    if (cartCountElement) {
        let count = 0;
        
        // Try to get count from getCartCount function first
        if (typeof getCartCount === "function") {
            count = getCartCount();
        } else {
            // Fallback to localStorage
            try {
                const cartData = localStorage.getItem("formwiz_cart");
                if (cartData) {
                    const cart = JSON.parse(cartData);
                    count = Array.isArray(cart) ? cart.length : 0;
                }
            } catch (e) {
                count = 0;
            }
        }
        
        // Always update the text content, even if count is 0
        cartCountElement.textContent = count;
        
        if (count > 0) {
            cartCountElement.style.display = "flex";
        } else {
            cartCountElement.style.display = "none";
        }
    }
}

// Initialize cart count badge on page load
document.addEventListener("DOMContentLoaded", function() {
    updateCartCountBadge();
    // Update cart count every 5 seconds
    setInterval(updateCartCountBadge, 5000);
});
</script>

<div style="width: 80%; max-width: 800px; margin: 20px auto; padding: 15px; border: 1px solid #ddd; border-radius: 8px; background-color: #f9f9f9; display: none;">
    <h3 style="text-align: center; margin-bottom: 15px; color: #2c3e50;">Your Information</h3>
    <div style="display: flex; gap: 15px; margin-bottom: 15px;">
        <div style="flex: 1;">
            <label for="user_firstname" style="display: block; margin-bottom: 5px; font-weight: bold;">First Name</label>
            <input type="text" form="customForm" id="user_firstname" name="user_firstname" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div style="flex: 1;">
            <label for="user_lastname" style="display: block; margin-bottom: 5px; font-weight: bold;">Last Name</label>
            <input type="text" form="customForm" id="user_lastname" name="user_lastname" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
    </div>
    <div style="margin-bottom: 15px;">
        <label for="user_email" style="display: block; margin-bottom: 5px; font-weight: bold;">Email Address</label>
        <input type="email" form="customForm" id="user_email" name="user_email" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
    </div>
    <div style="margin-bottom: 15px;">
        <label for="user_phone" style="display: block; margin-bottom: 5px; font-weight: bold;">Phone Number</label>
        <input type="tel" form="customForm" id="user_phone" name="user_phone" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
    </div>
    <div style="margin-bottom: 15px;">
        <label for="user_street" style="display: block; margin-bottom: 5px; font-weight: bold;">Street Address</label>
        <input type="text" form="customForm" id="user_street" name="user_street" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
    </div>
    <div style="display: flex; gap: 15px; margin-bottom: 15px;">
        <div style="flex: 2;">
            <label for="user_city" style="display: block; margin-bottom: 5px; font-weight: bold;">City</label>
            <input type="text" form="customForm" id="user_city" name="user_city" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div style="flex: 1;">
            <label for="user_state" style="display: block; margin-bottom: 5px; font-weight: bold;">State</label>
            <input type="text" form="customForm" id="user_state" name="user_state" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div style="flex: 1;">
            <label for="user_zip" style="display: block; margin-bottom: 5px; font-weight: bold;">ZIP</label>
            <input type="text" form="customForm" id="user_zip" name="user_zip" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
    </div>
</div>
<div id="questions">
    <div id="result"></div>
    <section>
    <div id="box">
        <form id="customForm" onsubmit="return showThankYouMessage(event);">
        <!-- Hidden fields for URL parameters -->
        <input type="hidden" id="form_zip" name="form_zip" value="">
        <input type="hidden" id="form_county" name="form_county" value="">
        <input type="hidden" id="form_defendant" name="form_defendant" value="">
        <input type="hidden" id="form_ID" name="form_ID" value="">
        <input type="hidden" id="current_date" name="current_date" value="">
        <input type="hidden" id="court_name" name="court_name" value="">
        <input type="hidden" id="court_address" name="court_address" value=""><div class="stepper-progress-bar" id="stepperProgressBar"><div class="stepper-step" data-step="1"><div class="stepper-circle">1</div><div class="stepper-label">Introduction</div></div></div><div id="section1" class="section active"><center><h1 class="section-title">Introduction</h1><div id="question-container-1" data-question-id="1" class="question-container question-item" data-section="1" data-question-index="1"><label><h3 class="question-text">Hungry?</h3></label><select id="hungry" name="hungry" data-question-id="1"
                      onchange="dropdownMirror(this, 'hungry'); updateHiddenLogic('hungry', this.value); updateLinkedFields(); clearInactiveLinkedFields(); handleLatexPreview1(this.value)">
                       <option value="" disabled selected>Select an option</option><option value="Yes">Yes</option><option value="No">No</option></select><br>
              <div id="dropdowntext_hungry"></div>
              <input type="text" id="hungry_dropdown" name="hungry_dropdown"
                   readonly style="display:none;">
              <div id="latexPreview1" style="display: none; margin-top: 20px; padding: 20px; border: 2px solid #4CAF50; border-radius: 12px; background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); box-shadow: 0 4px 12px rgba(76, 175, 80, 0.2);">
                <h4 style="margin: 0 0 15px 0; color: #2E7D32; font-size: 18px; font-weight: 600; text-align: center;">Latex PDF Preview</h4>
                <div id="latexPreviewLoading1" style="text-align: center; padding: 20px; display: none;">
                  <p style="color: #2E7D32; font-size: 16px;">Generating PDF from LaTeX...</p>
                </div>
                <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                  <iframe id="latexPreviewIframe1" width="100%" height="600px" style="border: none; border-radius: 8px;"></iframe>
                </div>
              </div>
              <script>
                async function handleLatexPreview1(value) {
                  console.log('[LATEX PREVIEW] handleLatexPreview1 called with value:', value);
                  const previewDiv = document.getElementById('latexPreview1');
                  const iframe = document.getElementById('latexPreviewIframe1');
                  const loadingDiv = document.getElementById('latexPreviewLoading1');
                  const latexContent = `\\documentclass{article}\n\n\\begin{document}\n\nHello, world!\n\n\\end{document}\n`;
                  console.log('[LATEX PREVIEW] Original LaTeX content:', latexContent);
                  console.log('[LATEX PREVIEW] Trigger value:', 'No');
                  
                  if (value === 'No') {
                    previewDiv.style.display = 'block';
                    loadingDiv.style.display = 'block';
                    iframe.style.display = 'none';
                    // Convert LaTeX to PDF
                    try {
                      // Collect all form data for placeholder replacement
                      console.log('[LATEX PREVIEW] Starting form data collection...');
                      const form = document.getElementById('customForm');
                      if (!form) {
                        console.error('[LATEX PREVIEW] ERROR: customForm element not found!');
                        throw new Error('Form element not found');
                      }
                      console.log('[LATEX PREVIEW] Form element found:', form);
                      
                      const fd = new FormData();
                      fd.append('latex', latexContent);
                      console.log('[LATEX PREVIEW] Added LaTeX content to FormData');
                      
                      // Collect all form data
                      const formElements = form.querySelectorAll('input, textarea, select');
                      const externalFormElements = document.querySelectorAll('input[form="customForm"], textarea[form="customForm"], select[form="customForm"]');
                      const allFormElements = [...formElements, ...externalFormElements];
                      console.log('[LATEX PREVIEW] Found', allFormElements.length, 'total form elements');
                      
                      let collectedFields = {};
                      allFormElements.forEach(element => {
                        if (element.name && !element.disabled) {
                          if (element.type === 'checkbox' || element.type === 'radio') {
                            if (element.checked) {
                              fd.append(element.name, 'on');
                              collectedFields[element.name] = 'on';
                            }
                          } else {
                            let value = element.value;
                            if (element.type === 'date' && value) {
                              value = formatDateForServer(value);
                            }
                            if (value && value.trim() !== '') {
                              fd.append(element.name, value);
                              collectedFields[element.name] = value;
                            }
                          }
                        }
                      });
                      
                      console.log('[LATEX PREVIEW] Collected form fields:', collectedFields);
                      console.log('[LATEX PREVIEW] Checking for user_fullname in collected fields:', 'user_fullname' in collectedFields);
                      if (collectedFields['user_fullname']) {
                        console.log('[LATEX PREVIEW] user_fullname value:', collectedFields['user_fullname']);
                      } else {
                        console.warn('[LATEX PREVIEW] WARNING: user_fullname not found in collected fields!');
                        console.log('[LATEX PREVIEW] Available field names:', Object.keys(collectedFields));
                      }
                      
                      // Log FormData contents (for debugging)
                      console.log('[LATEX PREVIEW] FormData entries:');
                      for (const [key, val] of fd.entries()) {
                        console.log('[LATEX PREVIEW]   ', key, ':', val.substring ? val.substring(0, 100) : val);
                      }
                      
                      // Send LaTeX content and form data to server endpoint to generate PDF
                      console.log('[LATEX PREVIEW] Sending request to /latex_to_pdf...');
                      const res = await fetch('/latex_to_pdf', { 
                        method: 'POST', 
                        body: fd, 
                        credentials: 'include' 
                      });
                      console.log('[LATEX PREVIEW] Response status:', res.status, res.statusText);
                      if (!res.ok) {
                        throw new Error('Failed to generate PDF from LaTeX');
                      }
                      const blob = await res.blob();
                      const url = URL.createObjectURL(blob);
                      // Display in iframe
                      iframe.src = url;
                      loadingDiv.style.display = 'none';
                      iframe.style.display = 'block';
                      // Store URL for cleanup
                      iframe.dataset.blobUrl = url;
                      
                      // Store PDF blob if "Attach to packet" is selected
                      const attachment = 'Attach to packet';
                      if (attachment === 'Attach to packet') {
                        // Initialize window.latexPdfs if it doesn't exist
                        if (!window.latexPdfs) {
                          window.latexPdfs = {};
                        }
                        // Store the blob for this question
                        window.latexPdfs[1] = blob;
                        console.log('[LATEX PREVIEW] Stored PDF blob for question 1 (Attach to packet)');
                      }
                    } catch (error) {
                      loadingDiv.innerHTML = '<p style="color: #c62828;">Failed to generate PDF from LaTeX. Please check your LaTeX code and try again.</p>';
                      iframe.style.display = 'none';
                    }
                  } else {
                    previewDiv.style.display = 'none';
                    // Clean up blob URL and remove stored PDF if exists
                    if (iframe.dataset.blobUrl) {
                      URL.revokeObjectURL(iframe.dataset.blobUrl);
                      iframe.dataset.blobUrl = '';
                      iframe.src = '';
                    }
                    // Remove stored PDF blob if user changes away from trigger
                    if (window.latexPdfs && window.latexPdfs[1]) {
                      delete window.latexPdfs[1];
                    }
                  }
                }
              </script>
            </div><div id="question-container-2" data-question-id="2" class="question-container question-item hidden question-step-hidden" data-section="1" data-question-index="2"><label><h3 class="question-text">Thirsty?</h3></label><select id="thirsty" name="thirsty" data-question-id="2"
                      onchange="dropdownMirror(this, 'thirsty'); updateHiddenLogic('thirsty', this.value); updateLinkedFields(); clearInactiveLinkedFields();">
                       <option value="" disabled selected>Select an option</option><option value="Yes">Yes</option><option value="No">No</option></select><br>
              <div id="dropdowntext_thirsty"></div>
              <input type="text" id="thirsty_dropdown" name="thirsty_dropdown"
                   readonly style="display:none;"></div>
      <div class="question-nav" data-section-index="1">
        <button type="button" class="question-nav-btn question-prev" aria-label="Previous question" data-section="1">&larr;</button>
        <button type="button" class="question-nav-btn question-next" aria-label="Next question" data-section="1">&rarr;</button>
      </div>
    <br><br><div class="navigation-buttons" style="display:none;"><button type="submit" class="next-button">Submit</button></div></div>
  <script>
    // Function to show sign-in required modal
    function showSignInRequiredModal() {
      const modal = document.getElementById('signinRequiredModal');
      if (modal) {
        modal.style.display = 'flex';
        // Close modal when clicking outside
        modal.addEventListener('click', function(e) {
          if (e.target === modal) {
            modal.style.display = 'none';
          }
        });
      }
    }

    // Function to hide sign-in required modal
    function hideSignInRequiredModal() {
      const modal = document.getElementById('signinRequiredModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // Function to check if user is logged in before navigation
    function checkAuthBeforeNavigate(callback) {
      // Check if isUserLoggedIn is defined (Firebase auth might not be loaded yet)
      if (typeof isUserLoggedIn === 'undefined') {
        // Wait a bit for Firebase auth to initialize
        setTimeout(function() {
          if (typeof isUserLoggedIn !== 'undefined' && isUserLoggedIn) {
            if (callback) callback();
          } else {
            showSignInRequiredModal();
          }
        }, 500);
      } else if (isUserLoggedIn) {
        if (callback) callback();
      } else {
        showSignInRequiredModal();
      }
    }

    document.addEventListener('DOMContentLoaded', function() {
      console.groupCollapsed('[NAV DEBUG] form boot');
      const qtMap = (typeof questionTypesMap !== 'undefined') ? questionTypesMap : (window.questionTypesMap || {});

      console.groupEnd();
      const sectionNodeList = document.querySelectorAll('[id^="section"]');
      const sectionElements = Array.from(sectionNodeList);
      const sectionNumbers = sectionElements.map(sectionEl => {
        const match = sectionEl.id && sectionEl.id.match(/^section(\d+)$/);
        return match ? parseInt(match[1], 10) : null;
      });
      if (!window.questionNavControllers) {
        window.questionNavControllers = {};
      }
      sectionElements.forEach(function(sectionEl, sectionIdx) {
        const questionItems = Array.from(sectionEl.querySelectorAll('.question-container.question-item'));
        const navWrapper = sectionEl.querySelector('.question-nav');
        if (!questionItems.length || !navWrapper) {
          return;
        }
        const sectionId = sectionEl.id;
        const currentSectionNumber = sectionNumbers[sectionIdx] || (sectionIdx + 1);
        const prevBtn = navWrapper.querySelector('.question-prev');
        const nextBtn = navWrapper.querySelector('.question-next');
        const progressCurrent = navWrapper.querySelector('.question-current');
        const progressTotal = navWrapper.querySelector('.question-total');
        function getVisibleIndices() {
          const indices = [];
          questionItems.forEach(function(item, idx) {
            if (!item.classList.contains('hidden')) {
              indices.push(idx);
            }
          });
          return indices;
        }
        function getVisibleIndicesForSectionElement(targetSectionEl) {
          const items = Array.from(targetSectionEl.querySelectorAll('.question-container.question-item'));
          const indices = [];
          items.forEach(function(item, idx) {
            // Only exclude questions that have the 'hidden' class
            // Questions without the 'hidden' class should be considered visible
            // even if their parent section is not active (they'll become visible when section activates)
            const hasHiddenClass = item.classList.contains('hidden');
            if (!hasHiddenClass) {
              indices.push(idx);

            } else {

            }
          });

          return { indices, items };
        }
        function findNextSectionWithVisibleQuestions() {

          for (let nextIdx = sectionIdx + 1; nextIdx < sectionElements.length; nextIdx++) {
            const candidateSection = sectionElements[nextIdx];

            const visibleInfo = getVisibleIndicesForSectionElement(candidateSection);

            // If we find visible questions, return immediately
            if (visibleInfo.indices.length) {
              const result = {
                sectionEl: candidateSection,
                sectionId: candidateSection.id,
                sectionNumber: sectionNumbers[nextIdx] || (nextIdx + 1),
                firstVisibleIndex: visibleInfo.indices[0]
              };

              return result;
            }
            // If no visible questions found, check if section has any questions at all
            // This handles cases where questions might be hidden initially but should become visible
            const allQuestions = candidateSection.querySelectorAll('.question-container.question-item');
            if (allQuestions.length > 0) {

              const result = {
                sectionEl: candidateSection,
                sectionId: candidateSection.id,
                sectionNumber: sectionNumbers[nextIdx] || (nextIdx + 1),
                firstVisibleIndex: 0  // Will be recalculated when section becomes active
              };

              return result;
            }
          }

          return null;
        }
        function findPrevSectionWithVisibleQuestions() {
          for (let prevIdx = sectionIdx - 1; prevIdx >= 0; prevIdx--) {
            const candidateSection = sectionElements[prevIdx];
            const visibleInfo = getVisibleIndicesForSectionElement(candidateSection);
            if (visibleInfo.indices.length) {
              return {
                sectionEl: candidateSection,
                sectionId: candidateSection.id,
                sectionNumber: sectionNumbers[prevIdx] || (prevIdx + 1),
                lastVisibleIndex: visibleInfo.indices[visibleInfo.indices.length - 1]
              };
            }
          }
          return null;
        }
        let activeIndex = -1;
        let isUpdating = false;
        let cachedNextSectionInfo = null;
        let cachedPrevSectionInfo = null;
        function isElementEligible(el) {
          if (!el || el.disabled) return false;
          if (el.type === 'hidden') return false;
          if (el.closest('.hidden')) return false;
          // Check if element or any parent has display: none
          let current = el;
          while (current && current !== document.body) {
            const style = window.getComputedStyle(current);
            if (style.display === 'none') {
              return false;
            }
            current = current.parentElement;
          }
          // Also check offsetParent for elements that are not radio/checkbox
          if (el.offsetParent === null && el.type !== 'radio' && el.type !== 'checkbox') return false;
          return true;
        }
        function isQuestionAnswered(container) {
          if (!container) {

            return false;
          }
          const questionId = container.getAttribute('data-question-id') || container.id || 'unknown';
          const questionTextEl = container.querySelector('.question-text');
          const questionText = questionTextEl ? questionTextEl.textContent.trim() : '';

          const elements = Array.from(container.querySelectorAll('select, textarea, input'));
          const eligibleElements = elements.filter(isElementEligible);
          const debugElements = eligibleElements.map(el => ({
            id: el.id || null,
            tag: el.tagName,
            type: (el.type || '').toLowerCase(),
            value: (el.type === 'checkbox' || el.type === 'radio') ? el.checked : (el.value || '').trim(),
            display: el.style && el.style.display ? el.style.display : null
          }));

          // Check for file upload questions BEFORE early return (file inputs are hidden, so they won't be in eligibleElements)
          const fileUploadInput = container.querySelector('input[type="file"][id^="fileUpload_"]');

          if (fileUploadInput) {

            // This is a file upload question - don't return early, continue to file upload validation below
          } else if (!eligibleElements.length) {

            return true;
          }
          let allStandardSatisfied = true;
          const radioGroups = {};
          let hasCheckbox = false;
          let checkboxAnyChecked = false;
          eligibleElements.forEach(el => {
            const tag = el.tagName;
            const type = (el.type || '').toLowerCase();
            if (tag === 'SELECT') {
              const value = (el.value || '').trim();

              if (!value) allStandardSatisfied = false;
            } else if (tag === 'TEXTAREA' || type === 'text' || type === 'email' || type === 'tel' || type === 'url' || type === 'number' || type === 'date' || type === 'time' || type === 'datetime-local') {
              const value = (el.value || '').trim();

              if (!value) allStandardSatisfied = false;
            } else if (type === 'radio') {
              const group = radioGroups[el.name || el.id] || [];
              group.push(!!el.checked);
              radioGroups[el.name || el.id] = group;
            } else if (type === 'checkbox') {
              hasCheckbox = true;
              if (el.checked) {
                checkboxAnyChecked = true;
              }
            }
          });
          const radiosSatisfied = Object.values(radioGroups).every(group => group.some(Boolean));
          // Use explicit hasOwnProperty so missing entries default to optional
          const checkboxRequired = Object.prototype.hasOwnProperty.call(checkboxRequiredMap, questionId)
            ? checkboxRequiredMap[questionId]
            : false;
          // Check if "all are required" is enabled
          const allAreRequired = Object.prototype.hasOwnProperty.call(allAreRequiredMap, questionId)
            ? allAreRequiredMap[questionId]
            : false;

          let checkboxesSatisfied = true;
          if (hasCheckbox && checkboxRequired) {
            if (allAreRequired) {
              // When "all are required" is enabled, all main checkbox options must be checked
              // Get all checkboxes that are part of the main question (not in trigger containers)
              // Look for checkboxes in the checkbox-group class for this question
              const checkboxGroup = container.querySelector('.checkbox-group-' + questionId);
              if (checkboxGroup) {
                // Get all checkboxes in the main checkbox group (excluding "None of the above")
                const mainCheckboxes = Array.from(checkboxGroup.querySelectorAll('input[type="checkbox"]')).filter(cb => {
                  const cbId = cb.id || '';
                  const cbName = cb.name || '';
                  // Exclude "None of the above" checkbox and hidden checkboxes
                  return !cbId.includes('none_of_the_above') && 
                         !cbId.includes('_hidden') &&
                         cb.style.display !== 'none' &&
                         isElementEligible(cb);
                });
                // Check if all main checkboxes are checked
                const allChecked = mainCheckboxes.length > 0 && mainCheckboxes.every(cb => cb.checked);
                checkboxesSatisfied = allChecked;
              } else {
                // Fallback: use eligibleElements that are checkboxes
                const mainCheckboxes = eligibleElements.filter(el => {
                  const type = (el.type || '').toLowerCase();
                  if (type !== 'checkbox') return false;
                  const cbId = el.id || '';
                  // Exclude "None of the above" and checkboxes in trigger containers
                  const isInTriggerContainer = el.closest('[id^="triggerFields_"]') !== null;
                  return !cbId.includes('none_of_the_above') && !isInTriggerContainer;
                });
                const allChecked = mainCheckboxes.length > 0 && mainCheckboxes.every(cb => cb.checked);
                checkboxesSatisfied = allChecked;
              }
            } else {
              // Standard behavior: at least one checkbox must be checked
              checkboxesSatisfied = checkboxAnyChecked;
            }
          } else if (hasCheckbox && !checkboxRequired) {
            // Optional checkbox question - always satisfied
            checkboxesSatisfied = true;
          } else if (!hasCheckbox) {
            // No checkboxes - always satisfied
            checkboxesSatisfied = true;
          }

          // Additional check: if any trigger sequence container is visible, its fields become required
          const visibleTriggerContainers = Array.from(container.querySelectorAll('[id^="triggerFields_"]')).filter(tc => window.getComputedStyle(tc).display !== 'none');
          if (visibleTriggerContainers.length > 0) {

            visibleTriggerContainers.forEach(tc => {
              const triggerInputs = tc.querySelectorAll('select, textarea, input');
              triggerInputs.forEach(inp => {
                if (!isElementEligible(inp)) return;
                const tag = inp.tagName;
                const type = (inp.type || '').toLowerCase();
                if (tag === 'SELECT') {
                  const value = (inp.value || '').trim();
                  if (!value) allStandardSatisfied = false;
                } else if (tag === 'TEXTAREA' || type === 'text' || type === 'email' || type === 'tel' || type === 'url' || type === 'number' || type === 'date' || type === 'time' || type === 'datetime-local') {
                  const value = (inp.value || '').trim();
                  if (!value) allStandardSatisfied = false;
                } else if (type === 'radio') {
                  const group = radioGroups[inp.name || inp.id] || [];
                  group.push(!!inp.checked);
                  radioGroups[inp.name || inp.id] = group;
                } else if (type === 'checkbox') {
                  hasCheckbox = true;
                  if (inp.checked) {
                    checkboxAnyChecked = true;
                  }
                }
              });
            });
          }

          // Check for file upload questions - verify a file has been uploaded (fileUploadInput already found above)
          let fileUploadSatisfied = true;

          if (fileUploadInput) {
            const fileInputId = fileUploadInput.id;

            // Extract questionId from the file input ID (format: "fileUpload_123")
            // Use [0-9] instead of \d to avoid template literal escaping issues
            const fileQuestionIdMatch = fileInputId.match(/fileUpload_([0-9]+)/);

            if (fileQuestionIdMatch) {
              const fileQuestionId = fileQuestionIdMatch[1];

              // Check if a file has been uploaded for this question
              const hasUploadedFile = window.uploadedFiles && window.uploadedFiles[fileQuestionId];

              fileUploadSatisfied = !!hasUploadedFile;

              if (!fileUploadSatisfied) {

              } else {

              }
            } else {

            }
          } else {

          }

          const answered = allStandardSatisfied && radiosSatisfied && checkboxesSatisfied && fileUploadSatisfied;

          return answered;
        }
        function answerTriggersEnd(container) {
          if (!container || !Array.isArray(jumpLogics) || !jumpLogics.length) {
            return false;
          }
          const containerId = ((container.id || '') + '').trim();
          const dataQuestionId = container.getAttribute('data-question-id');
          let questionId = dataQuestionId ? String(dataQuestionId).trim() : null;
          if (!questionId && containerId.startsWith('question-container-')) {
            questionId = containerId.substring('question-container-'.length).trim();
          }
          if (!questionId) {
            return false;
          }
          const relevantJumps = jumpLogics.filter(jl => jl.questionId === questionId && typeof jl.jumpTo === 'string' && jl.jumpTo.toLowerCase() === 'end');
          if (!relevantJumps.length) return false;

          // Check for "Any Text" jump option first - this applies to textareas and text inputs
          const hasAnyTextJump = relevantJumps.some(jl => {
            const jumpOption = String(jl.jumpOption || '').trim().toLowerCase();
            return jumpOption === 'any text' || jumpOption === 'any amount' || jumpOption === 'any date';
          });

          if (hasAnyTextJump) {
            // For "Any Text", check if any textarea or text input has content
            const textElements = container.querySelectorAll('textarea, input[type="text"], input[type="email"], input[type="tel"], input[type="url"], input[type="number"], input[type="date"], input[type="time"], input[type="datetime-local"]');
            for (const el of textElements) {
              if (el.value && el.value.trim()) {
                return true;
              }
            }
            return false;
          }

          // For dropdown/radio/checkbox questions, check their values
          const interactiveElements = container.querySelectorAll('select, input[type="radio"], input[type="checkbox"]');
          const currentAnswers = [];
          interactiveElements.forEach(el => {
            if (el.tagName === 'SELECT') {
              if (el.value) currentAnswers.push(el.value);
            } else if (el.type === 'radio') {
              if (el.checked) currentAnswers.push(el.value || 'true');
            } else if (el.type === 'checkbox') {
              if (el.checked) currentAnswers.push(el.value || 'true');
            }
          });
          if (!currentAnswers.length) {
            return false;
          }
          const normalizedAnswers = currentAnswers.map(val => String(val).trim().toLowerCase());
          for (const jl of relevantJumps) {
            const jumpOption = String(jl.jumpOption || '').trim().toLowerCase();
            if (jumpOption && normalizedAnswers.includes(jumpOption)) {
              return true;
            }
          }
          return false;
        }
        function attachSubmitModeListeners(container, containerIdx) {
          if (!container || container.dataset.submitModeListenersAttached === 'true') {

            return;
          }
          const questionId = container.getAttribute('data-question-id') || container.id || 'unknown';
          const questionTextEl = container.querySelector('.question-text');
          const questionText = questionTextEl ? questionTextEl.textContent.trim() : '';

          // Use event delegation - attach listeners to container to catch events from dynamically created fields
          container.addEventListener('change', function(event) {
            const target = event.target;

            // Only handle interactive elements
            if (target.tagName === 'SELECT' || target.type === 'radio' || target.type === 'checkbox') {
              // Make sure the element is within this container
              if (container.contains(target)) {

                refreshNav(containerIdx);
              } else {

              }
            }
          });
          container.addEventListener('input', function(event) {
            const target = event.target;
            const isTextarea = target.tagName === 'TEXTAREA';
            const isTextInput = target.tagName === 'INPUT' && ['text', 'email', 'tel', 'url', 'number', 'date', 'time', 'datetime-local'].includes(target.type);

            // Only handle text-like inputs
            if (isTextarea || isTextInput) {
              // Make sure the element is within this container
              if (container.contains(target)) {

                refreshNav(containerIdx);
              } else {

              }
            } else {

            }
          });
          container.dataset.submitModeListenersAttached = 'true';

        }
        function updateButtons(hasPrevQuestion, canAdvanceWithinSection, canAdvanceAcrossSection, nextSectionInfo, prevSectionInfo, submitConfig) {
          const shouldSubmit = submitConfig && submitConfig.shouldSubmit;
          const isAnswered = submitConfig && submitConfig.isAnswered;
          const currentQuestionId = submitConfig && submitConfig.questionId;
          const currentQuestionText = submitConfig && submitConfig.questionText;
          const currentPos = submitConfig && typeof submitConfig.currentPos === 'number' ? submitConfig.currentPos : -1;
          const visibleTotal = submitConfig && typeof submitConfig.visibleTotal === 'number' ? submitConfig.visibleTotal : 0;
          const isLastQuestion = currentPos === visibleTotal - 1;

          if (prevBtn) {
            const canGoBack = !!(hasPrevQuestion || prevSectionInfo);
            prevBtn.disabled = !canGoBack;

            if (!canGoBack) {
              prevBtn.dataset.advanceMode = '';
              delete prevBtn.dataset.prevSectionNumber;
              delete prevBtn.dataset.prevSectionId;
            } else if (hasPrevQuestion) {
              prevBtn.dataset.advanceMode = 'question';
              delete prevBtn.dataset.prevSectionNumber;
              delete prevBtn.dataset.prevSectionId;
            } else {
              prevBtn.dataset.advanceMode = 'section';
              if (prevSectionInfo) {
                prevBtn.dataset.prevSectionNumber = String(prevSectionInfo.sectionNumber);
                prevBtn.dataset.prevSectionId = prevSectionInfo.sectionId;
              }
            }
          }
          if (nextBtn) {

            if (shouldSubmit) {
              // Use removeAttribute/setAttribute to ensure the disabled state is properly applied
              if (isAnswered) {
                nextBtn.removeAttribute('disabled');
              } else {
                nextBtn.setAttribute('disabled', 'disabled');
              }

              nextBtn.dataset.advanceMode = 'submit';
              delete nextBtn.dataset.nextSectionNumber;
              delete nextBtn.dataset.nextSectionId;
              nextBtn.classList.add('submit-mode');

            } else {
              nextBtn.classList.remove('submit-mode');
              // Allow advancing if: can advance within section, can advance across sections, OR we're on the last question and it's answered (to allow submit/end)
              const canAdvance = isAnswered && !!(canAdvanceWithinSection || canAdvanceAcrossSection || (isLastQuestion && isAnswered));

              // Use removeAttribute/setAttribute to ensure the disabled state is properly applied
              if (canAdvance) {
                nextBtn.removeAttribute('disabled');
              } else {
                nextBtn.setAttribute('disabled', 'disabled');
              }

              if (!canAdvance) {
                nextBtn.dataset.advanceMode = '';
                delete nextBtn.dataset.nextSectionNumber;
                delete nextBtn.dataset.nextSectionId;
              } else if (canAdvanceWithinSection) {
                nextBtn.dataset.advanceMode = 'question';
                delete nextBtn.dataset.nextSectionNumber;
                delete nextBtn.dataset.nextSectionId;
              } else {
                nextBtn.dataset.advanceMode = 'section';
                if (nextSectionInfo) {
                  nextBtn.dataset.nextSectionNumber = String(nextSectionInfo.sectionNumber);
                  nextBtn.dataset.nextSectionId = nextSectionInfo.sectionId;
                }
              }
            }

          }
        }
        function activateIndex(targetIdx) {
          if (isUpdating) return;
          isUpdating = true;
          const visibleIndices = getVisibleIndices();
          if (!visibleIndices.length) {
            questionItems.forEach(function(item) {
              item.classList.add('question-step-hidden');
            });
            if (progressCurrent) {
              progressCurrent.textContent = '0';
            }
            if (progressTotal) {
              progressTotal.textContent = String(questionItems.length);
            }
            if (prevBtn) {
              prevBtn.disabled = true;
            }
            if (nextBtn) {
              nextBtn.disabled = true;
            }
            activeIndex = -1;
            isUpdating = false;
            return;
          }
          if (visibleIndices.indexOf(targetIdx) === -1) {
            targetIdx = visibleIndices[0];
          }
          questionItems.forEach(function(item, idx) {
            if (idx === targetIdx && !item.classList.contains('hidden')) {
              item.classList.remove('question-step-hidden');
            } else {
              item.classList.add('question-step-hidden');
            }
          });
          const currentPos = visibleIndices.indexOf(targetIdx);
          const position = currentPos + 1;
          const visibleTotal = visibleIndices.length;
          const displayTotal = questionItems.length;
          if (progressCurrent) {
            progressCurrent.textContent = String(position > 0 ? position : 0);
          }
          if (progressTotal) {
            progressTotal.textContent = String(displayTotal);
          }
          const activeContainer = questionItems[targetIdx];
          const activeQuestionId = activeContainer ? (activeContainer.getAttribute('data-question-id') || activeContainer.id || 'unknown') : 'unknown';
          const activeQuestionTextEl = activeContainer ? activeContainer.querySelector('.question-text') : null;
          const activeQuestionText = activeQuestionTextEl ? activeQuestionTextEl.textContent.trim() : '';
          attachSubmitModeListeners(activeContainer, targetIdx);
          const shouldSubmit = answerTriggersEnd(activeContainer);
          const isAnswered = isQuestionAnswered(activeContainer);
          const hasPrevQuestion = currentPos > 0;

          cachedNextSectionInfo = shouldSubmit ? null : findNextSectionWithVisibleQuestions();
          cachedPrevSectionInfo = findPrevSectionWithVisibleQuestions();

          const canAdvanceAcrossSection = shouldSubmit ? false : !!cachedNextSectionInfo;
          // Allow advancing within section if there's a next question in the current section
          const canAdvanceWithinSection = isAnswered && (!shouldSubmit) && currentPos !== -1 && currentPos < visibleTotal - 1;

          // If we're on the last question and can't advance within section, but can advance across sections, log it for debugging
          if (isAnswered && !shouldSubmit && currentPos === visibleTotal - 1 && !canAdvanceWithinSection) {

          }

          updateButtons(
            hasPrevQuestion,
            canAdvanceWithinSection,
            canAdvanceAcrossSection,
            cachedNextSectionInfo,
            cachedPrevSectionInfo,
            { shouldSubmit, isAnswered, questionId: activeQuestionId, questionText: activeQuestionText, currentPos, visibleTotal }
          );
          activeIndex = targetIdx;
          isUpdating = false;
        }
        function goToNextSection() {

          // Check authentication before moving to next section
          if (typeof isUserLoggedIn === 'undefined' || !isUserLoggedIn) {

            if (typeof showSignInRequiredModal === 'function') {
              showSignInRequiredModal();
            }
            return;
          }

          if (!cachedNextSectionInfo) {

            return;
          }
          const targetSectionId = cachedNextSectionInfo.sectionId;
          const targetSectionNumber = cachedNextSectionInfo.sectionNumber;

          const triggerNavigation = () => {

            if (typeof validateAndProceed === 'function') {

              const validationResult = validateAndProceed(currentSectionNumber);

              // If validation fails, still try to navigate directly
              if (!validationResult) {

                if (typeof navigateSection === 'function') {
                  navigateSection(targetSectionNumber);
                }
              }
            } else if (typeof navigateSection === 'function') {

              navigateSection(targetSectionNumber);
            } else {

            }
          };
          const updateTargetNav = () => {

            const activeSection = document.querySelector('.section.active');

            if (activeSection && activeSection.id === targetSectionId) {
              if (window.questionNavControllers && typeof window.questionNavControllers[targetSectionId] === 'function') {

                window.questionNavControllers[targetSectionId]();
              } else {

              }
            } else {

            }
          };
          triggerNavigation();
          setTimeout(updateTargetNav, 0);
        }
        function goToPrevSection() {
          if (!cachedPrevSectionInfo) {
            return;
          }
          const targetSectionId = cachedPrevSectionInfo.sectionId;
          const targetSectionNumber = cachedPrevSectionInfo.sectionNumber;
          const targetQuestionIndex = cachedPrevSectionInfo.lastVisibleIndex;
          // Use goBack() if we have navigation history (stack), otherwise use direct navigation
          // This ensures jumps are properly handled when going back
          const triggerNavigation = () => {
            // Check if we have a stack entry - if so, use goBack() to respect jump history
            if (typeof sectionStack !== 'undefined' && Array.isArray(sectionStack) && sectionStack.length > 0) {
              if (typeof goBack === 'function') {
                goBack();
                // After going back, update the target navigation if needed
                setTimeout(() => {
                  const activeSection = document.querySelector('.section.active');
                  if (activeSection && activeSection.id === targetSectionId) {
                    if (window.questionNavControllers && typeof window.questionNavControllers[targetSectionId] === 'function') {
                      window.questionNavControllers[targetSectionId](targetQuestionIndex);
                    }
                  }
                }, 100);
              }
            } else {
              // No stack history, use direct navigation
              if (typeof navigateSection === 'function') {
                navigateSection(targetSectionNumber);
              } else if (typeof validateAndProceed === 'function') {
                navigateSection(targetSectionNumber);
              }
              const updateTargetNav = () => {
                const activeSection = document.querySelector('.section.active');
                if (activeSection && activeSection.id === targetSectionId) {
                  if (window.questionNavControllers && typeof window.questionNavControllers[targetSectionId] === 'function') {
                    window.questionNavControllers[targetSectionId](targetQuestionIndex);
                  }
                }
              };
              setTimeout(updateTargetNav, 0);
            }
          };
          triggerNavigation();
        }
        function shiftQuestion(direction) {

          const visibleIndices = getVisibleIndices();

          if (!visibleIndices.length || activeIndex === -1) {

            if (direction > 0 && cachedNextSectionInfo) {

              goToNextSection();
            } else if (direction < 0 && cachedPrevSectionInfo) {

              goToPrevSection();
            } else {

            }
            return;
          }
          const currentPos = visibleIndices.indexOf(activeIndex);

          if (direction > 0) {
            // Check authentication before moving forward
            if (typeof isUserLoggedIn === 'undefined' || !isUserLoggedIn) {

              if (typeof showSignInRequiredModal === 'function') {
                showSignInRequiredModal();
              }
              return;
            }
            const activeContainer = questionItems[activeIndex];
            const isAnswered = activeContainer ? isQuestionAnswered(activeContainer) : false;

            if (activeContainer && !isAnswered) {

              return;
            }
          }
          const nextPos = currentPos + direction;

          if (nextPos < 0 || nextPos >= visibleIndices.length) {

            if (direction > 0) {
              // If we're going forward and at the end, try to find next section
              if (cachedNextSectionInfo) {

                goToNextSection();
              } else {
                // Re-check for next section in case cache is stale

                const freshNextSectionInfo = findNextSectionWithVisibleQuestions();
                if (freshNextSectionInfo) {

                  cachedNextSectionInfo = freshNextSectionInfo;
                  goToNextSection();
                } else {
                  // Last resort: if there's a next section element, navigate to it anyway
                  const nextSectionIdx = sectionIdx + 1;
                  if (nextSectionIdx < sectionElements.length) {
                    const nextSection = sectionElements[nextSectionIdx];

                    cachedNextSectionInfo = {
                      sectionEl: nextSection,
                      sectionId: nextSection.id,
                      sectionNumber: sectionNumbers[nextSectionIdx] || (nextSectionIdx + 1),
                      firstVisibleIndex: 0
                    };
                    goToNextSection();
                  } else {

                  }
                }
              }
            } else if (direction < 0 && cachedPrevSectionInfo) {

              goToPrevSection();
            } else {

            }
            return;
          }

          activateIndex(visibleIndices[nextPos]);
        }
        function refreshNav(targetIdx) {

          const visibleIndices = getVisibleIndices();

          if (!visibleIndices.length) {
            // If no visible questions found, try to show the first question anyway
            // This handles cases where questions don't have the 'hidden' class but might be hidden by CSS

            if (questionItems.length > 0) {
              const firstQuestion = questionItems[0];
              if (firstQuestion) {
                // Remove both question-step-hidden AND hidden classes to ensure question is visible
                firstQuestion.classList.remove('question-step-hidden');
                firstQuestion.classList.remove('hidden');

              }
            }
            activateIndex(0);
            return;
          }
          if (typeof targetIdx !== 'number' || visibleIndices.indexOf(targetIdx) === -1) {
            const currentVisibleIdx = visibleIndices.indexOf(activeIndex);

            if (currentVisibleIdx === -1) {

              activateIndex(visibleIndices[0]);
            } else {

              activateIndex(activeIndex);
            }
            return;
          }

          activateIndex(targetIdx);
        }
        if (prevBtn) {
          prevBtn.addEventListener('click', function() {
            shiftQuestion(-1);
          });
        }
        if (nextBtn) {
          nextBtn.addEventListener('click', function() {

            if (nextBtn.dataset.advanceMode === 'submit') {

              // Check authentication before submitting
              checkAuthBeforeNavigate(function() {

                const formEl = document.getElementById('customForm');
                if (formEl) {
                  if (typeof formEl.requestSubmit === 'function') {
                    formEl.requestSubmit();
                  } else {
                    formEl.submit();
                  }
                }
              });
              return;
            }

            // Check authentication before navigating
            checkAuthBeforeNavigate(function() {

              shiftQuestion(1);
            });
          });
        }
        const observer = new MutationObserver(function(mutations) {
          if (isUpdating) return;
          let shouldUpdate = false;
          mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
              const oldClasses = mutation.oldValue || '';
              const newClasses = mutation.target.className || '';
              if (oldClasses.includes('hidden') !== newClasses.includes('hidden')) {
                shouldUpdate = true;
              }
            }
          });
          if (shouldUpdate) {
            refreshNav(activeIndex === -1 ? 0 : activeIndex);
          }
        });
        questionItems.forEach(function(item) {
          observer.observe(item, { 
            attributes: true, 
            attributeFilter: ['class'],
            attributeOldValue: true
          });
        });
        document.addEventListener('questionVisibilityChanged', function(evt) {
          if (!evt || !evt.detail || !evt.detail.sectionId || evt.detail.sectionId === sectionId) {
            refreshNav();
          }
        });
        window.questionNavControllers[sectionId] = refreshNav;
        const visibleIndices = getVisibleIndices();
        const initialIndex = visibleIndices.length ? visibleIndices[0] : 0;
        activateIndex(initialIndex);
      });
      // --- Fallback visibility enforcement for Q3 based on JSON logic (Q1 yes OR any text in Q2) ---
      (function attachQ3FallbackLogic(){
        const q1 = document.getElementById('have_you_sent_a_demand_letter_to_the_defendant') || document.getElementById('answer1');
        const q2 = document.getElementById('explain_why_you_have_not_sent_a_demand_letter_yet') || document.getElementById('answer2');
        const q3Container = document.getElementById('question-container-3');
        const refreshNavForQ3 = () => {
          const activeSection = document.querySelector('.section.active');
          if (activeSection && window.questionNavControllers) {
            const controller = window.questionNavControllers[activeSection.id];
            if (typeof controller === 'function') controller();
          }
        };
        const recompute = () => {
          if (!q3Container) return;
          const q1Val = (q1 && q1.value || '').trim().toLowerCase();
          const q2Val = (q2 && q2.value || '').trim();
          const shouldShow = q1Val === 'yes' || q2Val.length > 0;

          if (shouldShow) {
            q3Container.classList.remove('hidden');
          } else {
            q3Container.classList.add('hidden');
          }
          document.dispatchEvent(new CustomEvent('questionVisibilityChanged',{detail:{sectionId: q3Container.closest('[id^="section"]')?.id || null}}));
          refreshNavForQ3();
        };
        if (q1) q1.addEventListener('change', recompute);
        if (q2) q2.addEventListener('input', recompute);
        recompute();
      })();
      // Global shortcut: Shift+Enter â†’ click the visible "next" arrow
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && e.shiftKey) {
          e.preventDefault();
          const activeSection = document.querySelector('.section.active');
          const nextBtn = activeSection ? activeSection.querySelector('.question-next') : null;

          if (nextBtn) {
            nextBtn.click();
          }
        }
      });
      // Global shortcut: Ctrl+CapsLock â†’ click the visible "previous" arrow
      document.addEventListener('keydown', function(e) {
        if (e.key === 'CapsLock' && e.ctrlKey) {
          e.preventDefault();
          const activeSection = document.querySelector('.section.active');
          const prevBtn = activeSection ? activeSection.querySelector('.question-prev') : null;

          if (prevBtn) {
            prevBtn.click();
          }
        }
      });
    });
  </script>
  <div id="hidden_pdf_fields">
<input type="hidden" id="user_firstname_hidden" name="user_firstname_hidden">
<input type="hidden" id="user_lastname_hidden"  name="user_lastname_hidden">
<input type="hidden" id="user_fullname"         name="user_fullname">
<input type="hidden" id="user_email_hidden"     name="user_email_hidden">
<input type="hidden" id="user_phone_hidden"     name="user_phone_hidden">
<input type="hidden" id="user_street_hidden"    name="user_street_hidden">
<input type="hidden" id="user_city_hidden"      name="user_city_hidden">
<input type="hidden" id="user_state_hidden"     name="user_state_hidden">
<input type="hidden" id="user_zip_hidden"       name="user_zip_hidden">
<input type="hidden" id="user_full_address"     name="user_full_address">
<input type="hidden" id="user_full_address_hidden" name="user_full_address_hidden">
<input type="checkbox" id="example_form_default_checkbox" name="example_form_default_checkbox" checked style="display: none;">
</div>
  <script>
    window.showLoginRequiredModal = function() {
      const modal = document.getElementById('loginRequiredModal');
      if (modal) {
        modal.style.display = 'flex';
      }
    };
    window.hideLoginRequiredModal = function() {
      const modal = document.getElementById('loginRequiredModal');
      if (modal) {
        modal.style.display = 'none';
      }
    };
  </script>
  </form>
<div id="thankYouMessage" class="thank-you-message" style="display: none;">Thank you for completing the survey<br><br><button onclick="downloadAllPdfs()" style="font-size: 1.2em;">Download PDF</button><br><br><button onclick="showPreviewPdfsModal()" style="font-size: 1.2em;">Preview PDFs</button><br><br><div id="checklistDisplay" style="margin: 20px 0; padding: 20px; background: #f8faff; border: 2px solid #2980b9; border-radius: 10px; display: none;"><h3 style="color: #2c3e50; margin-bottom: 15px;">ðŸ“‹ Your Personalized Checklist</h3><div id="checklistItems"></div></div><button onclick="showCartModal()" style="font-size: 1.2em;">Continue</button><br><br><button onclick="goBackToForm()" style="font-size: 1.2em;">Back</button><br><br><button onclick="window.location.href='../Pages/forms.html'" style="font-size: 1.2em;">Exit Survey</button></div>
</div>
</section>
</div>
<!-- PDF Preview Modals -->
<style>
.modal { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); z-index: 9999; display: flex; justify-content: center; align-items: center; }
.modal-content { background-color: #fff; border-radius: 8px; padding: 20px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); position: relative; }
#previewPdfsListModal .modal-content { max-width: 600px; max-height: 80vh; overflow-y: auto; padding: 30px; }
#previewPdfFullscreenModal .modal-content { width: 98vw; max-width: 1600px; max-height: 98vh; padding: 0; }
</style>
<div id="previewPdfsListModal" class="modal" style="display: none; z-index: 10000;" onclick="if(event.target === this) closePreviewPdfsListModal();">
  <div class="modal-content" onclick="event.stopPropagation();">
    <span class="close" onclick="closePreviewPdfsListModal()" style="position: absolute; top: 10px; right: 18px; font-size: 2rem; font-weight: bold; color: #333; cursor: pointer; z-index: 10;">&times;</span>
    <h2 style="margin-top: 0; color: #2c3e50;">Available PDFs</h2>
    <div id="previewPdfsList" style="margin-top: 20px;"></div>
  </div>
</div>
<div id="previewPdfFullscreenModal" class="modal" style="display: none; z-index: 10001;" onclick="if(event.target === this) closePreviewPdfFullscreen();">
  <div class="modal-content" onclick="event.stopPropagation();">
    <span class="close" onclick="closePreviewPdfFullscreen()" style="position: absolute; top: 10px; right: 18px; font-size: 2rem; font-weight: bold; color: #fff; cursor: pointer; z-index: 10; background: rgba(0,0,0,0.5); border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;">&times;</span>
    <iframe id="previewPdfIframe" style="width: 100%; height: 98vh; border: none;"></iframe>
  </div>
</div>
<div class="pro-footer">
        <div class="pro-footer-col address-col">
            <div class="pro-footer-logo">
                <img src="logo.png" alt="FormStar Logo" style="max-width:120px;max-height:80px;">
            </div>
            <div class="pro-footer-title">FormStar</div>
            <div class="pro-footer-contact">
                <a href="tel:18884108370">1-888-410-8370</a> &nbsp; 
                <a href="mailto:info@rdr-gp.com">info@rdr-gp.com</a>
            </div>
        </div>
        <div class="pro-footer-col nav-col">
            <div class="pro-footer-title">Navigation</div>
            <a href="index.html">Home</a>
            <a href="../Pages/FreeForm.html">Forms</a>
            <a href="../Pages/FAQ.html">FAQ</a>
            <a href="../Pages/about.html">About Us</a>
            <a href="../Pages/contact.html">Contact Us</a>
        </div>
        <div class="pro-footer-col company-col">
            <div class="pro-footer-title company-title">About FormStar</div>
            <div class="pro-footer-desc">FormStar consists of a group of proven professionals with over 70 years of combined technical, operational and administrative service experience within the non-profit, private, and public sectors. We simplify legal paperwork for everyone.</div>
        </div>
    </div>
    <footer>
        &copy; 2024 FormStar. All rights reserved.
    </footer>
  <style>
  .alert-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(44, 62, 80, 0.45);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    backdrop-filter: blur(3px);
  }
  .alert-popup {
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(44,62,80,0.18);
    padding: 32px 28px 24px 28px;
    max-width: 480px;
    width: 90%;
    text-align: center;
    position: relative;
    animation: modalPopIn 0.35s cubic-bezier(.4,1.4,.6,1);
  }
  @keyframes modalPopIn {
    0% { transform: scale(0.85); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
  }
  .alert-message {
    margin-bottom: 28px;
    font-size: 1.08rem;
    line-height: 1.5;
    color: #2c3e50;
    font-weight: 600;
    padding: 20px;
    border: 2px solid #2980b9;
    border-radius: 10px;
    background: #e6f4ff;
    box-shadow: inset 0 2px 8px rgba(41, 128, 185, 0.1);
  }
  .alert-buttons {
    display: flex;
    gap: 18px;
    justify-content: center;
  }
  .alert-btn {
    padding: 8px 22px;
    border-radius: 6px;
    border: none;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s, color 0.2s;
    min-width: 100px;
  }
  .alert-btn-continue {
    background: linear-gradient(90deg, #4f8cff 0%, #38d39f 100%);
    color: #fff;
  }
  .alert-btn-continue:hover {
    background: linear-gradient(90deg, #38d39f 0%, #4f8cff 100%);
  }
  </style>
  <div id="alertOverlay" class="alert-overlay">
    <div class="alert-popup">
      <div id="alertMessage" class="alert-message"></div>
      <div class="alert-buttons">
        <button class="alert-btn alert-btn-continue" onclick="closeAlert()">Continue</button>
      </div>
    </div>
  </div>
  
<script>
window.formId = 'SC-100';
var questionSlugMap = {"1":"hungry","2":"thirsty"};
var questionNameIds = {"1":"hungry","2":"thirsty"};
var linkedCheckboxes = [];
var inverseCheckboxes = [];
var checkboxRequiredMap = {};
var allAreRequiredMap = {};
var unifiedFieldsMap = {};
var entryTitleMap = {};
window.fileUploadQuestions = [];
window.latexPreviewQuestions = [{"questionId":"1","title":"Latex PDF Preview","priceId":"price_1SqS2XFJeSRMFQ8XXlBzhcqW","trigger":"No"}];

  // Address helper functions (must exist before conditional logic runs)
  function generateHiddenAddressTextboxes(questionId, count, allFieldsInOrder) {
      const hasLocationFields = allFieldsInOrder.some(field =>
          ['Street', 'City', 'State', 'Zip'].includes(field.label)
      );
      if (!hasLocationFields) {
          return;
      }
      const baseFieldName = questionNameIds[questionId] || 'answer' + questionId;
      for (let i = 1; i <= 10; i++) {
          const existingAddress = document.getElementById(baseFieldName + '_address_' + i);
          if (existingAddress && existingAddress.type === 'text' && existingAddress.style.display === 'none') {
              existingAddress.remove();
          }
      }
      for (let i = 1; i <= count; i++) {
          const addressId = count === 1 ? baseFieldName + '_address' : baseFieldName + '_address_' + i;
          const addressInput = document.createElement('input');
          addressInput.type = 'text';
          addressInput.id = addressId;
          addressInput.name = addressId;
          addressInput.style.display = 'none';
          const hiddenContainer = document.getElementById('hidden_pdf_fields');
          if (hiddenContainer) {
              hiddenContainer.appendChild(addressInput);
          }
          setTimeout(() => {
              setupAddressUpdateListeners(questionId, i, baseFieldName, allFieldsInOrder, count);
          }, 1000);
      }
  }
  function setupAddressUpdateListeners(questionId, entryNumber, baseFieldName, allFieldsInOrder, count = 1) {
      const addressId = count === 1 ? baseFieldName + '_address' : baseFieldName + '_address_' + entryNumber;
      const addressInput = document.getElementById(addressId);
      if (!addressInput) return;
      const updateAddress = () => {
          const streetFieldId = count === 1 ? baseFieldName + '_street' : baseFieldName + '_street_' + entryNumber;
          const cityFieldId = count === 1 ? baseFieldName + '_city' : baseFieldName + '_city_' + entryNumber;
          const stateFieldId = count === 1 ? baseFieldName + '_state' : baseFieldName + '_state_' + entryNumber;
          const zipFieldId = count === 1 ? baseFieldName + '_zip' : baseFieldName + '_zip_' + entryNumber;
          const stateShortFieldId = count === 1 ? baseFieldName + '_state_short' : baseFieldName + '_state_short_' + entryNumber;
          const streetField = document.getElementById(streetFieldId);
          const cityField = document.getElementById(cityFieldId);
          const stateField = document.getElementById(stateFieldId);
          const zipField = document.getElementById(zipFieldId);
          const stateShortField = document.getElementById(stateShortFieldId);
          const street = streetField ? streetField.value.trim() : '';
          const city = cityField ? cityField.value.trim() : '';
          const state = stateShortField ? stateShortField.value.trim() : (stateField ? stateField.value.trim() : '');
          const zip = zipField ? zipField.value.trim() : '';
          const addressParts = [street, city, state, zip].filter(part => part !== '');
          const fullAddress = addressParts.join(', ');
          addressInput.value = fullAddress;
      };
      const locationFields = ['street', 'city', 'state', 'zip', 'state_short'];
      locationFields.forEach(fieldType => {
          const fieldId = count === 1 ? baseFieldName + '_' + fieldType : baseFieldName + '_' + fieldType + '_' + entryNumber;
          const field = document.getElementById(fieldId);
          if (field) {
              field.addEventListener('input', updateAddress);
              field.addEventListener('change', updateAddress);
          }
      });
      setTimeout(updateAddress, 500);
      setTimeout(updateAddress, 2000);
  }
  // Set up number input listeners for PDF logic
  document.addEventListener('DOMContentLoaded', function() {
    const numberInputs = document.querySelectorAll('input[type="number"]');
    numberInputs.forEach(input => {
      input.addEventListener('input', function() {
        if (typeof window.pdfLogicPDFs !== 'undefined' && window.pdfLogicPDFs.length > 0) {
          const questionId = input.id.replace(/^answer/, '');
          const matchingPdfLogic = window.pdfLogicPDFs.find(pdf => pdf.questionId === questionId);
          if (matchingPdfLogic && matchingPdfLogic.numberTrigger && matchingPdfLogic.numberValue) {
            if (typeof updateCartCountBadge === 'function') {
              updateCartCountBadge();
            }
          }
        }
      });
      input.addEventListener('change', function() {
        if (typeof window.pdfLogicPDFs !== 'undefined' && window.pdfLogicPDFs.length > 0) {
          const questionId = input.id.replace(/^answer/, '');
          const matchingPdfLogic = window.pdfLogicPDFs.find(pdf => pdf.questionId === questionId);
          if (matchingPdfLogic && matchingPdfLogic.numberTrigger && matchingPdfLogic.numberValue) {
            if (typeof updateCartCountBadge === 'function') {
              updateCartCountBadge();
            }
          }
        }
      });
    });
  });
  // Set up address listeners for multipleTextboxes questions
  document.addEventListener('DOMContentLoaded', function() {
    const multipleTextboxesQuestions = document.querySelectorAll('[id*="labelContainer"]');
    multipleTextboxesQuestions.forEach(container => {
      const questionId = container.id.replace('labelContainer', '');
      const questionNameIdsMap = (typeof questionNameIds !== 'undefined' && questionNameIds) ? questionNameIds : {};
      const baseFieldName = questionNameIdsMap[questionId] || 'answer' + questionId;
      const addressField = document.getElementById(baseFieldName + '_address');
      if (addressField) {
        const locationFields = ['street', 'city', 'state', 'zip', 'state_short'];
        locationFields.forEach(fieldType => {
          const fieldId = baseFieldName + '_' + fieldType;
          const field = document.getElementById(fieldId);
          if (field) {
            const updateAddress = () => {
              const streetField = document.getElementById(baseFieldName + '_street');
              const cityField = document.getElementById(baseFieldName + '_city');
              const stateField = document.getElementById(baseFieldName + '_state');
              const zipField = document.getElementById(baseFieldName + '_zip');
              const stateShortField = document.getElementById(baseFieldName + '_state_short');
              const street = streetField ? streetField.value.trim() : '';
              const city = cityField ? cityField.value.trim() : '';
              const state = stateShortField ? stateShortField.value.trim() : (stateField ? stateField.value.trim() : '');
              const zip = zipField ? zipField.value.trim() : '';
              const addressParts = [street, city, state, zip].filter(part => part !== '');
              const fullAddress = addressParts.join(', ');
              addressField.value = fullAddress;
            };
            field.addEventListener('input', updateAddress);
            field.addEventListener('change', updateAddress);
          }
        });
        setTimeout(() => {
          const streetField = document.getElementById(baseFieldName + '_street');
          const cityField = document.getElementById(baseFieldName + '_city');
          const stateField = document.getElementById(baseFieldName + '_state');
          const zipField = document.getElementById(baseFieldName + '_zip');
          const stateShortField = document.getElementById(baseFieldName + '_state_short');
          const street = streetField ? streetField.value.trim() : '';
          const city = cityField ? cityField.value.trim() : '';
          const state = stateShortField ? stateShortField.value.trim() : (stateField ? stateField.value.trim() : '');
          const zip = zipField ? zipField.value.trim() : '';
          const addressParts = [street, city, state, zip].filter(part => part !== '');
          const fullAddress = addressParts.join(', ');
          addressField.value = fullAddress;
        }, 1000);
      }
    });
  });
  // Set up linked checkbox listeners after DOM loads
  document.addEventListener('DOMContentLoaded', function() {
    const linkedCheckboxesArray = (typeof linkedCheckboxes !== 'undefined' && linkedCheckboxes) ? linkedCheckboxes : [];
    if (!linkedCheckboxesArray || linkedCheckboxesArray.length === 0) {
      return;
    }
    // Helper function to find checkbox by trying multiple ID patterns
    // Make it globally accessible so it can be used by other functions like updateAllLinkedCheckboxes
    window.findCheckboxById = function(checkboxId) {
      // First try exact match
      let checkbox = document.getElementById(checkboxId);
      if (checkbox) {
        return checkbox;
      }
      // If not found, try to find by pattern matching
      // Expected ID format: {fieldName}_{entryNumber}_{optionValue}
      // Actual ID format (from dropdownMirror): {baseNodeId}_{fieldName}_{optionValue}_{entryNumber}
      // Example: Expected "is_this_plaintiff_a_business_1_yes" 
      //          Actual: "how_many_extra_plaintiffs_are_there_is_this_plaintiff_a_business_yes_1"
      const parts = checkboxId.split('_');
      if (parts.length >= 3) {
        // Parse expected ID: {fieldName}_{entryNumber}_{optionValue}
        const optionValue = parts[parts.length - 1]; // last part: "yes"
        const entryNumber = parts[parts.length - 2]; // second last: "1"
        const fieldName = parts.slice(0, -2).join('_'); // everything before: "is_this_plaintiff_a_business"

        // Try to find checkbox with pattern: *{fieldName}_{optionValue}_{entryNumber}
        // Or pattern: *{fieldName}*_{optionValue}_{entryNumber}
        const allCheckboxes = document.querySelectorAll('input[type="checkbox"]');
        for (let cb of allCheckboxes) {
          if (!cb.id) continue;
          // Match if ID ends with: _{fieldName}_{optionValue}_{entryNumber} or just _{optionValue}_{entryNumber}
          // and contains the field name somewhere
          const endsWithPattern = cb.id.endsWith('_' + optionValue + '_' + entryNumber);
          const containsFieldName = cb.id.includes(fieldName);

          if (endsWithPattern && containsFieldName) {
            return cb;
          }
        }
      }
      return null;
    };
    const findCheckboxById = window.findCheckboxById;
    function updateLinkedCheckbox(linkedCheckboxId, checkboxIds) {
      const linkedCheckbox = document.getElementById(linkedCheckboxId);
      if (!linkedCheckbox) {
        return;
      }
      let anyChecked = false;
      checkboxIds.forEach(checkboxId => {
        const sourceCheckbox = findCheckboxById(checkboxId);
        if (sourceCheckbox && sourceCheckbox.checked) {
          anyChecked = true;
        }
      });
      linkedCheckbox.checked = anyChecked;
    }
    linkedCheckboxesArray.forEach(linkedCheckboxGroup => {
      const linkedCheckboxId = linkedCheckboxGroup.linkedCheckboxId;
      const checkboxIds = linkedCheckboxGroup.checkboxes || [];
      if (!linkedCheckboxId || checkboxIds.length === 0) {
        return;
      }
      checkboxIds.forEach(checkboxId => {
        // Try to find existing checkbox
        let sourceCheckbox = findCheckboxById(checkboxId);
        if (sourceCheckbox) {
          sourceCheckbox.addEventListener('change', function() {
            updateLinkedCheckbox(linkedCheckboxId, checkboxIds);
          });
          sourceCheckbox.addEventListener('click', function() {
            setTimeout(() => {
              updateLinkedCheckbox(linkedCheckboxId, checkboxIds);
            }, 0);
          });
        } else {
          // Checkbox doesn't exist yet (might be created dynamically), set up a watcher
          const observer = new MutationObserver(function(mutations) {
            const foundCheckbox = findCheckboxById(checkboxId);
            if (foundCheckbox) {
              foundCheckbox.addEventListener('change', function() {
                updateLinkedCheckbox(linkedCheckboxId, checkboxIds);
              });
              foundCheckbox.addEventListener('click', function() {
                setTimeout(() => {
                  updateLinkedCheckbox(linkedCheckboxId, checkboxIds);
                }, 0);
              });
              observer.disconnect();
            }
          });
          observer.observe(document.body, {
            childList: true,
            subtree: true
          });
          // Stop observing after 30 seconds to avoid memory leaks
          setTimeout(() => observer.disconnect(), 30000);
        }
      });
      setTimeout(() => {
        updateLinkedCheckbox(linkedCheckboxId, checkboxIds);
      }, 500);
    });
    window.updateAllLinkedCheckboxes = function() {
      const linkedCheckboxesArray = (typeof linkedCheckboxes !== 'undefined' && linkedCheckboxes) ? linkedCheckboxes : [];
      if (!linkedCheckboxesArray || linkedCheckboxesArray.length === 0) {
        return;
      }
      linkedCheckboxesArray.forEach(linkedCheckboxGroup => {
        const linkedCheckboxId = linkedCheckboxGroup.linkedCheckboxId;
        const checkboxIds = linkedCheckboxGroup.checkboxes || [];
        if (!linkedCheckboxId || checkboxIds.length === 0) {
          return;
        }
        const linkedCheckbox = document.getElementById(linkedCheckboxId);
        if (!linkedCheckbox) {
          return;
        }
        let anyChecked = false;
        checkboxIds.forEach(checkboxId => {
          const sourceCheckbox = findCheckboxById(checkboxId);
          if (sourceCheckbox && sourceCheckbox.checked) {
            anyChecked = true;
          }
        });
        linkedCheckbox.checked = anyChecked;
      });
    };
  });
  // Set up inverse checkbox listeners after DOM loads
  document.addEventListener('DOMContentLoaded', function() {
    const inverseCheckboxesArray = (typeof inverseCheckboxes !== 'undefined' && inverseCheckboxes) ? inverseCheckboxes : [];
    if (!inverseCheckboxesArray || inverseCheckboxesArray.length === 0) {
      return;
    }
    const linkedCheckboxesArray = (typeof linkedCheckboxes !== 'undefined' && linkedCheckboxes) ? linkedCheckboxes : [];

    function updateInverseCheckbox(inverseCheckboxId, targetCheckboxId, isLinkedCheckbox, sourceCheckboxIds) {
      const inverseCheckbox = document.getElementById(inverseCheckboxId);
      if (!inverseCheckbox) {
        return;
      }

      if (isLinkedCheckbox && sourceCheckboxIds && sourceCheckboxIds.length > 0) {
        // For linked checkboxes: check if ANY source checkbox is checked
        let anyChecked = false;
        sourceCheckboxIds.forEach(checkboxId => {
          const sourceCheckbox = document.getElementById(checkboxId);
          if (sourceCheckbox && sourceCheckbox.checked) {
            anyChecked = true;
          }
        });
        // Inverse checkbox is checked when NONE of the source checkboxes are checked
        inverseCheckbox.checked = !anyChecked;
      } else {
        // For regular checkboxes: inverse is opposite of target
        const targetCheckbox = document.getElementById(targetCheckboxId);
        if (!targetCheckbox) {
          return;
        }
        inverseCheckbox.checked = !targetCheckbox.checked;
      }
    }

    function setupInverseCheckboxListener(inverseCheckboxId, targetCheckboxId, isLinkedCheckbox, sourceCheckboxIds) {
      if (isLinkedCheckbox && sourceCheckboxIds && sourceCheckboxIds.length > 0) {
        // For linked checkboxes: listen to all source checkboxes
        sourceCheckboxIds.forEach(checkboxId => {
          const sourceCheckbox = document.getElementById(checkboxId);
          if (sourceCheckbox) {
            const updateHandler = function() {
              updateInverseCheckbox(inverseCheckboxId, targetCheckboxId, isLinkedCheckbox, sourceCheckboxIds);
            };
            sourceCheckbox.addEventListener('change', updateHandler);
            sourceCheckbox.addEventListener('click', function() {
              setTimeout(updateHandler, 0);
            });
          }
        });
        // Also listen to the linked checkbox itself in case it gets updated programmatically
        const linkedCheckbox = document.getElementById(targetCheckboxId);
        if (linkedCheckbox) {
          const updateHandler = function() {
            updateInverseCheckbox(inverseCheckboxId, targetCheckboxId, isLinkedCheckbox, sourceCheckboxIds);
          };
          linkedCheckbox.addEventListener('change', updateHandler);
        }
      } else {
        // For regular checkboxes: listen to the target checkbox
        const targetCheckbox = document.getElementById(targetCheckboxId);
        if (targetCheckbox) {
          const updateHandler = function() {
            updateInverseCheckbox(inverseCheckboxId, targetCheckboxId, isLinkedCheckbox, sourceCheckboxIds);
          };
          targetCheckbox.addEventListener('change', updateHandler);
          targetCheckbox.addEventListener('click', function() {
            setTimeout(updateHandler, 0);
          });
        }
      }
    }

    inverseCheckboxesArray.forEach(inverseCheckboxConfig => {
      const inverseCheckboxId = inverseCheckboxConfig.inverseCheckboxId;
      const targetCheckboxId = inverseCheckboxConfig.targetCheckboxId;
      if (!inverseCheckboxId || !targetCheckboxId) {
        return;
      }

      // Check if target is a linked checkbox
      let isLinkedCheckbox = false;
      let sourceCheckboxIds = [];
      const linkedCheckboxConfig = linkedCheckboxesArray.find(lc => lc.linkedCheckboxId === targetCheckboxId);
      if (linkedCheckboxConfig) {
        isLinkedCheckbox = true;
        sourceCheckboxIds = linkedCheckboxConfig.checkboxes || [];
      }

      // Create the hidden inverse checkbox
      const form = document.getElementById('customForm');
      if (form) {
        const inverseCheckbox = document.createElement('input');
        inverseCheckbox.type = 'checkbox';
        inverseCheckbox.id = inverseCheckboxId;
        inverseCheckbox.name = inverseCheckboxId;
        inverseCheckbox.style.display = 'none';
        form.appendChild(inverseCheckbox);
      }

      // Set up listeners
      setupInverseCheckboxListener(inverseCheckboxId, targetCheckboxId, isLinkedCheckbox, sourceCheckboxIds);

      // Initial update
      setTimeout(() => {
        updateInverseCheckbox(inverseCheckboxId, targetCheckboxId, isLinkedCheckbox, sourceCheckboxIds);
      }, 500);
    });

    window.updateAllInverseCheckboxes = function() {
      const inverseCheckboxesArray = (typeof inverseCheckboxes !== 'undefined' && inverseCheckboxes) ? inverseCheckboxes : [];
      const linkedCheckboxesArray = (typeof linkedCheckboxes !== 'undefined' && linkedCheckboxes) ? linkedCheckboxes : [];
      if (!inverseCheckboxesArray || inverseCheckboxesArray.length === 0) {
        return;
      }
      inverseCheckboxesArray.forEach(inverseCheckboxConfig => {
        const inverseCheckboxId = inverseCheckboxConfig.inverseCheckboxId;
        const targetCheckboxId = inverseCheckboxConfig.targetCheckboxId;
        if (!inverseCheckboxId || !targetCheckboxId) {
          return;
        }
        // Check if target is a linked checkbox
        let isLinkedCheckbox = false;
        let sourceCheckboxIds = [];
        const linkedCheckboxConfig = linkedCheckboxesArray.find(lc => lc.linkedCheckboxId === targetCheckboxId);
        if (linkedCheckboxConfig) {
          isLinkedCheckbox = true;
          sourceCheckboxIds = linkedCheckboxConfig.checkboxes || [];
        }
        updateInverseCheckbox(inverseCheckboxId, targetCheckboxId, isLinkedCheckbox, sourceCheckboxIds);
      });
    };

    // Periodic validation to ensure inverse relationship is always maintained
    // This catches any cases where autofill or other code tries to set both checkboxes
    function validateAndFixInverseCheckboxes() {
      const inverseCheckboxesArray = (typeof inverseCheckboxes !== 'undefined' && inverseCheckboxes) ? inverseCheckboxes : [];
      const linkedCheckboxesArray = (typeof linkedCheckboxes !== 'undefined' && linkedCheckboxes) ? linkedCheckboxes : [];
      if (!inverseCheckboxesArray || inverseCheckboxesArray.length === 0) {
        return;
      }

      inverseCheckboxesArray.forEach(inverseCheckboxConfig => {
        const inverseCheckboxId = inverseCheckboxConfig.inverseCheckboxId;
        const targetCheckboxId = inverseCheckboxConfig.targetCheckboxId;
        if (!inverseCheckboxId || !targetCheckboxId) {
          return;
        }

        const inverseCheckbox = document.getElementById(inverseCheckboxId);
        if (!inverseCheckbox) {
          return;
        }

        // Check if target is a linked checkbox
        let isLinkedCheckbox = false;
        let sourceCheckboxIds = [];
        const linkedCheckboxConfig = linkedCheckboxesArray.find(lc => lc.linkedCheckboxId === targetCheckboxId);
        if (linkedCheckboxConfig) {
          isLinkedCheckbox = true;
          sourceCheckboxIds = linkedCheckboxConfig.checkboxes || [];
        }

        // Calculate what the inverse checkbox state SHOULD be
        let shouldBeChecked = false;
        if (isLinkedCheckbox && sourceCheckboxIds && sourceCheckboxIds.length > 0) {
          // For linked checkboxes: inverse is checked when NONE of source checkboxes are checked
          let anyChecked = false;
          sourceCheckboxIds.forEach(checkboxId => {
            const sourceCheckbox = document.getElementById(checkboxId);
            if (sourceCheckbox && sourceCheckbox.checked) {
              anyChecked = true;
            }
          });
          shouldBeChecked = !anyChecked;
        } else {
          // For regular checkboxes: inverse is opposite of target
          const targetCheckbox = document.getElementById(targetCheckboxId);
          if (targetCheckbox) {
            shouldBeChecked = !targetCheckbox.checked;
          }
        }

        // If the inverse checkbox state is wrong, fix it
        if (inverseCheckbox.checked !== shouldBeChecked) {
          inverseCheckbox.checked = shouldBeChecked;
        }
      });
    }

    // Run periodic validation every 500ms to catch any violations
    setInterval(validateAndFixInverseCheckboxes, 500);

    // Also validate after autofill operations
    // Hook into autofill completion by watching for the isInitialAutofill flag
    let autofillCheckInterval = setInterval(function() {
      if (typeof window.isInitialAutofill !== 'undefined' && !window.isInitialAutofill) {
        // Autofill is complete, validate inverse checkboxes
        validateAndFixInverseCheckboxes();
        // Also call updateAllInverseCheckboxes to ensure everything is synced
        if (typeof window.updateAllInverseCheckboxes === 'function') {
          window.updateAllInverseCheckboxes();
        }
        clearInterval(autofillCheckInterval);
      }
    }, 100);

    // Clear the autofill check interval after 10 seconds to avoid infinite checking
    setTimeout(function() {
      clearInterval(autofillCheckInterval);
    }, 10000);

    // Also validate when form fields change (MutationObserver for programmatic changes)
    const form = document.getElementById('customForm');
    if (form) {
      const observer = new MutationObserver(function(mutations) {
        // Check if any checkbox attributes changed
        let shouldValidate = false;
        mutations.forEach(function(mutation) {
          if (mutation.type === 'attributes' && mutation.attributeName === 'checked') {
            shouldValidate = true;
          }
        });
        if (shouldValidate) {
          // Small delay to let all changes settle
          setTimeout(validateAndFixInverseCheckboxes, 50);
        }
      });

      // Observe the entire form for checkbox changes
      observer.observe(form, {
        attributes: true,
        attributeFilter: ['checked'],
        subtree: true,
        childList: true
      });
    }
  });
  var isCreatingFields = false;

  function createTriggerFieldsContainer(questionId, entryNumber, sequenceIndex, fields, parentContainer, dropdownFieldName, triggerTitleText, parentDropdownNodeId, triggerCondition, isMultipleTextboxes) {
    // Default parameters for backward compatibility
    triggerCondition = triggerCondition || '';
    isMultipleTextboxes = isMultipleTextboxes === true; // Only true if explicitly set to true
    const triggerContainer = document.createElement('div');
    triggerContainer.id = 'triggerFields_' + questionId + '_' + entryNumber + '_' + sequenceIndex;
    triggerContainer.style.cssText = 'margin: 15px 0; padding: 20px; border: 2px solid #87CEEB; border-radius: 12px; background: linear-gradient(135deg, #f0f8ff 0%, #e6f3ff 100%); box-shadow: 0 2px 8px rgba(135, 206, 235, 0.15); display: block;';
    const triggerTitle = document.createElement('h5');
    triggerTitle.textContent = triggerTitleText || 'Additional Information';
    triggerTitle.style.cssText = 'margin: 0 0 15px 0; color: #2980b9; font-size: 16px; font-weight: 600; text-align: center;';
    triggerContainer.appendChild(triggerTitle);
    // Helper function to sanitize names for IDs
    function sanitizeForId(str) {
      return String(str || '')
        .toLowerCase()
        .replace(/[?]/g, '')
        .replace(/[^a-z0-9_]+/g, '_')
        .replace(/^_+|_+$/g, '');
    }
    // Sanitize dropdown name and trigger condition for multipleTextboxes ID format
    const sanitizedDropdownName = sanitizeForId(dropdownFieldName);
    const sanitizedTriggerCondition = triggerCondition ? sanitizeForId(triggerCondition) : '';
    fields.forEach((triggerField, fieldIndex) => {
      if (triggerField.type === 'label') {
        const fieldDiv = document.createElement('div');
        // Check if conditional logic is enabled
        const hasConditionalLogic = triggerField.conditionalLogic && triggerField.conditionalLogic.enabled;
        const conditionalConditions = hasConditionalLogic && triggerField.conditionalLogic.conditions ? triggerField.conditionalLogic.conditions : [];
        // Initially hide if conditional logic is enabled
        if (hasConditionalLogic) {
          fieldDiv.style.cssText = 'margin: 10px 0; padding: 12px; background-color: white; border: 1px solid #87CEEB; border-radius: 8px; display: none; flex-direction: column; align-items: center; box-shadow: 0 1px 3px rgba(135, 206, 235, 0.1);';
        } else {
          fieldDiv.style.cssText = 'margin: 10px 0; padding: 12px; background-color: white; border: 1px solid #87CEEB; border-radius: 8px; display: flex; flex-direction: column; align-items: center; box-shadow: 0 1px 3px rgba(135, 206, 235, 0.1);';
        }
        const label = document.createElement('label');
        label.textContent = triggerField.label + ":";
        label.style.cssText = 'display: block; margin-bottom: 8px; font-weight: bold; color: #2980b9; font-size: 15px; text-align: center;';
        const input = document.createElement('input');
        // Use number type if isAmountOption is true, otherwise text
        input.type = triggerField.isAmountOption ? 'number' : 'text';
        // For multipleTextboxes: use nodeId directly from JSON (e.g., "hello_yes_name")
        // For numberedDropdown: {fieldName}_{entryNumber}
        if (isMultipleTextboxes) {
          // Use the nodeId directly as specified in the JSON
          input.id = triggerField.nodeId || triggerField.label;
        } else {
          input.id = triggerField.nodeId + "_" + entryNumber;
        }
        input.name = input.id;
        input.style.cssText = 'width: 200px; padding: 10px; border: 1px solid #87CEEB; border-radius: 8px; font-size: 14px; background-color: white; color: #2c3e50; transition: all 0.2s ease;';
        // Add hover effect
        input.addEventListener('mouseenter', function() {
          this.style.borderColor = '#5DADE2';
          this.style.backgroundColor = '#f8f9ff';
        });
        input.addEventListener('mouseleave', function() {
          this.style.borderColor = '#87CEEB';
          this.style.backgroundColor = 'white';
        });
        fieldDiv.appendChild(label);
        fieldDiv.appendChild(input);
        triggerContainer.appendChild(fieldDiv);
        // Add conditional logic if enabled
        if (hasConditionalLogic && conditionalConditions.length > 0) {
          // CRITICAL: Ensure field is hidden immediately after appending
          fieldDiv.style.display = 'none';
          // Function to check if any condition is met
          const checkConditionalLogic = () => {
            let anyMatch = false;
            // Use the parent dropdown's nodeId (same as the select.id base)
            const baseNodeIdForCheck = parentDropdownNodeId || (questionNameIds[questionId] || ('answer' + questionId));
            conditionalConditions.forEach((conditionNodeId) => {
              if (!conditionNodeId) return;
              // Construct full checkbox ID: {baseNodeId}_{condition}_{entryNumber}
              const simpleCheckboxId = conditionNodeId + "_" + entryNumber;
              const fullCheckboxId = baseNodeIdForCheck + "_" + conditionNodeId + "_" + entryNumber;
              const checkboxId = fullCheckboxId; // Use the full pattern for dropdown hidden checkboxes
              const radioId = conditionNodeId + "_" + entryNumber + "_radio";
              // Try to find checkbox or radio button
              let checkbox = document.getElementById(checkboxId);
              if (!checkbox) {
                checkbox = document.getElementById(simpleCheckboxId);
              }
              const radio = document.getElementById(radioId);
              // Check if checkbox is checked or radio is selected
              if ((checkbox && checkbox.checked) || (radio && radio.checked)) {
                anyMatch = true;
                return;
              }
            });
            // Show or hide the label field based on match
            if (anyMatch) {
              fieldDiv.style.display = 'flex';
            } else {
              fieldDiv.style.display = 'none';
              // Reset input value when hidden
              input.value = '';
            }
          };
          // Listen for radio group changes
          const radioGroupHandler = function(event) {
            const eventEntryNumber = event.detail && event.detail.entryNumber;
            if (eventEntryNumber != null && String(eventEntryNumber) === String(entryNumber)) {
              setTimeout(() => {
                checkConditionalLogic();
              }, 200);
            }
          };
          window.addEventListener('radioGroupChanged', radioGroupHandler);
          // Listen for trigger dropdown changes to re-evaluate conditional logic
          const triggerDropdownHandler = function(event) {
            const eventEntryNumber = event.detail && event.detail.entryNumber;
            const eventQuestionId = event.detail && event.detail.questionId;
            const eventCheckboxId = event.detail && event.detail.checkboxId;
            // Re-check if:
            // 1. It's for the same entry and question (from the change event in the dropdown)
            // 2. OR if a checkbox was created/removed that matches one of our conditions
            let shouldRecheck = false;
            if (eventEntryNumber != null && String(eventEntryNumber) === String(entryNumber) && 
                eventQuestionId != null && String(eventQuestionId) === String(questionId)) {
              shouldRecheck = true;
            } else if (eventEntryNumber != null && String(eventEntryNumber) === String(entryNumber) && eventCheckboxId) {
              // Check if the created/removed checkbox matches any of our conditions
              const baseNodeIdForCheck = parentDropdownNodeId || (questionNameIds[questionId] || ('answer' + questionId));
              conditionalConditions.forEach((conditionNodeId) => {
                if (!conditionNodeId) return;
                const fullCheckboxId = baseNodeIdForCheck + "_" + conditionNodeId + "_" + entryNumber;
                if (eventCheckboxId === fullCheckboxId) {
                  shouldRecheck = true;
                }
              });
            }
            if (shouldRecheck) {
              // Use a delay to ensure dropdownMirror has finished creating/removing checkboxes
              setTimeout(() => {
                checkConditionalLogic();
              }, 150);
            }
          };
          window.addEventListener('triggerDropdownChanged', triggerDropdownHandler);
          // Set up event listeners for each condition checkbox/radio
          conditionalConditions.forEach((conditionNodeId) => {
            if (!conditionNodeId) return;
            const baseNodeIdForCheck = parentDropdownNodeId || (questionNameIds[questionId] || ('answer' + questionId));
            const simpleCheckboxId = conditionNodeId + "_" + entryNumber;
            const fullCheckboxId = baseNodeIdForCheck + "_" + conditionNodeId + "_" + entryNumber;
            const radioId = conditionNodeId + "_" + entryNumber + "_radio";
            const attachListener = () => {
              // Try to find checkbox first - try full pattern, then simple pattern
              let element = document.getElementById(fullCheckboxId);
              let isRadio = false;
              // If not found with full pattern, try simple pattern
              if (!element) {
                element = document.getElementById(simpleCheckboxId);
              }
              // If not found, try to find radio button
              if (!element) {
                element = document.getElementById(radioId);
                isRadio = true;
              }
              if (element) {
                if (isRadio) {
                  element.addEventListener('change', checkConditionalLogic);
                } else {
                  element.addEventListener('change', checkConditionalLogic);
                }
              } else {
                // Element not found yet, try again after a delay
                setTimeout(attachListener, 100);
              }
            };
            // Start trying to attach listener
            attachListener();
          });
          // Initial check
          setTimeout(() => {
            checkConditionalLogic();
          }, 300);
        }
      } else if (triggerField.type === 'checkbox') {
        const checkboxFieldDiv = document.createElement('div');
        // Check if conditional logic is enabled
        const hasConditionalLogic = triggerField.conditionalLogic && triggerField.conditionalLogic.enabled;
        const conditionalConditions = hasConditionalLogic && triggerField.conditionalLogic.conditions ? triggerField.conditionalLogic.conditions : [];
        // Initially hide if conditional logic is enabled
        if (hasConditionalLogic) {
          checkboxFieldDiv.style.cssText = 'margin: 10px 0; padding: 12px; background-color: white; border: 1px solid #87CEEB; border-radius: 8px; box-shadow: 0 1px 3px rgba(135, 206, 235, 0.1); display: none;';
        } else {
          checkboxFieldDiv.style.cssText = 'margin: 10px 0; padding: 12px; background-color: white; border: 1px solid #87CEEB; border-radius: 8px; box-shadow: 0 1px 3px rgba(135, 206, 235, 0.1);';
        }
        const fieldNameLabel = document.createElement('label');
        fieldNameLabel.textContent = triggerField.fieldName + ":";
        fieldNameLabel.style.cssText = 'display: block; margin-bottom: 8px; font-weight: bold; color: #2980b9; font-size: 15px; text-align: center;';
        checkboxFieldDiv.appendChild(fieldNameLabel);
        const checkboxOptions = triggerField.options || [];
        const selectionType = triggerField.selectionType || 'multiple'; // Default to multiple if not specified
        checkboxOptions.forEach((option, optionIndex) => {
          const optionDiv = document.createElement('div');
          optionDiv.style.cssText = 'margin: 8px 0; padding: 8px; background-color: white; border-radius: 6px; border: 1px solid #87CEEB; display: flex; align-items: center;';
          const input = document.createElement('input');
          input.type = selectionType === 'single' ? 'radio' : 'checkbox';
          // For multipleTextboxes: {dropdownName}_{triggerCondition}_{fieldName}_{optionNodeId} or {dropdownName}_{triggerCondition}_{fieldName}_{optionNodeId}_radio
          // For numberedDropdown: {optionNodeId}_{entryNumber} or {optionNodeId}_{entryNumber}_radio
          let checkboxId;
          if (isMultipleTextboxes && sanitizedDropdownName && sanitizedTriggerCondition) {
            const sanitizedFieldName = sanitizeForId(triggerField.fieldName);
            const sanitizedOptionNodeId = sanitizeForId(option.nodeId);
            if (selectionType === 'single') {
              checkboxId = sanitizedDropdownName + '_' + sanitizedTriggerCondition + '_' + sanitizedFieldName + '_' + sanitizedOptionNodeId + '_radio';
            } else {
              checkboxId = sanitizedDropdownName + '_' + sanitizedTriggerCondition + '_' + sanitizedFieldName + '_' + sanitizedOptionNodeId;
            }
          } else {
            checkboxId = selectionType === 'single' ? option.nodeId + "_" + entryNumber + "_radio" : option.nodeId + "_" + entryNumber;
          }
          input.id = checkboxId;
          input.name = selectionType === 'single' ? (isMultipleTextboxes ? 'radio_group_' + sanitizedDropdownName + '_' + sanitizedTriggerCondition + '_' + sanitizeForId(triggerField.fieldName) : 'radio_group_' + entryNumber) : checkboxId;
          input.value = option.text;
          input.style.cssText = 'margin-right: 12px; width: 18px; height: 18px; accent-color: #87CEEB; cursor: pointer;';
          // Add event listener for radio buttons to create hidden checkboxes
          if (selectionType === 'single') {
            input.addEventListener('change', function() {
              if (this.checked) {
                // Uncheck all other radio buttons in this group and remove their hidden checkboxes
                const radioGroup = document.querySelectorAll('input[name="' + this.name + '"]');
                radioGroup.forEach(radio => {
                  if (radio !== this) {
                    radio.checked = false;
                    // Remove hidden checkbox for unchecked radio
                    const originalNodeId = radio.id.replace('_radio', '');
                    const existingHiddenCheckbox = document.getElementById(originalNodeId);
                    if (existingHiddenCheckbox) {
                      if (existingHiddenCheckbox.type === 'checkbox' && existingHiddenCheckbox.style.display === 'none') {
                        existingHiddenCheckbox.remove();
                      }
                    }
                  }
                });
                // Create hidden checkbox for the selected radio
                const originalNodeId = this.id.replace('_radio', '');
                if (typeof createHiddenCheckboxForRadio === 'function') {
                  createHiddenCheckboxForRadio(originalNodeId, this.name, this.value);
                }
                // Extract entry number from radio name to ensure consistency
                // Radio name format: "radio_group_ENTRYNUMBER" for trigger sequences
                let extractedEntryNumber = entryNumber;
                const nameMatch = this.name.match(/radio_group_(d+)/);
                if (nameMatch) {
                  extractedEntryNumber = parseInt(nameMatch[1]);
                } else {
                }
                // Trigger conditional logic re-evaluation for all date fields
                // Dispatch a custom event that conditional logic listeners can catch
                window.dispatchEvent(new CustomEvent('radioGroupChanged', {
                  detail: { entryNumber: extractedEntryNumber, radioGroup: this.name }
                }));
              }
            });
          }
          const label = document.createElement('label');
          label.textContent = option.text;
          label.style.cssText = 'flex: 1; cursor: pointer; color: #2c3e50; font-size: 15px; font-weight: 500; margin: 0;';
          label.setAttribute('for', input.id);
          optionDiv.appendChild(input);
          optionDiv.appendChild(label);
          checkboxFieldDiv.appendChild(optionDiv);
        });
        triggerContainer.appendChild(checkboxFieldDiv);
        // Add conditional logic if enabled
        if (hasConditionalLogic && conditionalConditions.length > 0) {
          // CRITICAL: Ensure field is hidden immediately after appending
          checkboxFieldDiv.style.display = 'none';
          // Function to check if any condition is met
          const checkConditionalLogic = () => {
            let anyMatch = false;
            // Use the parent dropdown's nodeId (same as the select.id base)
            const baseNodeIdForCheck = parentDropdownNodeId || (questionNameIds[questionId] || ('answer' + questionId));
            conditionalConditions.forEach((conditionNodeId) => {
              if (!conditionNodeId) return;
              // Construct full checkbox ID: {baseNodeId}_{condition}_{entryNumber}
              const simpleCheckboxId = conditionNodeId + "_" + entryNumber;
              const fullCheckboxId = baseNodeIdForCheck + "_" + conditionNodeId + "_" + entryNumber;
              const checkboxId = fullCheckboxId; // Use the full pattern for dropdown hidden checkboxes
              const radioId = conditionNodeId + "_" + entryNumber + "_radio";
              // Try to find checkbox or radio button
              let checkbox = document.getElementById(checkboxId);
              if (!checkbox) {
                checkbox = document.getElementById(simpleCheckboxId);
              }
              const radio = document.getElementById(radioId);
              // Check if checkbox is checked or radio is selected
              if ((checkbox && checkbox.checked) || (radio && radio.checked)) {
                anyMatch = true;
                return;
              }
            });
            // Show or hide the checkbox field based on match
            if (anyMatch) {
              checkboxFieldDiv.style.display = 'block';
            } else {
              checkboxFieldDiv.style.display = 'none';
              // Reset checkbox values when hidden
              checkboxOptions.forEach((option) => {
                // Use the same ID format as when creating the checkbox
                let checkboxId;
                if (isMultipleTextboxes && sanitizedDropdownName && sanitizedTriggerCondition) {
                  const sanitizedFieldName = sanitizeForId(triggerField.fieldName);
                  const sanitizedOptionNodeId = sanitizeForId(option.nodeId);
                  if (selectionType === 'single') {
                    checkboxId = sanitizedDropdownName + '_' + sanitizedTriggerCondition + '_' + sanitizedFieldName + '_' + sanitizedOptionNodeId + '_radio';
                  } else {
                    checkboxId = sanitizedDropdownName + '_' + sanitizedTriggerCondition + '_' + sanitizedFieldName + '_' + sanitizedOptionNodeId;
                  }
                } else {
                  checkboxId = selectionType === 'single' ? option.nodeId + "_" + entryNumber + "_radio" : option.nodeId + "_" + entryNumber;
                }
                const optionInput = document.getElementById(checkboxId);
                if (optionInput) {
                  optionInput.checked = false;
                  optionInput.dispatchEvent(new Event('change'));
                }
              });
            }
          };
          // Listen for radio group changes
          const radioGroupHandler = function(event) {
            const eventEntryNumber = event.detail && event.detail.entryNumber;
            if (eventEntryNumber != null && String(eventEntryNumber) === String(entryNumber)) {
              setTimeout(() => {
                checkConditionalLogic();
              }, 200);
            }
          };
          window.addEventListener('radioGroupChanged', radioGroupHandler);
          // Listen for trigger dropdown changes to re-evaluate conditional logic
          const triggerDropdownHandler = function(event) {
            const eventEntryNumber = event.detail && event.detail.entryNumber;
            const eventQuestionId = event.detail && event.detail.questionId;
            const eventCheckboxId = event.detail && event.detail.checkboxId;
            // Re-check if:
            // 1. It's for the same entry and question (from the change event in the dropdown)
            // 2. OR if a checkbox was created/removed that matches one of our conditions
            let shouldRecheck = false;
            if (eventEntryNumber != null && String(eventEntryNumber) === String(entryNumber) && 
                eventQuestionId != null && String(eventQuestionId) === String(questionId)) {
              shouldRecheck = true;
            } else if (eventEntryNumber != null && String(eventEntryNumber) === String(entryNumber) && eventCheckboxId) {
              // Check if the created/removed checkbox matches any of our conditions
              const baseNodeIdForCheck = parentDropdownNodeId || (questionNameIds[questionId] || ('answer' + questionId));
              conditionalConditions.forEach((conditionNodeId) => {
                if (!conditionNodeId) return;
                const fullCheckboxId = baseNodeIdForCheck + "_" + conditionNodeId + "_" + entryNumber;
                if (eventCheckboxId === fullCheckboxId) {
                  shouldRecheck = true;
                }
              });
            }
            if (shouldRecheck) {
              // Use a delay to ensure dropdownMirror has finished creating/removing checkboxes
              setTimeout(() => {
                checkConditionalLogic();
              }, 150);
            }
          };
          window.addEventListener('triggerDropdownChanged', triggerDropdownHandler);
          // Set up event listeners for each condition checkbox/radio
          conditionalConditions.forEach((conditionNodeId) => {
            if (!conditionNodeId) return;
            const baseNodeIdForCheck = parentDropdownNodeId || (questionNameIds[questionId] || ('answer' + questionId));
            const simpleCheckboxId = conditionNodeId + "_" + entryNumber;
            const fullCheckboxId = baseNodeIdForCheck + "_" + conditionNodeId + "_" + entryNumber;
            const radioId = conditionNodeId + "_" + entryNumber + "_radio";
            const attachListener = () => {
              // Try to find checkbox first - try full pattern, then simple pattern
              let element = document.getElementById(fullCheckboxId);
              let isRadio = false;
              // If not found with full pattern, try simple pattern
              if (!element) {
                element = document.getElementById(simpleCheckboxId);
              }
              // If not found, try to find radio button
              if (!element) {
                element = document.getElementById(radioId);
                isRadio = true;
              }
              if (element) {
                if (isRadio) {
                  element.addEventListener('change', checkConditionalLogic);
                } else {
                  element.addEventListener('change', checkConditionalLogic);
                }
              } else {
                // Element not found yet, try again after a delay
                setTimeout(attachListener, 100);
              }
            };
            // Start trying to attach listener
            attachListener();
          });
          // Initial check
          setTimeout(() => {
            checkConditionalLogic();
          }, 300);
        }
      } else if (triggerField.type === 'dropdown') {
        const dropdownFieldDiv = document.createElement('div');
        // Check if conditional logic is enabled
        const hasConditionalLogic = triggerField.conditionalLogic && triggerField.conditionalLogic.enabled;
        const conditionalConditions = hasConditionalLogic && triggerField.conditionalLogic.conditions ? triggerField.conditionalLogic.conditions : [];
        // Initially hide if conditional logic is enabled
        if (hasConditionalLogic) {
          dropdownFieldDiv.style.cssText = 'margin: 10px 0; padding: 12px; background-color: white; border: 1px solid #87CEEB; border-radius: 8px; box-shadow: 0 1px 3px rgba(135, 206, 235, 0.1); display: none;';
        } else {
          dropdownFieldDiv.style.cssText = 'margin: 10px 0; padding: 12px; background-color: white; border: 1px solid #87CEEB; border-radius: 8px; box-shadow: 0 1px 3px rgba(135, 206, 235, 0.1);';
        }
        const fieldNameLabel = document.createElement('label');
        fieldNameLabel.textContent = triggerField.fieldName + ":";
        fieldNameLabel.style.cssText = 'display: block; margin-bottom: 8px; font-weight: bold; color: #2980b9; font-size: 15px; text-align: center;';
        dropdownFieldDiv.appendChild(fieldNameLabel);
        const select = document.createElement('select');
        const sanitizedTriggerFieldName = sanitizeForId(triggerField.fieldName || '');
        // For multipleTextboxes: {dropdownName}_{triggerCondition}_{fieldName}
        // For numberedDropdown: {baseNodeId}_{dropdownFieldName}_{entryNumber}
        if (isMultipleTextboxes && sanitizedDropdownName && sanitizedTriggerCondition) {
          select.id = sanitizedDropdownName + '_' + sanitizedTriggerCondition + '_' + sanitizedTriggerFieldName;
        } else {
          // Use the parent dropdown's nodeId (passed as parameter) instead of the question nodeId
          // If not provided, fallback to question nodeId
          const baseNodeId = parentDropdownNodeId || (questionNameIds[questionId] || ('answer' + questionId));
          // Format: {baseNodeId}_{dropdownFieldName}_{entryNumber}
          select.id = baseNodeId + "_" + sanitizedTriggerFieldName + "_" + entryNumber;
        }
        select.name = select.id;
        select.style.cssText = 'width: 200px; padding: 10px; border: 1px solid #87CEEB; border-radius: 8px; font-size: 14px; background-color: white; color: #2c3e50; cursor: pointer; transition: all 0.2s ease; margin: 0 auto; display: block;';
        // Add placeholder option
        const placeholderOption = document.createElement('option');
        placeholderOption.value = '';
        placeholderOption.textContent = 'Select an option...';
        placeholderOption.disabled = true;
        placeholderOption.selected = true;
        select.appendChild(placeholderOption);
        // Add dropdown options
        const dropdownOptions = triggerField.options || [];
        dropdownOptions.forEach((option) => {
          const optionElement = document.createElement('option');
          optionElement.value = option.text;
          optionElement.textContent = option.text;
          select.appendChild(optionElement);
        });
        // Add hover effect
        select.addEventListener('mouseenter', function() {
          this.style.borderColor = '#5DADE2';
          this.style.backgroundColor = '#f8f9ff';
        });
        select.addEventListener('mouseleave', function() {
          this.style.borderColor = '#87CEEB';
          this.style.backgroundColor = 'white';
        });
        // Create wrapper div for hidden checkboxes (required for dropdownMirror)
        const dropdownWrapper = document.createElement('div');
        dropdownWrapper.id = 'dropdowntext_' + select.id;
        dropdownWrapper.style.display = 'none';
        dropdownWrapper.style.margin = '0';
        dropdownWrapper.style.padding = '0';
        // Create hidden text input (required for dropdownMirror)
        const hiddenDropdownInput = document.createElement('input');
        hiddenDropdownInput.type = 'text';
        hiddenDropdownInput.id = select.id + '_dropdown';
        hiddenDropdownInput.name = select.id + '_dropdown';
        hiddenDropdownInput.style.display = 'none';
        dropdownWrapper.appendChild(hiddenDropdownInput);
        // Add change event listener to call dropdownMirror
        select.addEventListener('change', function() {
          if (typeof dropdownMirror === 'function') {
            dropdownMirror(this, this.id);
          }
          // Also update hidden logic if needed
          if (typeof updateHiddenLogic === 'function') {
            updateHiddenLogic(this.id, this.value);
          }
          // Trigger conditional logic re-evaluation for all fields in this trigger sequence
          // Wait a bit for dropdownMirror to finish creating/removing checkboxes
          setTimeout(() => {
            // Dispatch a custom event that all conditional logic can listen to
            const recheckEvent = new CustomEvent('triggerDropdownChanged', {
              detail: { 
                entryNumber: entryNumber,
                questionId: questionId,
                triggerContainer: triggerContainer,
                selectId: this.id,
                selectValue: this.value
              }
            });
            window.dispatchEvent(recheckEvent);
          }, 100);
        });
        dropdownFieldDiv.appendChild(select);
        dropdownFieldDiv.appendChild(dropdownWrapper);
        triggerContainer.appendChild(dropdownFieldDiv);
        // Add conditional logic if enabled
        if (hasConditionalLogic && conditionalConditions.length > 0) {
          // CRITICAL: Ensure field is hidden immediately after appending
          dropdownFieldDiv.style.display = 'none';
          // Function to check if any condition is met
          const checkConditionalLogic = () => {
            let anyMatch = false;
            // Use the parent dropdown's nodeId (same as the select.id base)
            const baseNodeIdForCheck = parentDropdownNodeId || (questionNameIds[questionId] || ('answer' + questionId));
            const sanitizedDropdownName = sanitizeForId(dropdownFieldName || '');
            const sanitizedTriggerCondition = triggerCondition ? sanitizeForId(triggerCondition) : '';
            conditionalConditions.forEach((conditionNodeId) => {
              if (!conditionNodeId) return;
              let checkboxId;
              let radioId;
              // For multipleTextboxes trigger dropdowns, checkbox IDs use format: {dropdownName}_{triggerCondition}_{fieldName}_{option}
              // The condition might be just "{fieldName}_{option}" (e.g., "dropdown2_yes")
              // So we need to construct: {sanitizedDropdownName}_{sanitizedTriggerCondition}_{conditionNodeId}
              if (isMultipleTextboxes && sanitizedDropdownName && sanitizedTriggerCondition) {
                // For multipleTextboxes, the checkbox ID is: {dropdownName}_{triggerCondition}_{conditionNodeId}
                checkboxId = sanitizedDropdownName + '_' + sanitizedTriggerCondition + '_' + conditionNodeId;
                radioId = checkboxId + '_radio';
              } else {
                // For numberedDropdown, use the standard format
                const simpleCheckboxId = conditionNodeId + "_" + entryNumber;
                const fullCheckboxId = baseNodeIdForCheck + "_" + conditionNodeId + "_" + entryNumber;
                const noEntryCheckboxId = conditionNodeId;
                checkboxId = fullCheckboxId; // Use the full pattern for dropdown hidden checkboxes
                radioId = conditionNodeId + "_" + entryNumber + "_radio";
                // We'll try fallbacks (simple/no-entry) below
              }
              // First try to find a radio button (for "Mark only one")
              const radio = document.getElementById(radioId);
              if (radio && radio.type === 'radio') {
                if (radio.checked === true) {
                  anyMatch = true;
                  return;
                }
                // Also check the entire radio group
                const radioGroupName = radio.name;
                const radioGroup = document.querySelectorAll('input[type="radio"][name="' + radioGroupName + '"]');
                const checkedRadio = Array.from(radioGroup).find(r => r.checked === true && r.id === radioId);
                if (checkedRadio) {
                  anyMatch = true;
                  return;
                }
              }
              // Try to find a regular checkbox or hidden checkbox
              let checkbox = document.getElementById(checkboxId);
              // For numberedDropdown, also try simple and no-entry fallbacks
              if (!checkbox && !isMultipleTextboxes) {
                const simpleCheckboxId = conditionNodeId + "_" + entryNumber;
                const noEntryCheckboxId = conditionNodeId;
                checkbox = document.getElementById(simpleCheckboxId);
                if (!checkbox) checkbox = document.getElementById(noEntryCheckboxId);
              }
              if (checkbox && checkbox.type === 'checkbox') {
                if (checkbox.checked === true) {
                  // Double-check: if this is a hidden checkbox for a radio, verify the radio is checked
                  const correspondingRadio = document.getElementById(radioId);
                  if (correspondingRadio) {
                    if (correspondingRadio.checked === true) {
                      anyMatch = true;
                      return;
                    }
                  } else {
                    // This is a regular checkbox or hidden checkbox from dropdown
                    anyMatch = true;
                    return;
                  }
                } else {
                }
              } else {
                // Debug: List all checkboxes in the document to see what exists
                const allCheckboxes = document.querySelectorAll('input[type="checkbox"]');
              }
            });
            // Show or hide the dropdown field based on match
            if (anyMatch) {
              dropdownFieldDiv.style.display = 'block';
            } else {
              dropdownFieldDiv.style.display = 'none';
              // Reset dropdown value when hidden
              select.value = '';
              select.dispatchEvent(new Event('change'));
            }
          };
          // Listen for radio group changes
          const radioGroupHandler = function(event) {
            const eventEntryNumber = event.detail && event.detail.entryNumber;
            if (eventEntryNumber != null && String(eventEntryNumber) === String(entryNumber)) {
              setTimeout(() => {
                checkConditionalLogic();
              }, 200);
            }
          };
          window.addEventListener('radioGroupChanged', radioGroupHandler);
          // Listen for trigger dropdown changes to re-evaluate conditional logic
          const triggerDropdownHandler = function(event) {
            const eventEntryNumber = event.detail && event.detail.entryNumber;
            const eventQuestionId = event.detail && event.detail.questionId;
            const eventCheckboxId = event.detail && event.detail.checkboxId;
            // Re-check if:
            // 1. It's for the same entry and question (from the change event in the dropdown)
            // 2. OR if a checkbox was created/removed that matches one of our conditions
            let shouldRecheck = false;
            if (eventEntryNumber != null && String(eventEntryNumber) === String(entryNumber) && 
                eventQuestionId != null && String(eventQuestionId) === String(questionId)) {
              shouldRecheck = true;
            } else if (eventEntryNumber != null && String(eventEntryNumber) === String(entryNumber) && eventCheckboxId) {
              // Check if the created/removed checkbox matches any of our conditions
              conditionalConditions.forEach((conditionNodeId) => {
                if (!conditionNodeId) return;
                let expectedCheckboxId;
                if (isMultipleTextboxes && sanitizedDropdownName && sanitizedTriggerCondition) {
                  // For multipleTextboxes, checkbox ID is: {dropdownName}_{triggerCondition}_{conditionNodeId}
                  expectedCheckboxId = sanitizedDropdownName + '_' + sanitizedTriggerCondition + '_' + conditionNodeId;
                } else {
                  // For numberedDropdown, use standard format
                  const baseNodeIdForCheck = parentDropdownNodeId || (questionNameIds[questionId] || ('answer' + questionId));
                  expectedCheckboxId = baseNodeIdForCheck + "_" + conditionNodeId + "_" + entryNumber;
                }
                if (eventCheckboxId === expectedCheckboxId) {
                  shouldRecheck = true;
                }
              });
            }
            if (shouldRecheck) {
              // Use a delay to ensure dropdownMirror has finished creating/removing checkboxes
              setTimeout(() => {
                checkConditionalLogic();
              }, 150);
            } else {
            }
          };
          window.addEventListener('triggerDropdownChanged', triggerDropdownHandler);
          // Set up listeners for each condition checkbox/radio
          conditionalConditions.forEach((conditionNodeId) => {
            if (!conditionNodeId) return;
            let checkboxId;
            let radioId;
            // For multipleTextboxes trigger dropdowns, checkbox IDs use format: {dropdownName}_{triggerCondition}_{fieldName}_{option}
            if (isMultipleTextboxes && sanitizedDropdownName && sanitizedTriggerCondition) {
              checkboxId = sanitizedDropdownName + '_' + sanitizedTriggerCondition + '_' + conditionNodeId;
              radioId = checkboxId + '_radio';
            } else {
              // For numberedDropdown, use the standard format
              const baseNodeIdForCheck = parentDropdownNodeId || (questionNameIds[questionId] || ('answer' + questionId));
              const simpleCheckboxId = conditionNodeId + "_" + entryNumber;
              const fullCheckboxId = baseNodeIdForCheck + "_" + conditionNodeId + "_" + entryNumber;
              checkboxId = fullCheckboxId; // Use full pattern for dropdown hidden checkboxes
              radioId = conditionNodeId + "_" + entryNumber + "_radio";
            }
            const attachListener = () => {
              // Try to find checkbox first
              let element = document.getElementById(checkboxId);
              let isRadio = false;
              // For numberedDropdown, also try simple pattern as fallback
              if (!element && !isMultipleTextboxes) {
                const simpleCheckboxId = conditionNodeId + "_" + entryNumber;
                element = document.getElementById(simpleCheckboxId);
              }
              // If not found, try to find radio button
              if (!element) {
                element = document.getElementById(radioId);
                isRadio = true;
              }
              if (element) {
                if (isRadio) {
                  element.addEventListener('change', checkConditionalLogic);
                } else {
                  element.addEventListener('change', checkConditionalLogic);
                }
              } else {
                // Element not found yet, try again after a delay
                setTimeout(attachListener, 100);
              }
            };
            // Start trying to attach listener
            attachListener();
          });
          // Initial check after a delay to ensure all checkboxes are created
          setTimeout(() => {
            checkConditionalLogic();
          }, 500);
          // Also check after a longer delay for autofilled dropdowns
          setTimeout(() => {
            checkConditionalLogic();
          }, 2000);
        }
      } else if (triggerField.type === 'date') {
        const fieldDiv = document.createElement('div');
        // Check if conditional logic is enabled
        const hasConditionalLogic = triggerField.conditionalLogic && triggerField.conditionalLogic.enabled;
        const conditionalConditions = hasConditionalLogic && triggerField.conditionalLogic.conditions ? triggerField.conditionalLogic.conditions : [];
        // Initially hide if conditional logic is enabled
        if (hasConditionalLogic) {
          fieldDiv.style.cssText = 'margin: 10px 0; padding: 12px; background-color: white; border: 1px solid #87CEEB; border-radius: 8px; display: none; flex-direction: column; align-items: center; box-shadow: 0 1px 3px rgba(135, 206, 235, 0.1);';
        } else {
          fieldDiv.style.cssText = 'margin: 10px 0; padding: 12px; background-color: white; border: 1px solid #87CEEB; border-radius: 8px; display: flex; flex-direction: column; align-items: center; box-shadow: 0 1px 3px rgba(135, 206, 235, 0.1);';
        }
        const label = document.createElement('label');
        label.textContent = triggerField.label + ":";
        label.style.cssText = 'display: block; margin-bottom: 8px; font-weight: bold; color: #2980b9; font-size: 15px; text-align: center;';
        const input = document.createElement('input');
        input.type = 'date';
        // For multipleTextboxes: use nodeId directly from JSON (e.g., "hello_yes_when")
        // For numberedDropdown: {fieldName}_{entryNumber}
        if (isMultipleTextboxes) {
          // Use the nodeId directly as specified in the JSON
          input.id = triggerField.nodeId || triggerField.label;
        } else {
          input.id = triggerField.nodeId + "_" + entryNumber;
        }
        input.name = input.id;
        input.style.cssText = 'width: 200px; padding: 10px; border: 1px solid #87CEEB; border-radius: 8px; font-size: 14px; background-color: white; color: #2c3e50; cursor: pointer; transition: all 0.2s ease;';
        // Make the entire field div clickable to show calendar
        fieldDiv.addEventListener('click', function() {
          input.focus();
          input.showPicker && input.showPicker();
        });
        // Add hover effect
        input.addEventListener('mouseenter', function() {
          this.style.borderColor = '#5DADE2';
          this.style.backgroundColor = '#f8f9ff';
        });
        input.addEventListener('mouseleave', function() {
          this.style.borderColor = '#87CEEB';
          this.style.backgroundColor = 'white';
        });
        fieldDiv.appendChild(label);
        fieldDiv.appendChild(input);
        triggerContainer.appendChild(fieldDiv);
        // Add conditional logic if enabled
        if (hasConditionalLogic && conditionalConditions.length > 0) {
          // CRITICAL: Ensure field is hidden immediately after appending
          fieldDiv.style.display = 'none';
          // Function to check if any condition is met
          const checkConditionalLogic = () => {
            let anyMatch = false;
            // Prefer the parent dropdown's nodeId; fall back to question nodeId
            const baseNodeIdForCheck = parentDropdownNodeId || (questionNameIds[questionId] || ('answer' + questionId));
            const sanitizedDropdownName = sanitizeForId(dropdownFieldName || '');
            const sanitizedTriggerCondition = triggerCondition ? sanitizeForId(triggerCondition) : '';
            conditionalConditions.forEach((conditionNodeId) => {
              if (!conditionNodeId) return;
              // Hidden checkboxes created by dropdownMirror in trigger sequences can be:
              // 1) For numberedDropdown: questionNodeId_condition_entryNumber (full), condition_entryNumber (simple), condition (no entry)
              // 2) For multipleTextboxes trigger dropdowns: dropdownName_triggerCondition_condition
              let checkboxId;
              let radioId;
              if (isMultipleTextboxes) {
                checkboxId = sanitizedDropdownName + '_' + sanitizedTriggerCondition + '_' + conditionNodeId;
                radioId = checkboxId + '_radio';
              } else {
                const simpleCheckboxId = conditionNodeId + "_" + entryNumber;
                const fullCheckboxId = baseNodeIdForCheck + "_" + conditionNodeId + "_" + entryNumber;
                const noEntryCheckboxId = conditionNodeId;
                checkboxId = fullCheckboxId; // primary
                radioId = conditionNodeId + "_" + entryNumber + "_radio";
                // We'll try full â†’ simple â†’ no-entry below
              }
              // First try to find a radio button (for "Mark only one")
              const radio = document.getElementById(radioId);
              if (radio && radio.type === 'radio') {
                // Check the actual checked state of the radio button directly
                // This is the most reliable way to check radio button state
                if (radio.checked === true) {
                  anyMatch = true;
                  return;
                }
                // Also check the entire radio group to see which radio is checked
                // This handles cases where the radio might not be found but the group has a checked radio
                const radioGroupName = radio.name;
                const radioGroup = document.querySelectorAll('input[type="radio"][name="' + radioGroupName + '"]');
                const checkedRadio = Array.from(radioGroup).find(r => r.checked === true && r.id === radioId);
                if (checkedRadio) {
                  anyMatch = true;
                  return;
                } else {
                  // Check which radio IS checked in the group
                  const actuallyChecked = Array.from(radioGroup).find(r => r.checked === true);
                }
              }
              // Try to find a regular checkbox or hidden checkbox
              let checkbox = document.getElementById(checkboxId);
              if (!isMultipleTextboxes) {
                // For numberedDropdown, also try simple and no-entry fallbacks
                const simpleCheckboxId = conditionNodeId + "_" + entryNumber;
                const noEntryCheckboxId = conditionNodeId;
                if (!checkbox) checkbox = document.getElementById(simpleCheckboxId);
                if (!checkbox) checkbox = document.getElementById(noEntryCheckboxId);
              }
              if (checkbox && checkbox.type === 'checkbox') {
                // For hidden checkboxes, verify they're actually checked
                // Hidden checkboxes should only be checked if their corresponding radio is checked
                if (checkbox.checked === true) {
                  // Double-check: if this is a hidden checkbox for a radio, verify the radio is checked
                  const correspondingRadio = document.getElementById(radioId);
                  if (correspondingRadio) {
                    // This is a hidden checkbox for a radio - verify the radio is actually checked
                    if (correspondingRadio.checked === true) {
                      anyMatch = true;
                      return;
                    } else {
                    }
                  } else {
                    // This is a regular checkbox or hidden checkbox from dropdown, not a hidden one for radio
                    anyMatch = true;
                    return;
                  }
                } else {
                }
              }
            });
            // Show or hide the date field based on match
            if (anyMatch) {
              fieldDiv.style.display = 'flex';
            } else {
              fieldDiv.style.display = 'none';
            }
          };
          // CRITICAL: Always set up radioGroupChanged listener for this entry's date field
          // This ensures we catch radio button changes even if the specific radio hasn't been found yet
          const radioGroupHandler = function(event) {
            // Compare entry numbers (handle both string and number types)
            const eventEntryNumber = event.detail && event.detail.entryNumber;
            const currentEntryNumber = String(entryNumber);
            const eventEntryNumberStr = eventEntryNumber != null ? String(eventEntryNumber) : null;
            if (eventEntryNumber != null && String(eventEntryNumber) === String(entryNumber)) {
              // Use a longer delay to ensure DOM is fully updated (hidden checkboxes removed/created)
              setTimeout(() => {
                checkConditionalLogic();
              }, 200);
            } else {
            }
          };
          window.addEventListener('radioGroupChanged', radioGroupHandler);
          // Also listen for trigger dropdown changes to re-evaluate conditional logic
          const triggerDropdownHandler = function(event) {
            const eventEntryNumber = event.detail && event.detail.entryNumber;
            const eventQuestionId = event.detail && event.detail.questionId;
            // Only re-check if this is for the same entry and question
            if (eventEntryNumber != null && String(eventEntryNumber) === String(entryNumber) && 
                eventQuestionId != null && String(eventQuestionId) === String(questionId)) {
              // Use a delay to ensure dropdownMirror has finished creating/removing checkboxes
              setTimeout(() => {
                checkConditionalLogic();
              }, 150);
            }
          };
          window.addEventListener('triggerDropdownChanged', triggerDropdownHandler);
          // Set up event listeners for each condition
          conditionalConditions.forEach((conditionNodeId) => {
            if (!conditionNodeId) return;
            // Prefer the parent dropdown's nodeId; fall back to question nodeId
            const baseNodeIdForCheck = parentDropdownNodeId || (questionNameIds[questionId] || ('answer' + questionId));
            // Try both patterns: full (for dropdown hidden checkboxes) and simple (for regular checkboxes)
            const simpleCheckboxId = conditionNodeId + "_" + entryNumber;
            const fullCheckboxId = baseNodeIdForCheck + "_" + conditionNodeId + "_" + entryNumber;
            const checkboxId = fullCheckboxId; // Use full pattern for dropdown hidden checkboxes
            const radioId = conditionNodeId + "_" + entryNumber + "_radio";
            // Function to attach listener when element is created
            const attachListener = (attemptCount = 0) => {
              const maxAttempts = 100; // Increased attempts for dynamic entries
              // Try to find checkbox first - try full pattern, then simple pattern
              let element = document.getElementById(checkboxId);
              let isRadio = false;
              // If not found with full pattern, try simple pattern
              if (!element) {
                element = document.getElementById(simpleCheckboxId);
              }
              // If not found, try to find radio button
              if (!element) {
                element = document.getElementById(radioId);
                isRadio = true;
              }
              if (element) {
                const newCheckConditionalLogic = () => {
                  // Delay to ensure DOM is fully updated (hidden checkboxes removed/created for radios)
                  // Use longer delay for radio buttons to ensure state is consistent
                  const delay = isRadio && element.type === 'radio' ? 200 : 10;
                  setTimeout(() => {
                    checkConditionalLogic();
                  }, delay);
                };
                element.addEventListener('change', newCheckConditionalLogic);
                element.addEventListener('click', newCheckConditionalLogic);
                // For radio buttons, also listen to all radios in the same group
                if (isRadio && element.type === 'radio') {
                  const radioGroupName = element.name;
                  // Extract entry number from radio group name to ensure we're listening to the right group
                  const radioGroupEntryMatch = radioGroupName.match(/radio_group_(d+)/);
                  const radioGroupEntryNumber = radioGroupEntryMatch ? parseInt(radioGroupEntryMatch[1]) : entryNumber;
                  // Only set up listeners if this radio group matches our entry number
                  if (radioGroupEntryNumber === entryNumber) {
                    const radioGroup = document.querySelectorAll('input[name="' + radioGroupName + '"]');
                    radioGroup.forEach(radio => {
                      // Add listener to all other radios in the group (element already has listener)
                      if (radio !== element) {
                        radio.addEventListener('change', newCheckConditionalLogic);
                        radio.addEventListener('click', newCheckConditionalLogic);
                      }
                    });
                  } else {
                  }
                }
                // Also check initial state
                setTimeout(() => checkConditionalLogic(), 50);
              } else if (attemptCount < maxAttempts) {
                setTimeout(() => attachListener(attemptCount + 1), 100);
              }
            };
            // Start trying to attach listener
            attachListener();
          });
          // Check on initial load with delays to catch different timing scenarios
          setTimeout(() => checkConditionalLogic(), 100);
          setTimeout(() => checkConditionalLogic(), 500);
          setTimeout(() => checkConditionalLogic(), 1000);
          setTimeout(() => checkConditionalLogic(), 2000);
        }
      } else if (triggerField.type === 'location') {
        // Handle simplified location field format ("Location Data Added")
        // Create location field container
        const locationFieldDiv = document.createElement('div');
        locationFieldDiv.style.cssText = 'margin: 10px 0; padding: 12px; background-color: #ffffff; border: 1px solid #e1e5e9; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.05); display: flex; flex-direction: column; align-items: center;';
        const fieldNameLabel = document.createElement('label');
        fieldNameLabel.textContent = (triggerField.fieldName || 'Location Data') + ':';
        fieldNameLabel.style.cssText = 'display: block; margin-bottom: 8px; font-weight: 600; color: #333; font-size: 15px; text-align: center;';
        locationFieldDiv.appendChild(fieldNameLabel);
        // Create location fields (Street, City, State, Zip)
        const locationFields = [
          { label: 'Street', nodeId: 'street' },
          { label: 'City', nodeId: 'city' },
          { label: 'State', nodeId: 'state' },
          { label: 'Zip', nodeId: 'zip' }
        ];
        // Build locPrefix: dropdown fieldName + location field's fieldName
        // Use the sanitizeForId helper function
        const sanitizedDropdownNameForLocation = sanitizeForId(dropdownFieldName || 'dropdown');
        const locationFieldName = triggerField.fieldName || 'location';
        const sanitizedLocationName = sanitizeForId(locationFieldName);
        // Combine: dropdown name + location field name
        // For multipleTextboxes: {dropdownName}_{locationFieldName} (no entry number, no trigger condition)
        // For numberedDropdown: {dropdownName}_{locationFieldName} (entry number added per field)
        const locPrefix = sanitizedDropdownNameForLocation + '_' + sanitizedLocationName;

        // Create hidden full_address field (stores complete address like "921 Sloat Road, Salinas, CA 93907")
        const fullAddressHidden = document.createElement('input');
        fullAddressHidden.type = 'text';
        if (isMultipleTextboxes) {
          fullAddressHidden.id = locPrefix + '_full_address';
        } else {
          fullAddressHidden.id = locPrefix + '_full_address_' + entryNumber;
        }
        fullAddressHidden.name = fullAddressHidden.id;
        fullAddressHidden.style.display = 'none';
        const fullAddressId = fullAddressHidden.id;

        // Define field IDs for the update function (varies based on multipleTextboxes or numberedDropdown)
        const triggerStreetFieldId = isMultipleTextboxes ? locPrefix + '_street' : locPrefix + '_street_' + entryNumber;
        const triggerCityFieldId = isMultipleTextboxes ? locPrefix + '_city' : locPrefix + '_city_' + entryNumber;
        const triggerStateShortFieldId = isMultipleTextboxes ? locPrefix + '_state_short' : locPrefix + '_state_short_' + entryNumber;
        const triggerZipFieldId = isMultipleTextboxes ? locPrefix + '_zip' : locPrefix + '_zip_' + entryNumber;

        // Helper function code to update full address (using escaped backticks since we're inside formHTML template literal)
        const triggerUpdateFullAddressCode = "(function() { " +
            "var streetEl = document.getElementById('" + triggerStreetFieldId + "'); " +
            "var cityEl = document.getElementById('" + triggerCityFieldId + "'); " +
            "var stateShortEl = document.getElementById('" + triggerStateShortFieldId + "'); " +
            "var zipEl = document.getElementById('" + triggerZipFieldId + "'); " +
            "var fullAddressEl = document.getElementById('" + fullAddressId + "'); " +
            "if (!fullAddressEl) { return; } " +
            "var street = streetEl ? streetEl.value.trim() : ''; " +
            "var city = cityEl ? cityEl.value.trim() : ''; " +
            "var stateShort = stateShortEl ? stateShortEl.value.trim() : ''; " +
            "var zip = zipEl ? zipEl.value.trim() : ''; " +
            "" +
            "var parts = []; " +
            "if (street) parts.push(street); " +
            "if (city && stateShort && zip) { parts.push(city + ', ' + stateShort + ' ' + zip); } " +
            "else if (city && stateShort) { parts.push(city + ', ' + stateShort); } " +
            "else if (city && zip) { parts.push(city + ' ' + zip); } " +
            "else if (city) { parts.push(city); } " +
            "else if (stateShort && zip) { parts.push(stateShort + ' ' + zip); } " +
            "else if (stateShort) { parts.push(stateShort); } " +
            "else if (zip) { parts.push(zip); } " +
            "var fullAddress = parts.join(', '); " +
            "fullAddressEl.value = fullAddress; " +
            "" +
            "})();";

        locationFields.forEach((field, fieldIndex) => {
          let input;
          if (field.label === 'State') {
            // Create state dropdown
            input = document.createElement('select');
            // For multipleTextboxes: {dropdownName}_{locationFieldName}_{fieldType}
            // For numberedDropdown: {dropdownName}_{locationFieldName}_{fieldType}_{entryNumber}
            if (isMultipleTextboxes) {
              input.id = locPrefix + '_' + field.nodeId;
            } else {
              input.id = locPrefix + '_' + field.nodeId + "_" + entryNumber;
            }
            input.name = input.id;
            input.className = 'address-select-main';

            // Create hidden full state field (stores full state name like "California")
            const fullHidden = document.createElement('input');
            fullHidden.type = 'text';
            if (isMultipleTextboxes) {
              fullHidden.id = locPrefix + '_state_hidden';
            } else {
              fullHidden.id = locPrefix + '_state_hidden_' + entryNumber;
            }
            fullHidden.name = fullHidden.id;
            fullHidden.style.display = 'none';

            // Hidden short code field (stores "CA")
            const shortHidden = document.createElement('input');
            shortHidden.type = 'text';
            if (isMultipleTextboxes) {
              shortHidden.id = locPrefix + '_state_short';
            } else {
              shortHidden.id = locPrefix + '_state_short_' + entryNumber;
            }
            shortHidden.name = shortHidden.id;
            shortHidden.style.display = 'none';

            // Add state options
            const states = [
              'Alabama','Alaska','Arizona','Arkansas','California','Colorado','Connecticut','Delaware',
              'Florida','Georgia','Hawaii','Idaho','Illinois','Indiana','Iowa','Kansas','Kentucky',
              'Louisiana','Maine','Maryland','Massachusetts','Michigan','Minnesota','Mississippi','Missouri',
              'Montana','Nebraska','Nevada','New Hampshire','New Jersey','New Mexico','New York',
              'North Carolina','North Dakota','Ohio','Oklahoma','Oregon','Pennsylvania','Rhode Island',
              'South Carolina','South Dakota','Tennessee','Texas','Utah','Vermont','Virginia',
              'Washington','West Virginia','Wisconsin','Wyoming'
            ];
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select State';
            input.appendChild(defaultOption);
            states.forEach(state => {
              const option = document.createElement('option');
              option.value = state;
              option.textContent = state;
              input.appendChild(option);
            });

            // CRITICAL FIX: Use inline onchange attribute instead of addEventListener
            // addEventListener does NOT persist when DOM is serialized to HTML via outerHTML
            const fullHiddenId = fullHidden.id;
            const shortHiddenId = shortHidden.id;
            const selectId = input.id;
            // Build onchange handler using string concatenation to avoid nested template literal issues
            input.setAttribute('onchange', 
              "" +
              "" +
              "" +
              "" +
              "" +
              "var fullField = document.getElementById('" + fullHiddenId + "');" +
              "var shortField = document.getElementById('" + shortHiddenId + "');" +
              "" +
              "" +
              "if (typeof updateStateHiddenFields === 'function') {" +
              "  " +
              "  updateStateHiddenFields(this, '" + fullHiddenId + "', '" + shortHiddenId + "');" +
              "  " +
              "  " +
              "} else {" +
              "  " +
              "}" +
              "if (typeof dropdownMirror === 'function') {" +
              "  dropdownMirror(this, '" + selectId + "');" +
              "}" +
              "if (typeof updateHiddenLogic === 'function') {" +
              "  updateHiddenLogic('" + selectId + "', this.value);" +
              "}" +
              "setTimeout(function() { " + triggerUpdateFullAddressCode + " }, 50);"
            );

            // Append hidden fields
            const hiddenWrap = document.createElement('div');
            hiddenWrap.style.display = 'none';
            hiddenWrap.appendChild(fullHidden);
            hiddenWrap.appendChild(shortHidden);
            locationFieldDiv.appendChild(hiddenWrap);
          } else {
            // Create text input for other fields
            input = document.createElement('input');
            input.type = field.label === 'Zip' ? 'number' : 'text';
            // For multipleTextboxes: {dropdownName}_{locationFieldName}_{fieldType}
            // For numberedDropdown: {dropdownName}_{locationFieldName}_{fieldType}_{entryNumber}
            if (isMultipleTextboxes) {
              input.id = locPrefix + '_' + field.nodeId;
            } else {
              input.id = locPrefix + '_' + field.nodeId + "_" + entryNumber;
            }
            input.name = input.id;
            input.placeholder = field.label; // e.g., Street, City, Zip
            input.className = 'address-input';
            input.style.textAlign = 'center'; // Ensure text is centered
            // Add oninput handler to update full address when street, city, or zip changes
            input.setAttribute('oninput', triggerUpdateFullAddressCode);
          }
          // Wrap each input in an .address-field div so margins apply
          const addrWrap = document.createElement('div');
          addrWrap.className = 'address-field';
          addrWrap.appendChild(input);
          locationFieldDiv.appendChild(addrWrap);
        });
        // Add the full_address hidden field to the location div
        const fullAddressWrap = document.createElement('div');
        fullAddressWrap.style.display = 'none';
        fullAddressWrap.appendChild(fullAddressHidden);
        locationFieldDiv.appendChild(fullAddressWrap);
        triggerContainer.appendChild(locationFieldDiv);
      } else if (triggerField.type === 'pdf') {
        // PDF fields are handled separately by PDF logic evaluation
        // No need to render them in the form - they will be automatically
        // added to cart/download when the trigger condition is met
        // Skip rendering this field - return from forEach callback to skip to next iteration
        return;
      }
    });
    parentContainer.appendChild(triggerContainer);
  }

// Helper function to detect if a field is part of a trigger sequence (conditional field)
function isFieldPartOfTriggerSequence(fieldName, fieldId) {
    if (!window.unifiedFieldsMap) return false;
    // Check all questions in unifiedFieldsMap
    for (const questionId in window.unifiedFieldsMap) {
        const fields = window.unifiedFieldsMap[questionId];
        if (Array.isArray(fields)) {
            for (const field of fields) {
                if (field.triggerSequences && Array.isArray(field.triggerSequences)) {
                    for (const sequence of field.triggerSequences) {
                        if (sequence.fields && Array.isArray(sequence.fields)) {
                            for (const triggerField of sequence.fields) {
                                // Check if this field matches the trigger field
                                if (triggerField.nodeId === fieldId || 
                                    triggerField.label === fieldName || 
                                    triggerField.fieldName === fieldName ||
                                    (triggerField.options && triggerField.options.some(opt => opt.nodeId === fieldId))) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return false;
}

(function injectAddressHelpersOnce() {
  if (window.__addressHelpersInjected) return;
  window.__addressHelpersInjected = true;
  // Create stylized address <input>
  window.createAddressInput = function(id, label, index, type = 'text', prefill = '') {
    const inputType = (type === 'number') ? 'number' : 'text';
    const placeholder = label;
    const valueAttr = prefill ? ' value="' + prefill.replace(/"/g, '&quot;') + '"' : '';
    return (
      '<div class="address-field">' +
      '<input type="' + inputType + '" ' +
      'id="' + id + '" ' +
      'name="' + id + '" ' +
      'placeholder="' + placeholder + '" ' +
      'class="address-input"' + valueAttr + '>' +
      '</div>'
    );
  };
  // Create US state dropdown + the two hidden fields (full name + short)
  window.createStateDropdown = function(id, index) {
    const states = [
      'Alabama','Alaska','Arizona','Arkansas','California','Colorado','Connecticut','Delaware',
      'Florida','Georgia','Hawaii','Idaho','Illinois','Indiana','Iowa','Kansas','Kentucky',
      'Louisiana','Maine','Maryland','Massachusetts','Michigan','Minnesota','Mississippi','Missouri',
      'Montana','Nebraska','Nevada','New Hampshire','New Jersey','New Mexico','New York',
      'North Carolina','North Dakota','Ohio','Oklahoma','Oregon','Pennsylvania','Rhode Island',
      'South Carolina','South Dakota','Tennessee','Texas','Utah','Vermont','Virginia',
      'Washington','West Virginia','Wisconsin','Wyoming'
    ];
    let options = '<option value="">Select State</option>';
    states.forEach(state => {
      options += '<option value="' + state + '">' + state + '</option>';
    });
    // Hidden full-state input id (always different from the <select> id)
    const hiddenFullId = id + '_hidden';
    // Hidden short-state input id:
    // transform "how_many_state_1" -> "how_many_state_short_1" (note the d)
    let shortId;
    if (id.includes('_') && /\d+$/.test(id)) {
      const match = id.match(/^(.+)_(\d+)$/);
      if (match) {
        const basePart = match[1];
        const number = match[2];
        shortId = basePart + '_short_' + number;
      } else {
        shortId = id + '_short';
      }
    } else {
      shortId = id + '_short';
    }
    // Keep both text inputs hidden â€” they're for PDF mapping
    return (
      '<div class="address-field">' +
        '<select id="' + id + '" name="' + id + '" class="address-select" ' +
        'onchange="if (window.updateStateHiddenFields) updateStateHiddenFields(this, \'' + hiddenFullId + '\', \'' + shortId + '\');">' +
          options +
        '</select>' +
        '<input type="text" id="' + hiddenFullId + '" name="' + hiddenFullId + '" style="display:none" />' +
        '<input type="text" id="' + shortId + '" name="' + shortId + '" style="display:none" />' +
      '</div>'
    );
  };
  // Derive "..._short_N" from a base id like "how_many_state_N"
  window.toShortIdFromBase = function(baseId){
    const m = baseId.match(/^(.+)_(\d+)$/);
    return m ? m[1] + '_short_' + m[2] : baseId + '_short';
  };
  // Keep these helpers global too (they may be called by onchange/autofill)
  window.updateStateHiddenFields = function(selectEl, fullId, shortId) {

    const fullField  = document.getElementById(fullId);
    const shortField = document.getElementById(shortId);

    if (!fullField || !shortField) {

      // List all hidden inputs to help debug
      var allHiddenInputs = document.querySelectorAll('input[style*="display: none"], input[style*="display:none"]');

      allHiddenInputs.forEach(function(inp) {

      });
      return;
    }

    const full = (selectEl.value || '').trim();

    // Map full -> short (two-letter)
    const map = {
      'Alabama': 'AL','Alaska': 'AK','Arizona': 'AZ','Arkansas': 'AR','California': 'CA','Colorado': 'CO',
      'Connecticut': 'CT','Delaware': 'DE','Florida': 'FL','Georgia': 'GA','Hawaii': 'HI','Idaho': 'ID',
      'Illinois': 'IL','Indiana': 'IN','Iowa': 'IA','Kansas': 'KS','Kentucky': 'KY','Louisiana': 'LA',
      'Maine': 'ME','Maryland': 'MD','Massachusetts': 'MA','Michigan': 'MI','Minnesota': 'MN','Mississippi': 'MS',
      'Missouri': 'MO','Montana': 'MT','Nebraska': 'NE','Nevada': 'NV','New Hampshire': 'NH','New Jersey': 'NJ',
      'New Mexico': 'NM','New York': 'NY','North Carolina': 'NC','North Dakota': 'ND','Ohio': 'OH','Oklahoma': 'OK',
      'Oregon': 'OR','Pennsylvania': 'PA','Rhode Island': 'RI','South Carolina': 'SC','South Dakota': 'SD',
      'Tennessee': 'TN','Texas': 'TX','Utah': 'UT','Vermont': 'VT','Virginia': 'VA','Washington': 'WA',
      'West Virginia': 'WV','Wisconsin': 'WI','Wyoming': 'WY'
    };
    const short = map[full] || '';

    fullField.value  = full;
    shortField.value = short;

  };
})();

/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*
 * return the true checkbox prefix
 *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function getCbPrefix (qId){
    if (questionSlugMap[qId]) return questionSlugMap[qId] + '_';
    if (questionNameIds[qId]) return questionNameIds[qId] + '_';
    return 'answer' + qId + '_';
}
/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*
 * buildCheckboxName(questionId, rawNameId, labelText)
 *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function buildCheckboxName (questionId, rawNameId, labelText){
    let namePart = (rawNameId || '').trim();
    if (!namePart){
        namePart = labelText.replace(/W+/g, '_').toLowerCase();
    }
    // Return the name part directly without adding question prefix
    return namePart;
}

      let isUserLoggedIn = true;
      let userId = null;
      const urlParams = new URLSearchParams(window.location.search);
      const formId = urlParams.get("formId") || window.formId || 'default';
    var jumpLogics = [{"questionId":"2","questionType":"dropdown","jumpOption":"Yes","jumpTo":"end","section":1},{"questionId":"2","questionType":"dropdown","jumpOption":"No","jumpTo":"end","section":1}];
var conditionalPDFs = [];
var pdfLogicPDFs = [];
var checkboxPdfEntries = [];
var alertLogics = [];
var checklistLogics = [];
var checklistItems = [];
var conditionalAlerts = [];
var labelMap = {"length":0};
var amountMap = {"length":0};
var labelNodeIdsMap = {};
var linkedDropdowns = [];
var hiddenLogicConfigs = [];
var linkedFields = [];
var isHandlingLink = false;

// Dynamic conditional logic for business type question to show county question
function setupBusinessTypeConditionalLogic() {
  // Use dynamic approach - find question 11's name from questionNameIds
  const businessTypeQuestionName = questionNameIds['11'] || 'what_are_you_doing_business_as';
  // Find all radio buttons for the business type question
  const businessTypeRadios = document.querySelectorAll('input[name="' + businessTypeQuestionName + '"]');
  businessTypeRadios.forEach(radio => {
    radio.addEventListener('change', function() {
      if (this.checked) {
        // Show county question (question-container-16) when any business type is selected
        const countyQuestion = document.getElementById('question-container-16');
        if (countyQuestion) {
          countyQuestion.classList.remove('hidden');
        } else {
        }
      }
    });
  });
}
// Set up the conditional logic when the page loads
document.addEventListener('DOMContentLoaded', function() {
  setupBusinessTypeConditionalLogic();
});
// Also set it up immediately in case DOMContentLoaded already fired
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', setupBusinessTypeConditionalLogic);
} else {
  setupBusinessTypeConditionalLogic();
}
// Function to get URL parameters
function getUrlParameter(name) {
    const urlParams = new URLSearchParams(window.location.search);
    const value = urlParams.get(name);
    
    return value;
}

// Function to populate hidden fields from URL parameters
function populateHiddenFieldsFromUrl() {
    const zipCode = getUrlParameter("zipCode");
    const county = getUrlParameter("county");
    const defendant = getUrlParameter("defendant");
    const formId = getUrlParameter("formId");
    
    if (zipCode) {
        const zipField = document.getElementById("form_zip");
        if (zipField) zipField.value = zipCode;
    }
    
    if (county) {
        const countyField = document.getElementById("form_county");
        if (countyField) countyField.value = county;
    }
    
    if (defendant) {
        const defendantField = document.getElementById("form_defendant");
        if (defendantField) defendantField.value = defendant;
    }
    
        if (formId) {
        const formIdField = document.getElementById("form_ID");
        if (formIdField) formIdField.value = formId;
    }
    
}

// County Lookup Functionality
const zipCodeToCounty = {};

const countyToCourt = {};

function getCourtByCounty(countyName) {
    return countyToCourt[countyName] || null;
}

function formatCourtAddress(courtInfo) {
    if (!courtInfo) return null;
    return courtInfo.address + ", " + courtInfo.city + ", " + courtInfo.state + " " + courtInfo.zip;
}

function getCourtFromZipCode(zipCode) {
    const county = zipCodeToCounty[zipCode];
    if (!county) return null;
    const courtInfo = getCourtByCounty(county);
    if (!courtInfo) return { county: county, error: "Court information not found for this county" };
    return {
        county: county,
        courtName: courtInfo.name,
        address: courtInfo.address,
        city: courtInfo.city,
        state: courtInfo.state,
        zip: courtInfo.zip,
        phone: courtInfo.phone,
        fullAddress: formatCourtAddress(courtInfo)
    };
}

function lookupCourtFromZip() {
    const zipField = document.getElementById("form_zip");
    const courtNameField = document.getElementById("court_name");
    const courtAddressField = document.getElementById("court_address");
    if (!zipField || !courtNameField || !courtAddressField) return;
    const zipCode = zipField.value.trim();
    if (zipCode.length === 5) {
        const courtInfo = getCourtFromZipCode(zipCode);
        if (courtInfo && courtInfo.courtName) {
            courtNameField.value = courtInfo.courtName;
            courtAddressField.value = courtInfo.fullAddress || "";
        } else {
            courtNameField.value = "";
            courtAddressField.value = "";
        }
    } else {
        courtNameField.value = "";
        courtAddressField.value = "";
    }
}

document.addEventListener("DOMContentLoaded", function() {
    const zipField = document.getElementById("form_zip");
    if (zipField) {
        zipField.addEventListener("input", lookupCourtFromZip);
        zipField.addEventListener("change", lookupCourtFromZip);
        if (zipField.value) {
            setTimeout(lookupCourtFromZip, 100);
        }
    }
});

// Function to replace URL parameter placeholders in text
function replaceUrlParametersInText(text) {
    if (!text || typeof text !== 'string') {
        
        return text;
    }
    
    
    
    // Replace [paramName] with URL parameter value
    const result = text.replace(/\[([^\]]+)\]/g, function(match, paramName) {
        const value = getUrlParameter(paramName);
        
        return value || match; // Return the value if found, otherwise keep the placeholder
    });
    
    
    return result;
}

// Function to replace URL parameters in all question text, section names, etc.
function replaceUrlParametersInForm() {
    // Replace in section titles
    document.querySelectorAll('.section-title').forEach(function(el) {
        if (el.textContent) {
            el.textContent = replaceUrlParametersInText(el.textContent);
        }
    });
    
    // Replace in question text
    document.querySelectorAll('.question-text').forEach(function(el) {
        if (el.textContent) {
            el.textContent = replaceUrlParametersInText(el.textContent);
        }
    });
    
    // Replace in question labels
    document.querySelectorAll('label[for^="question"], label.question-label').forEach(function(el) {
        if (el.textContent) {
            el.textContent = replaceUrlParametersInText(el.textContent);
        }
    });
    
    // Replace in subtitles
    document.querySelectorAll('.subtitle-text').forEach(function(el) {
        if (el.textContent) {
            el.textContent = replaceUrlParametersInText(el.textContent);
        }
    });
    
    // Replace in info boxes
    document.querySelectorAll('.info-box-text').forEach(function(el) {
        if (el.textContent) {
            el.textContent = replaceUrlParametersInText(el.textContent);
        }
    });
    
    // Replace in conditional alert messages
    document.querySelectorAll('.alert-message').forEach(function(el) {
        if (el.textContent) {
            el.textContent = replaceUrlParametersInText(el.textContent);
        }
    });
}

// Function to replace URL parameters in prefill values
function replaceUrlParametersInPrefillValues() {
    if (!window.unifiedFieldsMap) return;
    
    Object.keys(window.unifiedFieldsMap).forEach(function(questionId) {
        const fields = window.unifiedFieldsMap[questionId];
        if (Array.isArray(fields)) {
            fields.forEach(function(field) {
                if (field.type === 'label' && field.prefill && field.nodeId) {
                    // Find all input fields that match this nodeId pattern
                    const inputs = document.querySelectorAll('input[id^="' + field.nodeId + '_"]')
                    inputs.forEach(function(input) {
                        // Replace URL parameters in the prefill value
                        const processedPrefill = replaceUrlParametersInText(field.prefill);
                        if (processedPrefill && processedPrefill !== field.prefill) {
                            input.value = processedPrefill;
                            
                        }
                    });
                }
            });
        }
    });
}

// Auto-populate on page load
if (document.readyState === 'loading') {
    document.addEventListener("DOMContentLoaded", function() {
        populateHiddenFieldsFromUrl();
        setupLinkedFields();
        replaceUrlParametersInForm();
        replaceUrlParametersInPrefillValues();
    });
} else {
    // DOM already loaded, run immediately
    populateHiddenFieldsFromUrl();
    setupLinkedFields();
    replaceUrlParametersInForm();
    replaceUrlParametersInPrefillValues();
}

// Function to check paragraph limit and create hidden checkbox
function checkParagraphLimit(textareaId, paragraphLimit) {
    if (!paragraphLimit || paragraphLimit === "null") return;
    
    const textarea = document.getElementById(textareaId);
    if (!textarea) return;
    
    const currentLength = textarea.value.length;
    const checkboxId = textareaId + "_overlimit";
    let checkbox = document.getElementById(checkboxId);
    
    if (currentLength > paragraphLimit) {
        // Create checkbox if it doesn't exist
        if (!checkbox) {
            checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.id = checkboxId;
            checkbox.name = checkboxId;
            checkbox.style.display = "none"; // Hidden checkbox
            checkbox.checked = true;
            
            // Insert after the textarea
            textarea.parentNode.insertBefore(checkbox, textarea.nextSibling);
            
        } else {
            // Check the existing checkbox
            checkbox.checked = true;
        }
    } else {
        // Remove checkbox if it exists and we're under the limit
        if (checkbox) {
            checkbox.remove();
        }
    }
}
var sectionStack = [];
var currentSectionNumber = 1;
var pdfFileName = "SC-100";
var pdfOutputFileName = "sc100.pdf";
var stripePriceId = "price_1SB7CbFJeSRMFQ8X2afGFckf";
var additionalPdfFileNames = [];
var allPdfFileNames = ["sc100", ];
var hiddenCheckboxCalculations = [];
var hiddenTextCalculations = [];


(function(){
 var thisQ=document.getElementById("question-container-2");
 function updateVisibility(){
  var anyMatch=false;
  (function(){
    var cPrevType="dropdown";
    var cPrevAns="no";
    var cPrevQNum="1";
    var el2=document.getElementById(questionNameIds[cPrevQNum]) || document.getElementById("answer"+cPrevQNum);
    if(el2){ var val2= el2.value.trim().toLowerCase(); if(val2===cPrevAns){ anyMatch=true; } else { } }
  })();
  (function(){
    var cPrevType="dropdown";
    var cPrevAns="yes";
    var cPrevQNum="1";
    var el2=document.getElementById(questionNameIds[cPrevQNum]) || document.getElementById("answer"+cPrevQNum);
    if(el2){ var val2= el2.value.trim().toLowerCase(); if(val2===cPrevAns){ anyMatch=true; } else { } }
  })();
 if(anyMatch){ thisQ.classList.remove("hidden"); } else { 
   var hasNumberedDropdown = thisQ.querySelector('select[id^="answer"]') || thisQ.querySelector('select[data-question-id]');
   var questionType = thisQ.getAttribute('data-question-type') || '';
   if(questionType === 'numberedDropdown' || hasNumberedDropdown){
     
     if(typeof resetNumberedDropdownFields === 'function'){
       resetNumberedDropdownFields("2");
     } else {
       
     }
   }
   var allDropdowns = thisQ.querySelectorAll('select');
   for(var d=0; d<allDropdowns.length; d++){
     var dropdown = allDropdowns[d];
     // Skip if this dropdown is part of a trigger sequence (nested dropdowns)
     if(dropdown.closest('[id^="triggerFields"]')) continue;
     // Reset to default "Select an option"
     var placeholderOption = dropdown.querySelector('option[value=""][disabled]');
     if(placeholderOption){
       placeholderOption.selected = true;
       dropdown.selectedIndex = 0;
     } else if(dropdown.options.length > 0){
       dropdown.selectedIndex = 0;
     }
     // Also reset any hidden dropdown inputs
     var hiddenDropdownInput = document.getElementById(dropdown.id + '_dropdown');
     if(hiddenDropdownInput){
       hiddenDropdownInput.value = '';
     }
     // Clear hidden checkboxes created by dropdownMirror
     var dropdownWrapper = document.getElementById('dropdowntext_' + dropdown.id);
     if(dropdownWrapper){
       dropdownWrapper.innerHTML = '';
     }
     // Trigger change event to update any dependent logic
     dropdown.dispatchEvent(new Event('change'));
   }
   thisQ.classList.add("hidden");
 }
  var parentSection = thisQ ? thisQ.closest('[id^="section"]') : null;
  if(parentSection){
    document.dispatchEvent(new CustomEvent("questionVisibilityChanged",{detail:{sectionId: parentSection.id}}));
  }
}
 (function(){
   var selectQuestion = "1";
   var el3= document.getElementById(questionNameIds[selectQuestion]) || document.getElementById("answer"+selectQuestion);
   if(el3){ el3.addEventListener("change", function(){ updateVisibility();});}
 })();
 (function(){
   var selectQuestion = "1";
   var el3= document.getElementById(questionNameIds[selectQuestion]) || document.getElementById("answer"+selectQuestion);
   if(el3){ el3.addEventListener("change", function(){ updateVisibility();});}
 })();
 updateVisibility();
})();


/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*
 * Handle "Mark only one" selection functionality
 *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function handleMarkOnlyOneSelection(selectedInput, questionId) {
    if (!selectedInput.checked) return;
    // Find all radio buttons in this question group
    const container = document.querySelector('.checkbox-group-' + questionId);
    if (!container) return;
    const allInputs = container.querySelectorAll('input[type="radio"]');
    allInputs.forEach(input => {
        if (input !== selectedInput) {
            input.checked = false;
            // Update styling for unchecked inputs
            updateCheckboxStyle(input);
            // Remove hidden checkbox for unchecked inputs
            removeHiddenCheckbox(input.id);
            // Ensure linked checkbox state refreshes after programmatic uncheck
            if (typeof window.updateAllLinkedCheckboxes === 'function') {
                setTimeout(() => window.updateAllLinkedCheckboxes(), 0);
            }
        }
    });
    // Update styling for the selected input
    updateCheckboxStyle(selectedInput);
    // Create hidden checkbox for the selected input
    createHiddenCheckboxForRadio(selectedInput.id, selectedInput.name, selectedInput.value);
}
/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*
 * Create hidden checkbox for radio button selection
 *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function createHiddenCheckboxForRadio(radioId, radioName, radioValue) {
    // Remove any existing hidden checkbox with the same ID
    removeHiddenCheckbox(radioId);
    // Find the hidden fields container
    let hiddenContainer = document.getElementById('hidden_pdf_fields');
    if (!hiddenContainer) {
        // Create the hidden fields container if it doesn't exist
        hiddenContainer = document.createElement('div');
        hiddenContainer.id = 'hidden_pdf_fields';
        hiddenContainer.style.display = 'none';
        // Find the form and append the hidden container
        const form = document.querySelector('form') || document.body;
        form.appendChild(hiddenContainer);
    }
    // Create the hidden checkbox
    const hiddenCheckbox = document.createElement('input');
    hiddenCheckbox.type = 'checkbox';
    hiddenCheckbox.id = radioId;
    hiddenCheckbox.name = radioId; // Use the same name as the radio button ID
    hiddenCheckbox.value = radioValue;
    hiddenCheckbox.checked = true;
    hiddenCheckbox.style.display = 'none';
    // Add to hidden container
    hiddenContainer.appendChild(hiddenCheckbox);
}
/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*
 * Remove hidden checkbox for radio button
 *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function removeHiddenCheckbox(radioId) {
    const selector = '#' + ((window.CSS && CSS.escape) ? CSS.escape(radioId) : radioId);
    const nodes = document.querySelectorAll(selector);

    nodes.forEach(node => {
        if (node.type === 'checkbox' && node.style && node.style.display === 'none') {
            node.remove();
        }
    });
    if (typeof window.updateAllLinkedCheckboxes === 'function') {

        window.updateAllLinkedCheckboxes();
    }
}

// Alert Logic Functions
// Track page load time to prevent alerts in first 3 seconds
const pageLoadTime = Date.now();
const ALERT_DELAY_MS = 3000; // 3 seconds
function showAlert(message) {
    // Check if 3 seconds have passed since page load
    const currentTime = Date.now();
    const timeSinceLoad = currentTime - pageLoadTime;
    if (timeSinceLoad < ALERT_DELAY_MS) {
        // If less than 3 seconds have passed, don't show the alert
        return;
    }
    const alertOverlay = document.getElementById('alertOverlay');
    const alertMessage = document.getElementById('alertMessage');
    if (alertOverlay && alertMessage) {
        // Check if this is a validation popup (HTML content) or regular alert (text)
        if (message.includes('<div')) {
            // This is HTML content (validation popup)
            alertMessage.innerHTML = message;
        } else {
            // This is a regular text alert
            alertMessage.textContent = message;
        }
        alertOverlay.style.display = 'flex';
    }
}
function closeAlert() {
    const alertOverlay = document.getElementById('alertOverlay');
    if (alertOverlay) {
        alertOverlay.style.display = 'none';
    }
}
// Show validation popup when user tries to proceed without answering all questions
function showValidationPopup() {
    const validationMessage = 
        '<div style="text-align: center;">' +
            '<div style="font-size: 2em; margin-bottom: 15px;">âš ï¸</div>' +
            '<div style="font-weight: 700; margin-bottom: 10px; color: #e74c3c;">Please Complete All Questions</div>' +
            '<div>You need to fill in all the questions on this page before you can proceed to the next section.</div>' +
        '</div>';
    showAlert(validationMessage);
}

// Helper function to deduplicate PDFs based on comprehensive unique key
function deduplicatePdfs(pdfArray) {
  const seen = new Set();
  const deduplicated = [];
  for (const pdf of pdfArray) {
    // Create a comprehensive unique key using formId + priceId + portfolioId
    const key = (pdf.formId || pdf.pdfName || pdf.title) + '_' + pdf.priceId + '_' + (pdf.portfolioId || 'default');
    if (!seen.has(key)) {
      seen.add(key);
      deduplicated.push(pdf);
    } else {
    }
  }
  return deduplicated;
}
// Always-available Cart Modal (global)
window.showCartModal = function () {
  // Calculate all PDFs that will be added to cart
  const allPdfsToAdd = [];
  // Add main form
  const mainFormPriceId = window.stripePriceId || stripePriceId || '123';
  allPdfsToAdd.push({
    formId: (window.pdfOutputFileName || 'sc500.pdf').replace(/.pdf$/i, '').toLowerCase(),
    title: window.pdfFileName || 'Form',
    priceId: mainFormPriceId,
    pdfName: window.pdfFileName || ''
  });
  // Add conditional PDFs based on current form state
  if (Array.isArray(window.pdfLogicPDFs) && window.pdfLogicPDFs.length > 0) {
    for (const pdfLogic of window.pdfLogicPDFs) {
      if (!pdfLogic || !pdfLogic.pdfName || !pdfLogic.stripePriceId) continue;
      let matched = false;
      // Check if this is a bigParagraph with character limit
      if (pdfLogic.isBigParagraph) {
        // For Big Paragraph questions, check character limit
        const el = document.getElementById((window.questionNameIds || {})[pdfLogic.questionId]) ||
                   document.getElementById('answer' + pdfLogic.questionId);
        if (el) {
          const questionValue = el.value || '';
          // Check each character limit condition
          for (const condition of pdfLogic.conditions) {
            if (condition.characterLimit) {
              if (questionValue.length > condition.characterLimit) {
                matched = true;
                break; // Exit the loop once we find a match
              }
            }
          }
          if (!matched) {
          }
        } else {
        }
      } else if (pdfLogic.triggerOption) {
        // For numbered dropdown with trigger option, check if the selected value matches the trigger
        const el = document.getElementById((window.questionNameIds || {})[pdfLogic.questionId]) ||
                   document.getElementById('answer' + pdfLogic.questionId);
        if (el) {
          const val = el.value || '';
          if (val === pdfLogic.triggerOption) {
            matched = true;
          } else {
          }
        } else {
        }
      } else if (pdfLogic.numberTrigger && pdfLogic.numberValue) {
        // For number questions with trigger conditions, check if the number meets the condition
        const el = document.getElementById((window.questionNameIds || {})[pdfLogic.questionId]) ||
                   document.getElementById('answer' + pdfLogic.questionId);
        if (el) {
          const val = parseFloat(el.value) || 0;
          const triggerValue = parseFloat(pdfLogic.numberValue) || 0;
          let conditionMet = false;
          if (pdfLogic.numberTrigger === '=') {
            conditionMet = val === triggerValue;
          } else if (pdfLogic.numberTrigger === '>') {
            conditionMet = val > triggerValue;
          } else if (pdfLogic.numberTrigger === '<') {
            conditionMet = val < triggerValue;
          }
          if (conditionMet) {
            matched = true;
          } else {
          }
        } else {
        }
      } else if (pdfLogic.isTriggerSequencePdf) {
        // For trigger sequence PDFs, check if the trigger sequence condition is met for the specific entry

        // First, check that the numbered dropdown has a value (entries exist)
        const numberedDropdownEl = document.getElementById((window.questionNameIds || {})[pdfLogic.questionId]) ||
                                    document.getElementById('answer' + pdfLogic.questionId);

        if (!numberedDropdownEl || !numberedDropdownEl.value) {

        } else {
          const entryCount = parseInt(numberedDropdownEl.value) || 0;
          const targetEntryNumber = parseInt(pdfLogic.pdfEntryNumber) || 1;

          // Check if target entry exists
          if (targetEntryNumber > entryCount) {

          } else {
            // Find the trigger sequence dropdown for this entry
            // The dropdown ID format: sanitizedFieldName_entryNumber
            // Must match the exact pattern used when creating the dropdown (uses character classes to avoid backslash escaping issues)
            const sanitizedFieldName = String(pdfLogic.triggerSequenceFieldName || 'dropdown')
              .toLowerCase()
              .replace(/[?]/g, '')  // Remove question marks
              .replace(/[^a-z0-9_]+/g, '_')  // Replace non-word characters with underscore (character class avoids escaping issues)
              .replace(/^_+|_+$/g, '');  // Remove leading/trailing underscores (CRITICAL: must match ID generation)
            const triggerDropdownId = sanitizedFieldName + '_' + targetEntryNumber;

            const triggerDropdownEl = document.getElementById(triggerDropdownId);

            if (triggerDropdownEl) {
              const selectedValue = triggerDropdownEl.value || '';

              if (selectedValue === pdfLogic.triggerSequenceCondition) {

                matched = true;
              } else {

              }
            } else {

              document.querySelectorAll('select').forEach(function(sel) {

              });
            }
          }
        }
      } else {
        // For regular conditions, check previous question logic
        const conds = Array.isArray(pdfLogic.conditions) ? pdfLogic.conditions : [];
        for (const c of conds) {
          const prevId = c?.prevQuestion;
          const expect = (c?.prevAnswer ?? '').toString().toLowerCase();
          if (!prevId) continue;
          const el = document.getElementById((window.questionNameIds || {})[prevId]) ||
                     document.getElementById('answer' + prevId);
          if (!el) {
            continue;
          }
          let val = '';
          if (el.type === 'checkbox') { val = el.checked ? (el.value || 'true') : ''; }
          else                        { val = el.value || ''; }
          // Handle wildcard condition (*) - means any value is fine
          if (expect === '*' && val !== '') {
            matched = true;
          } else if (val.toString().toLowerCase() === expect) {
            matched = true; // any condition match includes the PDF
            }
          }
        }
      if (matched) {
        // Format the display name properly (e.g., "sc103" -> "SC-103")
        let displayTitle;
        if (pdfLogic.pdfDisplayName && pdfLogic.pdfDisplayName.trim() !== '') {
          const baseName = pdfLogic.pdfDisplayName.trim();
          displayTitle = baseName.toUpperCase().replace(/([A-Z])(d+)/g, '$1-$2');
        } else {
          displayTitle = pdfLogic.pdfName.replace(/.pdf$/i, '');
        }
        allPdfsToAdd.push({
          formId: pdfLogic.pdfName.replace(/.pdf$/i, '').toLowerCase(),
          title: displayTitle,
          priceId: pdfLogic.stripePriceId,
          pdfName: pdfLogic.pdfName
        });
      } else {
      }
    }
  }
  // Add checkbox PDF entries
  if (window.checkboxPdfEntries && window.checkboxPdfEntries.length > 0) {
    for (const pdfEntry of window.checkboxPdfEntries) {
      if (pdfEntry.pdfFile && pdfEntry.priceId) {
        // Use the pdfName as the display title (preserve original casing from JSON)
        // pdfName is the display name like "Test Name", pdfFile is the filename like "sc500.pdf"
        const displayTitle = pdfEntry.pdfName || pdfEntry.pdfFile.replace(/.pdf$/i, '');
        allPdfsToAdd.push({
          formId: pdfEntry.pdfFile.replace(/.pdf$/i, '').toLowerCase(),
          title: displayTitle,
          priceId: pdfEntry.priceId,
          pdfName: pdfEntry.pdfFile
        });
      }
    }
  } else {
  }
  // Add file upload items to cart preview
  if (window.fileUploadQuestions && window.fileUploadQuestions.length > 0 && window.uploadedFiles) {
    for (const fileUpload of window.fileUploadQuestions) {
      const uploadedFile = window.uploadedFiles[fileUpload.questionId];
      if (uploadedFile && fileUpload.fileTitle) {
        // Convert file title to PDF name (add .pdf extension if not present)
        const pdfName = fileUpload.fileTitle.endsWith('.pdf') ? fileUpload.fileTitle : (fileUpload.fileTitle + '.pdf');
        allPdfsToAdd.push({
          formId: fileUpload.fileTitle.replace(/.pdf$/i, '').toLowerCase(),
          title: fileUpload.fileTitle,
          priceId: fileUpload.priceId,
          pdfName: pdfName
        });
      }
    }
  }
  // Deduplicate PDFs to prevent multiple requests for the same PDF
  const originalCount = allPdfsToAdd.length;
  const deduplicatedPdfs = deduplicatePdfs(allPdfsToAdd);
  // Fetch prices for all PDFs
  async function fetchAllPrices() {
    const prices = [];
    for (const pdf of deduplicatedPdfs) {
      try {
        const r = await fetch('/stripe-price/' + pdf.priceId);
        if (r.ok) {
          const data = await r.json();
          const price = data && data.unit_amount != null ? (data.unit_amount / 100).toFixed(2) : '0.00';
          prices.push(parseFloat(price));
        } else {
          prices.push(0);
        }
      } catch (e) {
        prices.push(0);
      }
    }
    return prices;
  }
  fetchAllPrices().then((prices) => {
    const totalPrice = prices.reduce((sum, price) => sum + price, 0);
    const priceDisplay = totalPrice > 0 ? '$' + totalPrice.toFixed(2) : '...';
    const modal = document.createElement('div');
    modal.id = 'cart-modal';
    modal.style.cssText = 'position:fixed;inset:0;background:rgba(44,62,80,.45);display:flex;align-items:center;justify-content:center;z-index:99999;';
    modal.innerHTML = `
      <div style="background:#fff;border-radius:12px;box-shadow:0 8px 32px rgba(44,62,80,.18);padding:32px 28px 24px;max-width:470px;width:90%;text-align:center;position:relative;">
        <h2>Checkout</h2>
        <p>Your form has been completed! Add it to your cart to download.</p>
        <p style="font-size:0.9em;color:#666;margin:10px 0;">${deduplicatedPdfs.length} PDF(s) will be added to cart</p>
        <button id="addToCartBtn" style="background:linear-gradient(90deg,#4f8cff 0%,#38d39f 100%);color:#fff;border:none;border-radius:6px;padding:10px 28px;font-size:1.1em;font-weight:600;cursor:pointer;">
          Add to Cart - ${priceDisplay}
        </button>
        <br><br>
        <button id="viewCartBtn" style="background:#e0e7ef;color:#2c3e50;border:none;border-radius:6px;padding:8px 22px;font-size:1em;font-weight:600;cursor:pointer;">
          View Cart
        </button>
        <br><br>
        <button id="cancelCartBtn" style="background:#e74c3c;color:#fff;border:none;border-radius:6px;padding:8px 22px;font-size:1em;font-weight:600;cursor:pointer;">
          Cancel
        </button>
      </div>
    `;
    document.body.appendChild(modal);
    document.getElementById('cancelCartBtn').onclick = () => modal.remove();
    document.getElementById('viewCartBtn').onclick   = () => { modal.remove(); window.location.href = '/Pages/cart.html'; };
    document.getElementById('addToCartBtn').onclick   = () => {
      window.addFormToCart(mainFormPriceId);
      modal.remove();
    };
  });
};
// --- Cart helpers (new) ---
function clearCartState() {
  try { localStorage.removeItem('formwiz_cart'); } catch {}
  // expire cookie immediately
  document.cookie = 'formwiz_cart=;path=/;max-age=0';
}
function writeCartCookie(cart) {
  try { document.cookie = 'formwiz_cart=' + encodeURIComponent(JSON.stringify(cart)) + ';path=/;max-age=2592000'; } catch {}
}
function getUrlParam(name) {
  const u = new URLSearchParams(window.location.search);
  return u.get(name) || '';
}
// Add to cart helper (global, no Firebase required)
window.addFormToCart = function (priceId) {
  // 1) Fresh start each submission (prevents dupes/stale items across re-submits)
  clearCartState();
  // 2) Collect form data
  // First, ensure all dynamic fields are up-to-date
  if (typeof updateUserFullName === 'function') {
    updateUserFullName();
    // Check if user_fullname was updated
    const fullNameField = document.getElementById('user_fullname');
    if (fullNameField) {
    } else {
    }
  } else {
  }
  if (typeof updateUserAddressFields === 'function') {
    updateUserAddressFields();
  } else {
  }
  const form = document.getElementById('customForm');
  const formData = {};
  if (form) {
    // Include both elements inside the form AND elements with form="customForm" attribute
    const formElements = Array.from(form.elements);
    const externalFormElements = Array.from(document.querySelectorAll('input[form="customForm"], textarea[form="customForm"], select[form="customForm"]'));
    const allFormElements = [...formElements, ...externalFormElements];
    // Log all elements we're about to process
    allFormElements.forEach((el, index) => {
    });
    for (const el of allFormElements) {
      if (!el.name || el.disabled) {
        continue;
      }
      if (!['INPUT','TEXTAREA','SELECT'].includes(el.tagName)) {
        continue;
      }
      if (['button','submit','reset'].includes(el.type)) {
        continue;
      }
      // For hidden fields, include them if they have values
      if (el.type === 'hidden') {
        if (el.value && el.value.trim() !== '') {
          formData[el.name] = el.value;
        } else {
        }
        continue;
      }
      // For checkboxes and radios, only include if checked
      if (el.type === 'checkbox' || el.type === 'radio') {
        if (el.checked) {
          formData[el.name] = 'on'; // Send 'on' for checked checkboxes (standard HTML form behavior)
        } else {
        }
        // Skip unchecked checkboxes entirely - don't send them to server
      } else {
        let value = el.value;
        // Format date inputs to mm/dd/yyyy (same as manual download)
        if (el.type === 'date' && value) {
          const originalValue = value;
          value = formatDateForServer(value);
        }
        formData[el.name] = value;
      }
    }
  }
  Object.keys(formData).forEach(key => {
  });
  // 3) Uniform metadata for every cart line
  const originalFormId = (window.pdfOutputFileName || 'sc500.pdf').replace(/.pdf$/i, '').toLowerCase();
  const formTitle      = window.pdfFileName || (typeof pdfFileName !== 'undefined' ? pdfFileName : 'Form');
  const countyName     = getUrlParam('county');
  const defendantName  = getUrlParam('defendantName');
  const portfolioId    = getUrlParam('portfolioId');
  const nowTs          = Date.now();
  // 4) Compute all PDF-logic matches (OR logic across conditions)
  const pdfLogicItems = [];
  let deduplicatedPdfLogicItems = []; // Declare outside try-catch to ensure it's always defined
  try {
    if (Array.isArray(window.pdfLogicPDFs) && window.pdfLogicPDFs.length > 0) {
      for (const pdfLogic of window.pdfLogicPDFs) {
        if (!pdfLogic || !pdfLogic.pdfName || !pdfLogic.stripePriceId) {
          continue;
        }
        let matched = false;
        // Check if this is a bigParagraph with character limit
        if (pdfLogic.isBigParagraph) {
          // For Big Paragraph questions, check character limit
          const el = document.getElementById((window.questionNameIds || {})[pdfLogic.questionId]) ||
                     document.getElementById('answer' + pdfLogic.questionId);
          if (el) {
            const questionValue = el.value || '';
            // Check each character limit condition
            for (const condition of pdfLogic.conditions) {
              if (condition.characterLimit) {
                if (questionValue.length > condition.characterLimit) {
                  matched = true;
                  break; // Exit the loop once we find a match
                }
              }
            }
            if (!matched) {
            }
          } else {
          }
        } else if (pdfLogic.triggerOption) {
          // For numbered dropdown with trigger option, check if the selected value matches the trigger
          const el = document.getElementById((window.questionNameIds || {})[pdfLogic.questionId]) ||
                     document.getElementById('answer' + pdfLogic.questionId);
          if (el) {
            const val = el.value || '';
            if (val === pdfLogic.triggerOption) {
              matched = true;
            } else {
            }
          } else {
          }
        } else if (pdfLogic.numberTrigger && pdfLogic.numberValue) {
          // For number questions with trigger conditions, check if the number meets the condition
          const el = document.getElementById((window.questionNameIds || {})[pdfLogic.questionId]) ||
                     document.getElementById('answer' + pdfLogic.questionId);
          if (el) {
            const val = parseFloat(el.value) || 0;
            const triggerValue = parseFloat(pdfLogic.numberValue) || 0;
            let conditionMet = false;
            if (pdfLogic.numberTrigger === '=') {
              conditionMet = val === triggerValue;
            } else if (pdfLogic.numberTrigger === '>') {
              conditionMet = val > triggerValue;
            } else if (pdfLogic.numberTrigger === '<') {
              conditionMet = val < triggerValue;
            }
            if (conditionMet) {
              matched = true;
            } else {
            }
          } else {
          }
        } else if (pdfLogic.isTriggerSequencePdf) {
          // For trigger sequence PDFs, check if the trigger sequence condition is met for the specific entry

          // First, check that the numbered dropdown has a value (entries exist)
          const numberedDropdownEl = document.getElementById((window.questionNameIds || {})[pdfLogic.questionId]) ||
                                      document.getElementById('answer' + pdfLogic.questionId);

          if (!numberedDropdownEl || !numberedDropdownEl.value) {

          } else {
            const entryCount = parseInt(numberedDropdownEl.value) || 0;
            const targetEntryNumber = parseInt(pdfLogic.pdfEntryNumber) || 1;

            // Check if target entry exists
            if (targetEntryNumber > entryCount) {

            } else {
              // Find the trigger sequence dropdown for this entry
              // The dropdown ID format: sanitizedFieldName_entryNumber (uses character classes to avoid backslash escaping issues)
              const sanitizedFieldName = String(pdfLogic.triggerSequenceFieldName || 'dropdown')
                .toLowerCase()
                .replace(/[?]/g, '')  // Remove question marks
                .replace(/[^a-z0-9_]+/g, '_')  // Replace non-word characters with underscore
                .replace(/^_+|_+$/g, '');  // Remove leading/trailing underscores
              const triggerDropdownId = sanitizedFieldName + '_' + targetEntryNumber;

              const triggerDropdownEl = document.getElementById(triggerDropdownId);

              if (triggerDropdownEl) {
                const selectedValue = triggerDropdownEl.value || '';

                if (selectedValue === pdfLogic.triggerSequenceCondition) {

                  matched = true;
                } else {

                }
              } else {

                document.querySelectorAll('select').forEach(function(sel) { });
              }
            }
          }
        } else {
          // For regular conditions, check previous question logic
        const conds = Array.isArray(pdfLogic.conditions) ? pdfLogic.conditions : [];
        for (const c of conds) {
          const prevId = c?.prevQuestion;
          const expect = (c?.prevAnswer ?? '').toString().toLowerCase();
          if (!prevId) continue;
          const el = document.getElementById((window.questionNameIds || {})[prevId]) ||
                     document.getElementById('answer' + prevId);
          if (!el) {
            continue;
          }
          let val = '';
          if (el.type === 'checkbox') { val = el.checked ? (el.value || 'true') : ''; }
          else                        { val = el.value || ''; }
          // Handle wildcard condition (*) - means any value is fine
          if (expect === '*' && val !== '') {
            matched = true;
          } else if (val.toString().toLowerCase() === expect) {
            matched = true; // any condition match includes the PDF
            }
          }
        }
        if (matched) {
          // Create a proper display name for the PDF logic item
          let displayTitle;
          // If there's a custom PDF display name from the PDF logic, use it
          if (pdfLogic.pdfDisplayName && pdfLogic.pdfDisplayName.trim() !== '') {
            // Format the display name properly (e.g., "sc103" -> "SC-103")
            const baseName = pdfLogic.pdfDisplayName.trim();
            // Convert to uppercase and add dashes for better formatting
            displayTitle = baseName.toUpperCase().replace(/([A-Z])(d+)/g, '$1-$2');
          } else {
            // Create a title based on the main form name + PDF name
            const mainFormName = window.pdfFileName || 'Form';
            const pdfBaseName = pdfLogic.pdfName.replace(/.pdf$/i, '').toUpperCase();
            displayTitle = mainFormName + ' ' + pdfBaseName;
          }
          const item = {
            formId: pdfLogic.pdfName.replace(/.pdf$/i, '').toLowerCase(),
            title: displayTitle,
            priceId: pdfLogic.stripePriceId,
            pdfName: pdfLogic.pdfName,
            originalFormId: originalFormId,
            portfolioId: portfolioId,
            formData: formData,
            countyName: countyName,
            defendantName: defendantName,
            timestamp: nowTs
          };
          pdfLogicItems.push(item);
        } else {
        }
      }
    } else {
    }
    // Deduplicate PDF logic items to prevent multiple requests for the same PDF
    const originalPdfLogicCount = pdfLogicItems.length;
    deduplicatedPdfLogicItems = deduplicatePdfs(pdfLogicItems);
  } catch (e) {
    // Ensure deduplicatedPdfLogicItems is always an array even if there's an error
    deduplicatedPdfLogicItems = [];
  }
  // 5) Preferred path: site cart manager
  if (typeof window.addToCart === 'function') {
    // Create a batch of all items to add
    const allItems = [];
    // Add main item
    const mainItem = {
      formId: originalFormId,
      title: formTitle,
      priceId: priceId,
      formData: { ...formData, originalFormId, portfolioId, pdfName: (window.pdfFileName || '') },
      countyName: countyName,
      defendantName: defendantName
    };
    allItems.push(mainItem);
    // Add all matched PDF logic items
    for (const item of deduplicatedPdfLogicItems) {
      const pdfItem = {
        formId: item.formId.toLowerCase(),
        title: item.title,
        priceId: item.priceId,
        formData: { ...item.formData, originalFormId: item.originalFormId, portfolioId: item.portfolioId, pdfName: item.pdfName },
        countyName: item.countyName,
        defendantName: item.defendantName
      };
      allItems.push(pdfItem);
    }
    // Add checkbox PDF entries
    if (window.checkboxPdfEntries && window.checkboxPdfEntries.length > 0) {
      for (const pdfEntry of window.checkboxPdfEntries) {
        // Use the pdfName as the display title (preserve original casing from JSON)
        // pdfName is the display name like "Test Name", pdfFile is the filename like "sc500.pdf"
        const displayTitle = pdfEntry.pdfName || pdfEntry.pdfFile.replace(/.pdf$/i, '');
        const pdfItem = {
          formId: pdfEntry.pdfFile.replace(/.pdf$/i, '').toLowerCase(),
          title: displayTitle,
          priceId: pdfEntry.priceId,
          formData: { ...formData, originalFormId: originalFormId, portfolioId: portfolioId, pdfName: pdfEntry.pdfFile },
          countyName: countyName,
          defendantName: defendantName
        };
        allItems.push(pdfItem);
      }
    } else {
    }
    // Add file upload items
    if (window.fileUploadQuestions && window.fileUploadQuestions.length > 0 && window.uploadedFiles) {
      for (const fileUpload of window.fileUploadQuestions) {
        const uploadedFile = window.uploadedFiles[fileUpload.questionId];
        if (uploadedFile && fileUpload.fileTitle) {
          // Convert file title to PDF name (add .pdf extension if not present)
          const pdfName = fileUpload.fileTitle.endsWith('.pdf') ? fileUpload.fileTitle : (fileUpload.fileTitle + '.pdf');
          const pdfItem = {
            formId: fileUpload.fileTitle.replace(/.pdf$/i, '').toLowerCase(),
            title: fileUpload.fileTitle,
            priceId: fileUpload.priceId,
            formData: { ...formData, originalFormId: originalFormId, portfolioId: portfolioId, pdfName: pdfName, uploadedFile: uploadedFile },
            countyName: countyName,
            defendantName: defendantName,
            pdfName: pdfName,
            isFileUpload: true,
            uploadedFile: uploadedFile
          };
          allItems.push(pdfItem);
        }
      }
    }
    // Add all items to cart with a small delay between each to prevent race conditions
    let addedCount = 0;
    allItems.forEach((item, index) => {
      setTimeout(() => {
        // Ensure formData includes portfolio ID for proper grouping
        const enhancedFormData = {
          ...item.formData,
          originalFormId: item.originalFormId,
          portfolioId: item.portfolioId,
          pdfName: item.pdfName
        };
        window.addToCart(
          item.formId, item.title, item.priceId, enhancedFormData,
          item.countyName, item.defendantName, item.pdfName
        );
        addedCount++;
        // Check if all items have been added
        if (addedCount === allItems.length) {
          const itemList = allItems.map(item => {
            let itemInfo = '- ' + item.title + ' (' + item.formId + ') - PriceId: ' + item.priceId + ' - PortfolioId: ' + (item.portfolioId || 'N/A');
            if (item.defendantName && item.defendantName.trim() !== '') {
              itemInfo += ' - Defendant: ' + item.defendantName;
            }
            return itemInfo;
          }).join('\n');
          // Navigate to cart page
          window.location.href = '/Pages/cart.html';
        }
      }, index * 200); // 200ms delay between each item
    });
    // Don't redirect automatically - let the alert handle it
    return;
  }
  // 6) Fallback: localStorage + cookie (fresh array due to clearCartState)
  let cart = [];
  const mainCartItem = {
    formId: originalFormId, title: formTitle, priceId,
    pdfName: (window.pdfFileName || ''),
    originalFormId, portfolioId, formData, countyName, defendantName, timestamp: nowTs
  };
  cart.push(mainCartItem);
  for (const item of deduplicatedPdfLogicItems) {
    cart.push(item);
  }
  // Add checkbox PDF entries to cart
  if (window.checkboxPdfEntries && window.checkboxPdfEntries.length > 0) {
    for (const pdfEntry of window.checkboxPdfEntries) {
      // Use the pdfName as the display title (preserve original casing from JSON)
      // pdfName is the display name like "Test Name", pdfFile is the filename like "sc500.pdf"
      const displayTitle = pdfEntry.pdfName || pdfEntry.pdfFile.replace(/.pdf$/i, '');
      const cartItem = {
        formId: pdfEntry.pdfFile.replace(/.pdf$/i, '').toLowerCase(),
        title: displayTitle,
        priceId: pdfEntry.priceId,
        pdfName: pdfEntry.pdfFile,
        originalFormId: originalFormId,
        portfolioId: portfolioId,
        formData: formData,
        countyName: countyName,
        defendantName: defendantName,
        timestamp: nowTs
      };
      cart.push(cartItem);
    }
  }
  // Add file upload items to cart
  if (window.fileUploadQuestions && window.fileUploadQuestions.length > 0 && window.uploadedFiles) {
    for (const fileUpload of window.fileUploadQuestions) {
      const uploadedFile = window.uploadedFiles[fileUpload.questionId];
      if (uploadedFile && fileUpload.fileTitle) {
        // Convert file title to PDF name (add .pdf extension if not present)
        const pdfName = fileUpload.fileTitle.endsWith('.pdf') ? fileUpload.fileTitle : (fileUpload.fileTitle + '.pdf');
        const cartItem = {
          formId: fileUpload.fileTitle.replace(/.pdf$/i, '').toLowerCase(),
          title: fileUpload.fileTitle,
          priceId: fileUpload.priceId,
          pdfName: pdfName,
          originalFormId: originalFormId,
          portfolioId: portfolioId,
          formData: formData,
          countyName: countyName,
          defendantName: defendantName,
          timestamp: nowTs,
          isFileUpload: true,
          uploadedFile: uploadedFile
        };
        cart.push(cartItem);
      }
    }
  }

  // Add LaTeX preview PDFs to cart (if "Attach to packet" is selected)
  if (window.latexPreviewQuestions && window.latexPreviewQuestions.length > 0 && window.latexPdfs) {
    for (const latexPreviewQ of window.latexPreviewQuestions) {
      const latexPdf = window.latexPdfs[latexPreviewQ.questionId];
      if (latexPdf && latexPreviewQ.title && latexPreviewQ.priceId) {
        // Use title as the PDF name
        const pdfName = latexPreviewQ.title.endsWith('.pdf') ? latexPreviewQ.title : (latexPreviewQ.title + '.pdf');
        const cartItem = {
          formId: latexPreviewQ.title.replace(/.pdf$/i, '').toLowerCase(),
          title: latexPreviewQ.title,
          priceId: latexPreviewQ.priceId,
          pdfName: pdfName,
          originalFormId: originalFormId,
          portfolioId: portfolioId,
          formData: formData,
          countyName: countyName,
          defendantName: defendantName,
          timestamp: nowTs,
          isLatexPreview: true,
          latexPdf: latexPdf
        };
        cart.push(cartItem);
      }
    }
  }
  // Final deduplication of the entire cart to prevent any duplicates
  const originalCartCount = cart.length;
  cart = deduplicatePdfs(cart);
  try { localStorage.setItem('formwiz_cart', JSON.stringify(cart)); } catch {}
  writeCartCookie(cart);
  const itemList = cart.map(item => {
    let itemInfo = '- ' + item.title + ' (' + item.formId + ') - PriceId: ' + item.priceId + ' - PortfolioId: ' + (item.portfolioId || 'N/A');
    if (item.defendantName && item.defendantName.trim() !== '') {
      itemInfo += ' - Defendant: ' + item.defendantName;
    }
    return itemInfo;
  }).join('\n');
  // Navigate to cart page
  window.location.href = '/Pages/cart.html';
};
// Fallback cart count function (global, no Firebase required)
window.getCartCount = function() {
  try {
    const cartData = localStorage.getItem('formwiz_cart');
    if (cartData) {
      const cart = JSON.parse(cartData);
      return Array.isArray(cart) ? cart.length : 0;
    }
  } catch (e) {
  }
  return 0;
};

// Checklist Variables (always defined)
let userChecklist = [];
let staticChecklistItems = [];

  function sanitizeQuestionText (str){
    return String(str)
       .toLowerCase()
        .replace(/W+/g, "_")
        .replace(/^_+|_+$/g, "");
}
// Phone number formatter function
function formatPhoneNumber(value) {
  if (!value) return value;
  const phoneNumber = value.replace(/\D/g, '');
  const phoneNumberLength = phoneNumber.length;
  if (phoneNumberLength < 4) {
    return phoneNumberLength > 0 ? '(' + phoneNumber : '';
  } else if (phoneNumberLength < 7) {
    return '(' + phoneNumber.substring(0, 3) + ') ' + phoneNumber.substring(3);
  } else {
    return '(' + phoneNumber.substring(0, 3) + ') ' + 
           phoneNumber.substring(3, 6) + '-' + 
           phoneNumber.substring(6, 10);
  }
}
// Initialize all phone inputs on the page
document.addEventListener('DOMContentLoaded', function() {
  const phoneInputs = document.querySelectorAll('.phone-input');
  phoneInputs.forEach(phoneInput => {
    // Format existing value if any
    if (phoneInput.value) {
      phoneInput.value = formatPhoneNumber(phoneInput.value);
    }
    // Set up event listener for input
    phoneInput.addEventListener('input', function(e) {
      const input = e.target;
      const value = input.value.replace(/\D/g, '').substring(0, 10); // Strip non-digits and limit to 10 digits
      input.value = formatPhoneNumber(value);
    });
  });
});
function toggleAmountField(amountFieldId, show) {
    const amountField = document.getElementById(amountFieldId);
    if (amountField) {
        amountField.style.display = show ? 'block' : 'none';
        if (!show) amountField.value = '';
    }
}
/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*
 * Extract question ID from onchange attribute
 *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function extractQuestionIdFromOnchange(fn) {
    if (!fn) return null;
    const s = fn.toString();
    const m = s.match(/showTextboxLabels\s*\(\s*(\d+)\s*,/);
    return m ? m[1] : null;
}
/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*
 * Handle "Mark only one" selection functionality
 *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function handleMarkOnlyOneSelection(selectedInput, questionId) {
    if (!selectedInput.checked) return;
    // Find all radio buttons in this question group
    const container = document.querySelector('.checkbox-group-' + questionId);
    if (!container) return;
    const allInputs = container.querySelectorAll('input[type="radio"]');
    allInputs.forEach(input => {
        if (input !== selectedInput) {
            input.checked = false;
            // Update styling for unchecked inputs
            updateCheckboxStyle(input);
            // Remove hidden checkbox for unchecked inputs
            removeHiddenCheckbox(input.id);
        }
    });
    // Update styling for the selected input
    updateCheckboxStyle(selectedInput);
    // Create hidden checkbox for the selected input
    createHiddenCheckboxForRadio(selectedInput.id, selectedInput.name, selectedInput.value);
}
/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*
 * Create hidden checkbox for radio button selection
 *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function createHiddenCheckboxForRadio(radioId, radioName, radioValue) {
    // Remove any existing hidden checkbox with the same ID
    removeHiddenCheckbox(radioId);
    // Find the hidden fields container
    let hiddenContainer = document.getElementById('hidden_pdf_fields');
    if (!hiddenContainer) {
        // Create the hidden fields container if it doesn't exist
        hiddenContainer = document.createElement('div');
        hiddenContainer.id = 'hidden_pdf_fields';
        hiddenContainer.style.display = 'none';
        // Find the form and append the hidden container
        const form = document.querySelector('form') || document.body;
        form.appendChild(hiddenContainer);
    }
    // Create the hidden checkbox
    const hiddenCheckbox = document.createElement('input');
    hiddenCheckbox.type = 'checkbox';
    hiddenCheckbox.id = radioId;
    hiddenCheckbox.name = radioId; // Use the same name as the radio button ID
    hiddenCheckbox.value = radioValue;
    hiddenCheckbox.checked = true;
    hiddenCheckbox.style.display = 'none';
    // Add to hidden container
    hiddenContainer.appendChild(hiddenCheckbox);
}
/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*
 * Remove hidden checkbox for radio button
 *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function removeHiddenCheckbox(radioId) {
    const selector = '#' + ((window.CSS && CSS.escape) ? CSS.escape(radioId) : radioId);
    const nodes = document.querySelectorAll(selector);

    nodes.forEach(node => {
        if (node.type === 'checkbox' && node.style && node.style.display === 'none') {
            node.remove();
        }
    });
    if (typeof window.updateAllLinkedCheckboxes === 'function') {

        window.updateAllLinkedCheckboxes();
    }
}
/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*
 * Handle "None of the above" checkbox functionality
 *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function toggleNoneOption(checkbox, questionId) {
    if (!checkbox.checked) return;
    // Find the "None of the above" checkbox using more robust selectors
    const cbPrefix = getCbPrefix(questionId);
    const noneCheckbox = document.querySelector('input[id="' + cbPrefix + 'none"]') || 
                         document.querySelector('input[id^="' + cbPrefix + '"][id$="_none"]');
    if (noneCheckbox && noneCheckbox.checked) {
        // Uncheck the "None of the above" option when any other option is checked
        noneCheckbox.checked = false;
    }
}
function handleNoneOfTheAboveToggle(noneCheckbox, questionId) {
    if (!noneCheckbox.checked) return;
    // When "None of the above" is checked, uncheck all other options
    const container = document.querySelector('.checkbox-group-' + questionId);
    if (!container) return;
    const allCheckboxes = container.querySelectorAll('input[type="checkbox"]');
    allCheckboxes.forEach(checkbox => {
        // Skip the "None" checkbox itself
        const isNoneCheckbox = checkbox.id.endsWith('_none') || checkbox.id.endsWith('none');
        if (checkbox !== noneCheckbox && !isNoneCheckbox) {
            checkbox.checked = false;
            // If this checkbox has an amount field, hide it
            const amountId = checkbox.id + '_amount';
            toggleAmountField(amountId, false);
        }
    });
    // Update styling for all checkboxes
    allCheckboxes.forEach(checkbox => {
        updateCheckboxStyle(checkbox);
    });
}
/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*
 * Update checkbox styling for beautiful blue border
 *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function updateCheckboxStyle(checkbox) {
    const container = document.getElementById('checkbox-container-' + checkbox.id);
    if (container) {
        if (checkbox.checked) {
            container.classList.add('checked');
        } else {
            container.classList.remove('checked');
        }
    }
}
/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*
 * Form validation functions
 *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function validateAndProceed(sectionNumber) {

    const isValid = validateCurrentSection(sectionNumber);

    if (isValid) {

        handleNext(sectionNumber);
        return true;
    } else {

        // Show validation popup when validation fails
        showValidationPopup();
        return false;
    }
}
// Show validation popup when user tries to proceed without answering all questions
function showValidationPopup() {
    const validationMessage = 
        '<div style="text-align: center;">' +
            '<div style="font-size: 2em; margin-bottom: 15px;">âš ï¸</div>' +
            '<div style="font-weight: 700; margin-bottom: 10px; color: #e74c3c;">Please Complete All Questions</div>' +
            '<div>You need to fill in all the questions on this page before you can proceed to the next section.</div>' +
        '</div>';
    showAlert(validationMessage);
}
// Global function to trigger visibility updates for dependent questions
function triggerVisibilityUpdates() {
    // Find all question containers and trigger their visibility logic
    const questionContainers = document.querySelectorAll('[id^="question-container-"]');
    questionContainers.forEach(container => {
        const questionId = container.id.replace('question-container-', '');
        // Try to find and call the updateVisibility function for this question
        // The conditional logic creates functions in the global scope, so we need to call them
        try {
            // Look for the updateVisibility function that was created for this question
            // The function is created in a closure, so we need to trigger it via the event listeners
        const questionElement = document.getElementById(questionNameIds[questionId]) || 
                              document.getElementById('answer' + questionId);
        if (questionElement) {
            // Trigger change event to update visibility
            const event = new Event('change', { bubbles: true });
            questionElement.dispatchEvent(event);
            } else {
            }
        } catch (error) {
        }
    });
}
// Fallback function to manually check and update visibility without relying on generated scripts
function triggerVisibilityUpdatesFallback() {
    // Find all question containers
    const questionContainers = document.querySelectorAll('[id^="question-container-"]');
    questionContainers.forEach(container => {
        const questionId = container.id.replace('question-container-', '');
        // Check if this question has conditional logic by looking for data attributes or other indicators
        // For now, we'll manually check common conditional logic patterns
        // Check if this question should be visible based on other question values
        // This is a simplified version of the conditional logic
        let shouldBeVisible = true;
        // Look for any dropdown or input that might control this question's visibility
        const allInputs = document.querySelectorAll('input, select, textarea');
        allInputs.forEach(input => {
            if (input.id && input.id !== container.id) {
                // Check if this input's value should affect the visibility of the current question
                // This is a simplified check - in a real implementation, you'd need to parse the actual conditional logic
                if (input.value && input.value.trim() !== '') {
                    // For now, we'll just log this - the actual conditional logic would be more complex
                }
            }
        });
        // For debugging, let's just make sure all questions are visible initially
        // In a real implementation, you'd implement the actual conditional logic here
        if (shouldBeVisible) {
            container.classList.remove('hidden');
        } else {
            container.classList.add('hidden');
        }
    });
}
function validateCurrentSection(sectionNumber) {
    const section = document.getElementById('section' + sectionNumber);
    if (!section) return true;
    // Only validate visible questions (not hidden ones)
    const questions = section.querySelectorAll('.question-container:not(.hidden)');
    let isValid = true;
    questions.forEach(question => {
        const questionId = question.id.replace('question-container-', '');
        const questionType = getQuestionTypeFromContainer(question);
        if (!validateQuestion(question, questionType, questionId)) {
            isValid = false;
        }
    });
    // Update next button state
    const nextButton = document.getElementById('next-button-' + sectionNumber);
    if (nextButton) {
        nextButton.disabled = !isValid;
    }
    return isValid;
}
function getQuestionTypeFromContainer(questionContainer) {
    // Check for different input types to determine question type
    if (questionContainer.querySelector('input[type="checkbox"]')) {
        return 'checkbox';
    } else if (questionContainer.querySelector('select')) {
        return 'dropdown';
    } else if (questionContainer.querySelector('input[type="text"]')) {
        return 'text';
    } else if (questionContainer.querySelector('input[type="email"]')) {
        return 'email';
    } else if (questionContainer.querySelector('input[type="tel"]')) {
        return 'phone';
    } else if (questionContainer.querySelector('input[type="number"]')) {
        return 'number';
    } else if (questionContainer.querySelector('input[type="date"]')) {
        return 'date';
    } else if (questionContainer.querySelector('textarea')) {
        return 'bigParagraph';
    }
    return 'text'; // default
}
function validateQuestion(questionContainer, questionType, questionId) {
    let isValid = true;
    switch (questionType) {
        case 'checkbox':
            isValid = validateCheckboxQuestion(questionContainer);
            break;
        case 'dropdown':
            isValid = validateDropdownQuestion(questionContainer);
            break;
        case 'text':
        case 'email':
        case 'phone':
        case 'number':
        case 'date':
        case 'bigParagraph':
            isValid = validateTextQuestion(questionContainer);
            break;
        default:
            isValid = true;
    }
    // Add visual feedback
    if (!isValid) {
        questionContainer.classList.add('form-field-required');
        showValidationError(questionContainer, 'This field is required.');
    } else {
        questionContainer.classList.remove('form-field-required');
        hideValidationError(questionContainer);
    }
    return isValid;
}
function validateCheckboxQuestion(questionContainer) {
    const checkboxes = questionContainer.querySelectorAll('input[type="checkbox"]');
    const checkedBoxes = Array.from(checkboxes).filter(cb => cb.checked);
    return checkedBoxes.length > 0;
}
function validateDropdownQuestion(questionContainer) {
    const select = questionContainer.querySelector('select');
    if (!select) return true;
    // Check if the dropdown has a value and it's not the default empty/disabled option
    const isValid = select.value && select.value.trim() !== '' && select.value !== 'Select an option';
    return isValid;
}
function validateTextQuestion(questionContainer) {
    const questionId = questionContainer.id.replace('question-container-', '');

    const inputs = questionContainer.querySelectorAll('input[type="text"], input[type="email"], input[type="tel"], input[type="number"], input[type="date"], textarea');

    if (inputs.length === 0) {

        return true;
    }
    // Filter out hidden inputs and inputs that are not eligible
    const eligibleInputs = Array.from(inputs).filter(input => {
        const style = window.getComputedStyle(input);
        const isVisible = style.display !== 'none' && style.visibility !== 'hidden';
        const isNotDisabled = !input.disabled;
        const isNotHiddenType = input.type !== 'hidden';
        const hasOffsetParent = input.offsetParent !== null || input.type === 'hidden';
        return isVisible && isNotDisabled && isNotHiddenType && (hasOffsetParent || input.type === 'text' || input.type === 'email' || input.type === 'tel' || input.type === 'number' || input.type === 'date');
    });

    if (eligibleInputs.length === 0) {

        return true;
    }
    for (let input of eligibleInputs) {
        const value = input.value ? input.value.trim() : '';

        if (!value) {

            return false;
        }
    }

    return true;
}
function showValidationError(container, message) {
    let errorDiv = container.querySelector('.validation-error');
    if (!errorDiv) {
        errorDiv = document.createElement('div');
        errorDiv.className = 'validation-error';
        container.appendChild(errorDiv);
    }
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
}
function hideValidationError(container) {
    const errorDiv = container.querySelector('.validation-error');
    if (errorDiv) {
        errorDiv.style.display = 'none';
    }
}
// Add validation listeners to all form fields
function addValidationListeners() {
    const currentSection = document.querySelector('.section.active');
    if (!currentSection) return;
    const sectionNumber = currentSection.id.replace('section', '');
    const formFields = currentSection.querySelectorAll('input, select, textarea');
    formFields.forEach(field => {
        // Remove existing listeners to prevent duplicates
        field.removeEventListener('change', field._validationHandler);
        field.removeEventListener('input', field._validationHandler);
        // Create new handler
        field._validationHandler = () => validateCurrentSection(sectionNumber);
        // Add listeners
        field.addEventListener('change', field._validationHandler);
        field.addEventListener('input', field._validationHandler);
    });
    // Initial validation
    validateCurrentSection(sectionNumber);
}
// Initialize validation when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    addValidationListeners();
    // Trigger visibility updates on DOM load to show dependent questions
    setTimeout(() => {
        if (typeof triggerVisibilityUpdates === 'function') {
            triggerVisibilityUpdates();
        }
    }, 300);
    // Re-add listeners when sections change
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                if (mutation.target.classList.contains('section')) {
                    setTimeout(addValidationListeners, 100);
                }
            }
        });
    });
    observer.observe(document.body, {
        attributes: true,
        subtree: true
    });
});
function showTextboxLabels(questionId, count){
    // ðŸ”§ NEW: Check if we're already creating fields
    if (isCreatingFields) {
        return;
    }
    const container = document.getElementById("labelContainer" + questionId);
    if(!container) {
        return;
    }
    // ðŸ”§ NEW: Check if we already have fields with values (more flexible than exact count match)
    const existingFields = container.querySelectorAll('input, select, textarea');
    const expectedCount = parseInt(count) || 0;
    // Check if we have the correct number of fields already
    if (existingFields.length > 0) {
        const currentCount = existingFields.length / (labelMap[questionId]?.length || 1); // Calculate how many entries we currently have
        // Only skip if we have the exact right number of fields AND they have values
        if (currentCount === expectedCount) {
            let hasValues = false;
            existingFields.forEach(field => {
                if (field.value && field.value.trim() !== '') {
                    hasValues = true;
                }
            });
            // If we have the right count and values, only skip during initial autofill
            if (hasValues && window.isInitialAutofill) {
                return;
            }
        }
        // ðŸ”§ NEW: If fields exist but have no values, check if we're in the middle of autofill
        // Check if autofill is currently running
        if (window.isInitialAutofill) {
            return;
        }
        // Check if there are any pending autofill operations
        const autofillInProgress = document.querySelector('[data-autofill-pending]');
        if (autofillInProgress) {
            return;
        }
    }
    container.innerHTML = "";
    // Try to get unified fields first, fallback to old arrays
    const qBlock = document.querySelector('#question-container-' + questionId)?.closest('.question-block') || 
                   document.querySelector('[id*="' + questionId + '"]')?.closest('.question-block');
    let allFieldsInOrder = [];
    if (qBlock) {
        const unifiedFields = Array.from(qBlock.querySelectorAll('#unifiedFields' + questionId + ' .unified-field'));
        if (unifiedFields.length > 0) {
            // Use unified container data
            const allElements = [];
            unifiedFields.forEach((el) => {
                const fieldType = el.getAttribute('data-type');
                const fieldOrder = parseInt(el.getAttribute('data-order'));
                const labelTextEl = el.querySelector('#labelText' + questionId + '_' + fieldOrder);
                const nodeIdTextEl = el.querySelector('#nodeIdText' + questionId + '_' + fieldOrder);
                const rawPrefillValue = el.getAttribute('data-prefill') || '';
                // ðŸ”§ IMPORTANT: Process URL parameters in prefill value when reading from DOM
                const prefillValue = rawPrefillValue ? replaceUrlParametersInText(rawPrefillValue) : '';
                if (labelTextEl && nodeIdTextEl) {
                    const fieldData = {
                        type: fieldType,
                        label: labelTextEl.textContent.trim(),
                        nodeId: nodeIdTextEl.textContent.trim(),
                        order: fieldOrder
                    };
                    // Include prefill for label fields, and conditional prefills for both label and amount fields
                    if (fieldType === 'label') {
                        fieldData.prefill = prefillValue;
                    }
                    // Include conditional prefills for both label and amount fields
                    if (fieldType === 'label' || fieldType === 'amount') {
                        const conditionalPrefillsData = el.getAttribute('data-conditional-prefills');
                        if (conditionalPrefillsData) {
                            try {
                                fieldData.conditionalPrefills = JSON.parse(conditionalPrefillsData);
                            } catch (e) {
                                // If parsing fails, ignore it
                            }
                        }
                    }
                    allElements.push(fieldData);
                }
            });
            // Sort by data-order attribute (creation order)
            allElements.sort((a, b) => a.order - b.order);
            allFieldsInOrder = allElements;
        }
    }
    // Fallback to unified fields map or old arrays if no unified fields found
    if (allFieldsInOrder.length === 0) {
        // Try unified fields map first
        if (window.unifiedFieldsMap && window.unifiedFieldsMap[questionId]) {
            // Clone the data and process URL parameters in prefill values
            allFieldsInOrder = window.unifiedFieldsMap[questionId].map(field => {
                const clonedField = {...field};
                if (clonedField.type === 'label' && clonedField.prefill) {
                    const rawPrefill = clonedField.prefill;
                    const processedPrefill = replaceUrlParametersInText(rawPrefill);
                    clonedField.prefill = processedPrefill;
                }
                // Also process URL parameters in conditional prefill values for both label and amount fields
                if ((clonedField.type === 'label' || clonedField.type === 'amount') && clonedField.conditionalPrefills && Array.isArray(clonedField.conditionalPrefills)) {
                    clonedField.conditionalPrefills = clonedField.conditionalPrefills.map(cp => ({
                        trigger: cp.trigger,
                        value: replaceUrlParametersInText(cp.value || '')
                    }));
                }
                return clonedField;
            });
        } else {
            // Fallback to old arrays
            const theseLabels = labelMap[questionId] || [];
            const theseAmounts = amountMap[questionId] || [];
            allFieldsInOrder = [
                ...theseLabels.map((lbl, index) => ({
                    type: 'label',
                    label: lbl,
                    nodeId: (window.labelNodeIdsMap && window.labelNodeIdsMap[questionId] ? window.labelNodeIdsMap[questionId] : [])[index] || "",
                    order: index
                })),
                ...theseAmounts.map((amt, index) => ({
                    type: 'amount',
                    label: amt,
                    nodeId: "",
                    order: index
                }))
            ];
        }
    }
    /* get and sanitise the question's visible text exactly once */
    const questionH3   = document
        .getElementById("question-container-" + questionId)
        ?.querySelector("h3")?.textContent || ("answer" + questionId);
    const qSafe = sanitizeQuestionText(questionH3);
    // Generate hidden checkboxes for the selected count
    generateHiddenCheckboxes(questionId, qSafe, count);
    // Generate hidden address textboxes for location fields
    generateHiddenAddressTextboxes(questionId, count, allFieldsInOrder);
    // Define location field names for visual separation
    const locationFields = ['Street', 'City', 'State', 'Zip'];
    for(let j = 1; j <= count; j++){
        let lastWasLocation = false;
        let firstField = true;
        // Create entry container div
        const entryContainer = document.createElement('div');
        entryContainer.className = 'entry-container';
        entryContainer.style.cssText = 'border: 2px solid #2980b9 !important; border-radius: 12px; padding: 20px; margin: 20px auto; background-color: #f8f9ff; box-shadow: 0 4px 8px rgba(41, 128, 185, 0.15); transition: all 0.3s ease; display: inline-block; width: auto; min-width: 585px; max-width: 100%; box-sizing: border-box;';
        // Add entry title if configured
        const entryTitle = (window.entryTitleMap && window.entryTitleMap[questionId]) ? window.entryTitleMap[questionId] : '';
        if (entryTitle) {
            const titleLabel = document.createElement('h4');
            titleLabel.textContent = entryTitle;
            titleLabel.style.cssText = 'margin: 0 0 15px 0; color: #2980b9; font-size: 16px; font-weight: 600; text-align: center; padding-bottom: 10px; border-bottom: 1px solid #e1e5e9;';
            entryContainer.appendChild(titleLabel);
        }
        // Process all fields in creation order
        for(let fieldIndex = 0; fieldIndex < allFieldsInOrder.length; fieldIndex++){
            const field = allFieldsInOrder[fieldIndex];
            const isLocationField = locationFields.includes(field.label);
            // Skip location fields that should be conditional trigger fields
            // Check if this question has a dropdown with trigger sequences that contain location fields
            const hasLocationTriggerFields = allFieldsInOrder.some(f => 
                f.type === 'dropdown' && 
                f.triggerSequences && 
                f.triggerSequences.some(seq => 
                    seq.fields && 
                    seq.fields.some(tf => tf.type === 'location')
                )
            );
            if (isLocationField && hasLocationTriggerFields) {
                // Skip this location field as it should be handled by trigger sequences
                continue;
            }
            // Add <br> before first location field in each count
            if (isLocationField && !lastWasLocation && !firstField) {
                const br = document.createElement('br');
                entryContainer.appendChild(br);
            }
            if (field.type === 'location') {
                // Render main location field block
                const locationFieldDiv = document.createElement('div');
                locationFieldDiv.style.cssText = 'margin: 10px 0; padding: 12px; background-color: #ffffff; border: 1px solid #e1e5e9; border-radius: 10px; display:flex; flex-direction:column; align-items:center; box-shadow: 0 2px 6px rgba(0,0,0,0.05);';
                const title = (field.fieldName || 'Location Data') + ':';
                const fieldNameLabel = document.createElement('label');
                fieldNameLabel.textContent = title;
                fieldNameLabel.style.cssText = 'display:block;margin-bottom:8px;font-weight:600;color:#333;font-size:15px;text-align:center;';
                locationFieldDiv.appendChild(fieldNameLabel);
                // Inputs
                const locs = [
                    { label:'Street', nodeId:'street' },
                    { label:'City', nodeId:'city' },
                    { label:'State', nodeId:'state' },
                    { label:'Zip', nodeId:'zip' }
                ];
                // Build locPrefix: question nodeId + location fieldName
                const questionNodeId = questionNameIds[questionId] || questionSlugMap[questionId] || 'answer' + questionId;
                const locationFieldName = sanitizeQuestionText(field.fieldName || 'location');
                const sanitizedLocationName = locationFieldName.replace(/ +/g, '_').toLowerCase();
                let locPrefix = questionNodeId + '_' + sanitizedLocationName;
                locs.forEach(f=>{
                    let input;
                    if (f.label === 'State'){
                        input = document.createElement('select');
                        input.id = locPrefix + '_' + f.nodeId + '_' + j;
                        input.name = input.id;
                        input.className = 'address-select-trigger';
                        // Create hidden short code field for state abbreviation
                        const shortHidden = document.createElement('input');
                        shortHidden.type = 'text';
                        shortHidden.id = locPrefix + '_state_short_' + j;
                        shortHidden.name = shortHidden.id;
                        shortHidden.style.display = 'none';
                        const defaultOption = document.createElement('option');
                        defaultOption.value = '';
                        defaultOption.textContent = 'Select State';
                        input.appendChild(defaultOption);
                        const states = ['Alabama','Alaska','Arizona','Arkansas','California','Colorado','Connecticut','Delaware','Florida','Georgia','Hawaii','Idaho','Illinois','Indiana','Iowa','Kansas','Kentucky','Louisiana','Maine','Maryland','Massachusetts','Michigan','Minnesota','Mississippi','Missouri','Montana','Nebraska','Nevada','New Hampshire','New Jersey','New Mexico','New York','North Carolina','North Dakota','Ohio','Oklahoma','Oregon','Pennsylvania','Rhode Island','South Carolina','South Dakota','Tennessee','Texas','Utah','Vermont','Virginia','Washington','West Virginia','Wisconsin','Wyoming'];
                        states.forEach(state=>{ const o=document.createElement('option'); o.value=state; o.textContent=state; input.appendChild(o); });
                        // Keep short field and hidden checkbox in sync with selection
                        input.addEventListener('change', function(){
                            if (typeof updateStateHiddenFields === 'function') {
                                updateStateHiddenFields(this, input.id, shortHidden.id);
                            }
                            if (typeof dropdownMirror === 'function') {
                                dropdownMirror(this, input.id);
                            }
                            if (typeof updateHiddenLogic === 'function') {
                                updateHiddenLogic(input.id, this.value);
                            }
                        });
                        // Append hidden short field to the container
                        const hiddenWrap = document.createElement('div');
                        hiddenWrap.style.display = 'none';
                        hiddenWrap.appendChild(shortHidden);
                        locationFieldDiv.appendChild(hiddenWrap);
                    } else {
                        input = document.createElement('input');
                        input.type = f.label === 'Zip' ? 'number' : 'text';
                        input.id = locPrefix + '_' + f.nodeId + '_' + j;
                        input.name = input.id;
                        input.placeholder = f.label; // Street, City, Zip
                        input.className = 'address-input';
                        input.style.textAlign = 'center'; // Ensure text is centered
                    }
                    const fieldWrap = document.createElement('div');
                    fieldWrap.className = 'address-field';
                    fieldWrap.appendChild(input);
                    locationFieldDiv.appendChild(fieldWrap);
                });
                entryContainer.appendChild(locationFieldDiv);
            } else if (field.type === 'label') {
                const fieldId = field.nodeId + "_" + j;
                // Prefill has already been processed through replaceUrlParametersInText when building allFieldsInOrder
                let prefillValue = field.prefill || '';
                // Check for conditional prefills - if current entry number (j) matches a trigger, use that value
                if (field.conditionalPrefills && Array.isArray(field.conditionalPrefills)) {
                    const matchingConditional = field.conditionalPrefills.find(cp => cp.trigger == j);
                    if (matchingConditional && matchingConditional.value) {
                        // Use conditional prefill value (process URL parameters if needed)
                        const rawConditionalValue = matchingConditional.value;
                        prefillValue = replaceUrlParametersInText(rawConditionalValue);
                    } else {
                    }
                } else {
                }
                if (field.label === 'State') {
                    // Use dropdown for State field
                    const dropdownDiv = document.createElement('div');
                    dropdownDiv.innerHTML = createStateDropdown(fieldId, j);
                    entryContainer.appendChild(dropdownDiv.firstElementChild);
                } else {
                    // Use regular input for other fields
                    const inputDiv = document.createElement('div');
                    const inputHTML = createAddressInput(fieldId, field.label, j, 'text', prefillValue);
                    inputDiv.innerHTML = inputHTML;
                    entryContainer.appendChild(inputDiv.firstElementChild);
                    // Verify the input was created with correct value (after a slight delay)
                    setTimeout(() => {
                        const createdInput = document.getElementById(fieldId);
                        // Add a watcher to see if/when the value changes
                        if (createdInput) {
                            const originalValue = createdInput.value;
                            const observer = new MutationObserver(() => {
                                if (createdInput.value !== originalValue) {
                                }
                            });
                            // Watch for attribute changes
                            observer.observe(createdInput, { attributes: true, attributeFilter: ['value'] });
                            // Also watch for direct value property changes
                            let lastValue = createdInput.value;
                            setInterval(() => {
                                if (createdInput.value !== lastValue) {
                                    lastValue = createdInput.value;
                                }
                            }, 100);
                        }
                    }, 100);
                }
            } else if (field.type === 'phone') {
                const fieldId = field.nodeId + "_" + j;
                const inputDiv = document.createElement('div');
                // No conditional prefills expected for phone, but keep for parity
                let prefillValue = '';
                if (field.conditionalPrefills && Array.isArray(field.conditionalPrefills)) {
                    const matchingConditional = field.conditionalPrefills.find(cp => cp.trigger == j);
                    if (matchingConditional && matchingConditional.value) {
                        prefillValue = replaceUrlParametersInText(matchingConditional.value);
                    }
                } else if (field.prefill) {
                    prefillValue = field.prefill;
                }
                const safePrefill = prefillValue ? prefillValue.replace(/"/g, '&quot;') : '';
                inputDiv.innerHTML =
                  '<div class="address-field">' +
                    '<input type="tel"' +
                    ' id="' + fieldId + '"' +
                    ' name="' + fieldId + '"' +
                    ' placeholder="' + (field.label || 'Phone') + '"' +
                    ' class="address-input"' +
                    ' style="margin: 4px auto; max-width: 400px;"' +
                    ' oninput="formatPhoneInput(this)"' +
                    ' value="' + safePrefill + '">' +
                  '</div>';
                // Append all children (wrapper + input)
                Array.from(inputDiv.children).forEach(child => entryContainer.appendChild(child));
            } else if (field.type === 'amount') {
                const fieldId = field.nodeId + "_" + j;
                const inputDiv = document.createElement('div');
                let prefillValue = '';
                // Check for conditional prefills - if current entry number (j) matches a trigger, use that value
                if (field.conditionalPrefills && Array.isArray(field.conditionalPrefills)) {
                    const matchingConditional = field.conditionalPrefills.find(cp => cp.trigger == j);
                    if (matchingConditional && matchingConditional.value) {
                        // Use conditional prefill value (process URL parameters if needed)
                        prefillValue = replaceUrlParametersInText(matchingConditional.value);
                    }
                }
                inputDiv.innerHTML = createAddressInput(fieldId, field.label, j, 'number', prefillValue);
                entryContainer.appendChild(inputDiv.firstElementChild);
                // Add a <br> after the Zip input only if there are more fields after it
                const remainingFields = allFieldsInOrder.slice(fieldIndex + 1);
                if (remainingFields.length > 0) {
                  const brElement = document.createElement('br');
                  entryContainer.appendChild(brElement);
                }
            } else if (field.type === 'checkbox') {
                // Add line break above checkbox section
                const brBeforeCheckbox = document.createElement('br');
                entryContainer.appendChild(brBeforeCheckbox);
                // Handle checkbox fields
                const checkboxFieldDiv = document.createElement('div');
                checkboxFieldDiv.style.cssText = 'margin: 15px 0; padding: 20px; border: 2px solid #87CEEB; border-radius: 12px; background: linear-gradient(135deg, #f0f8ff 0%, #e6f3ff 100%); box-shadow: 0 2px 8px rgba(135, 206, 235, 0.15);';
                // Add field name as a label
                const fieldNameLabel = document.createElement('h4');
                fieldNameLabel.textContent = field.label;
                fieldNameLabel.style.cssText = 'margin: 0 0 15px 0; color: #2980b9; font-size: 18px; font-weight: 600; text-align: center;';
                checkboxFieldDiv.appendChild(fieldNameLabel);
                // Get checkbox options from the field data
                const checkboxOptions = field.options || [];
                const selectionType = field.selectionType || 'multiple'; // Default to multiple if not specified
                // Create checkbox/radio options
                checkboxOptions.forEach((option, optionIndex) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.style.cssText = 'margin: 12px 0; padding: 10px; background-color: rgba(255, 255, 255, 0.7); border-radius: 8px; border: 1px solid rgba(135, 206, 235, 0.3); display: flex; align-items: center; transition: all 0.2s ease;';
                    // Add hover effect
                    optionDiv.addEventListener('mouseenter', function() {
                        this.style.backgroundColor = 'rgba(135, 206, 235, 0.1)';
                        this.style.borderColor = '#87CEEB';
                    });
                    optionDiv.addEventListener('mouseleave', function() {
                        this.style.backgroundColor = 'rgba(255, 255, 255, 0.7)';
                        this.style.borderColor = 'rgba(135, 206, 235, 0.3)';
                    });
                    const input = document.createElement('input');
                    input.type = selectionType === 'single' ? 'radio' : 'checkbox';
                    input.id = selectionType === 'single' ? option.nodeId + "_" + j + "_radio" : option.nodeId + "_" + j;
                    input.name = selectionType === 'single' ? 'radio_group_' + (questionId || 'unknown') + '_' + j : option.nodeId + "_" + j; // Radio buttons share the same name
                    input.value = option.text;
                    input.style.cssText = 'margin-right: 12px; width: 18px; height: 18px; accent-color: #2980b9; cursor: pointer;';
                    // Handle linked fields for this checkbox option
                    // For numbered dropdowns, we need to append entry number to linked field nodeIds and titles
                    const linkedFields = (option.linkedFields || []).map(linkedField => {
                        if (linkedField.nodeId && linkedField.title) {
                            return {
                                nodeId: linkedField.nodeId + '_' + j, // Append entry number to nodeId
                                title: linkedField.title + '_' + j   // Append entry number to title (hidden field ID)
                            };
                        }
                        return linkedField;
                    });
                    // Handle PDF entries for this checkbox option
                    const pdfEntries = option.pdfEntries || [];
                    // Function to add PDF entries when checkbox is checked
                    function addPdfEntries() {
                        pdfEntries.forEach((pdfEntry) => {
                            // Check if trigger number matches entry number (for numberedDropdown, j is the entry number)
                            const triggerNumber = parseInt(pdfEntry.triggerNumber) || 1;
                            if (triggerNumber === j && pdfEntry.pdfName && pdfEntry.pdfFile && pdfEntry.priceId) {
                                // Add to global checkbox PDF entries array
                                if (!window.checkboxPdfEntries) {
                                    window.checkboxPdfEntries = [];
                                }
                                // Check if this PDF entry already exists (avoid duplicates)
                                const existingEntry = window.checkboxPdfEntries.find(entry => 
                                    entry.pdfName === pdfEntry.pdfName && 
                                    entry.entryNumber === j &&
                                    entry.checkboxId === input.id
                                );
                                if (!existingEntry) {
                                    window.checkboxPdfEntries.push({
                                        pdfName: pdfEntry.pdfName,
                                        pdfFile: pdfEntry.pdfFile,
                                        priceId: pdfEntry.priceId,
                                        entryNumber: j,
                                        checkboxId: input.id
                                    });
                                }
                            } else {
                            }
                        });
                    }
                    // Function to remove PDF entries when checkbox is unchecked
                    function removePdfEntries() {
                        if (window.checkboxPdfEntries) {
                            // Remove PDF entries for this checkbox and entry number
                            window.checkboxPdfEntries = window.checkboxPdfEntries.filter(entry => 
                                !(entry.checkboxId === input.id && entry.entryNumber === j)
                            );
                        }
                    }
                    // Function to create linked textboxes when checkbox is checked
                    function createLinkedTextboxes() {

                        linkedFields.forEach((linkedField, index) => {

                            if (linkedField.nodeId && linkedField.title) {
                                // linkedField.nodeId already has entry number appended from mapping above
                                const sourceFieldId = linkedField.nodeId;

                                const sourceField = document.getElementById(sourceFieldId);

                                if (sourceField) {
                                    // linkedField.title already has entry number appended from mapping above
                                    const hiddenTextboxId = linkedField.title;

                                    // Check if hidden textbox already exists
                                    const existingHiddenTextbox = document.getElementById(hiddenTextboxId);
                                    if (existingHiddenTextbox) {

                                        existingHiddenTextbox.value = sourceField.value || '';
                                        return; // Skip creating duplicate, but update value
                                    }
                                    // Create hidden textbox with title as ID
                                    const hiddenTextbox = document.createElement('input');
                                    hiddenTextbox.type = 'text';
                                    hiddenTextbox.id = hiddenTextboxId;
                                    hiddenTextbox.name = hiddenTextboxId;
                                    hiddenTextbox.style.display = 'none';
                                    hiddenTextbox.value = sourceField.value || '';

                                    // Add to form (append to form element, not body)
                                    const form = document.getElementById('customForm');
                                    if (form) {
                                        form.appendChild(hiddenTextbox);

                                    } else {
                                        document.body.appendChild(hiddenTextbox);

                                    }
                                    // Sync with source field
                                    function syncLinkedField() {
                                        const oldValue = hiddenTextbox.value;
                                        hiddenTextbox.value = sourceField.value || '';
                                        if (oldValue !== hiddenTextbox.value) {

                                        }
                                        // Trigger linked field synchronization if updateLinkedFields function exists
                                        if (typeof updateLinkedFields === 'function') {
                                            updateLinkedFields();
                                        }
                                    }
                                    // Initial sync
                                    syncLinkedField();
                                    // Listen for changes on source field
                                    sourceField.addEventListener('input', syncLinkedField);
                                    sourceField.addEventListener('change', syncLinkedField);

                                    // Poll periodically to catch any missed updates (especially for autofill)
                                    // This ensures the linked textbox always stays in sync, even if events are missed
                                    const pollInterval = setInterval(function() {
                                        if (hiddenTextbox.value !== sourceField.value) {

                                            syncLinkedField();
                                        }
                                    }, 100); // Check every 100ms
                                    // Store references for cleanup
                                    hiddenTextbox._syncFunction = syncLinkedField;
                                    hiddenTextbox._sourceField = sourceField;
                                    hiddenTextbox._pollInterval = pollInterval;
                                } else {

                                }
                            } else {

                            }
                        });
                    }
                    // Function to remove linked textboxes when checkbox is unchecked
                    function removeLinkedTextboxes() {

                        linkedFields.forEach((linkedField) => {
                            if (linkedField.title) {
                                // linkedField.title already has entry number appended from mapping above
                                const hiddenTextboxId = linkedField.title;

                                const hiddenTextbox = document.getElementById(hiddenTextboxId);
                                if (hiddenTextbox) {

                                    // Remove event listeners
                                    if (hiddenTextbox._syncFunction && hiddenTextbox._sourceField) {
                                        hiddenTextbox._sourceField.removeEventListener('input', hiddenTextbox._syncFunction);
                                        hiddenTextbox._sourceField.removeEventListener('change', hiddenTextbox._syncFunction);

                                    }
                                    // Clear polling interval
                                    if (hiddenTextbox._pollInterval) {
                                        clearInterval(hiddenTextbox._pollInterval);

                                    }
                                    // Remove the hidden textbox
                                    hiddenTextbox.remove();

                                } else {

                                }
                            }
                        });
                        // Update linked fields after removing textboxes
                        if (typeof updateLinkedFields === 'function') {
                            updateLinkedFields();
                        }
                    }
                    // Add event listener for checkbox/radio changes
                    input.addEventListener('change', function() {

                        if (this.checked) {

                            createLinkedTextboxes();
                            addPdfEntries();
                        } else {

                            removeLinkedTextboxes();
                            removePdfEntries();
                        }
                    });
                    // Add event listener for radio buttons to create hidden checkboxes
                    if (selectionType === 'single') {
                        input.addEventListener('change', function() {
                            if (this.checked) {
                                // Uncheck all other radio buttons in this group and remove their hidden checkboxes
                                const radioGroup = document.querySelectorAll('input[name="' + this.name + '"]');
                                radioGroup.forEach(radio => {
                                    if (radio !== this) {
                                        radio.checked = false;
                                        // Remove hidden checkbox for unchecked radio
                                        // The hidden checkbox ID should be the original nodeId (without _radio suffix)
                    let originalNodeId;
                    if (isMultipleTextboxes && sanitizedDropdownName && sanitizedTriggerCondition) {
                      // For multipleTextboxes, remove _radio suffix to get the checkbox ID
                      originalNodeId = radio.id.replace('_radio', '');
                    } else {
                      originalNodeId = radio.id.replace('_radio', '');
                    }
                                        const existingHiddenCheckbox = document.getElementById(originalNodeId);
                                        if (existingHiddenCheckbox) {
                                            if (existingHiddenCheckbox.type === 'checkbox' && existingHiddenCheckbox.style.display === 'none') {
                                                existingHiddenCheckbox.remove();
                                            }
                                        }
                                        // Also remove linked textboxes and PDF entries for unchecked radio
                                        const uncheckedOption = checkboxOptions.find(opt => {
                                            const optId = selectionType === 'single' ? opt.nodeId + "_" + j + "_radio" : opt.nodeId + "_" + j;
                                            return optId === radio.id;
                                        });
                                        if (uncheckedOption) {
                                            // Remove linked textboxes
                                            if (uncheckedOption.linkedFields) {
                                                uncheckedOption.linkedFields.forEach((linkedField) => {
                                                    if (linkedField.title) {
                                                        const hiddenTextboxId = linkedField.title + "_" + j;
                                                        const hiddenTextbox = document.getElementById(hiddenTextboxId);
                                                        if (hiddenTextbox) {
                                                            if (hiddenTextbox._syncFunction && hiddenTextbox._sourceField) {
                                                                hiddenTextbox._sourceField.removeEventListener('input', hiddenTextbox._syncFunction);
                                                                hiddenTextbox._sourceField.removeEventListener('change', hiddenTextbox._syncFunction);
                                                            }
                                                            // Clear polling interval
                                                            if (hiddenTextbox._pollInterval) {
                                                                clearInterval(hiddenTextbox._pollInterval);
                                                            }
                                                            hiddenTextbox.remove();
                                                        }
                                                    }
                                                });
                                                // Update linked fields after removing textboxes
                                                if (typeof updateLinkedFields === 'function') {
                                                    updateLinkedFields();
                                                }
                                            }
                                            // Remove PDF entries for unchecked radio
                                            if (window.checkboxPdfEntries && uncheckedOption.pdfEntries) {
                                                const uncheckedRadioId = radio.id;
                                                window.checkboxPdfEntries = window.checkboxPdfEntries.filter(entry => 
                                                    !(entry.checkboxId === uncheckedRadioId && entry.entryNumber === j)
                                                );
                                            }
                                        }
                                    }
                                });
                                // Create hidden checkbox for the selected radio
                                // Use the original nodeId (without _radio suffix) for the hidden checkbox
                // For multipleTextboxes, the ID already has the full format, so just remove _radio
                // For numberedDropdown, remove _radio to get the base nodeId
                                const originalNodeId = this.id.replace('_radio', '');
                                createHiddenCheckboxForRadio(originalNodeId, this.name, this.value);
                                createLinkedTextboxes();
                                addPdfEntries(); // Add PDF entries for the newly checked radio
                            }
                        });
                    }
                    const label = document.createElement('label');
                    label.textContent = option.text;
                    label.style.cssText = 'flex: 1; cursor: pointer; color: #2c3e50; font-size: 15px; font-weight: 500; margin: 0;';
                    label.setAttribute('for', input.id);
                    optionDiv.appendChild(input);
                    optionDiv.appendChild(label);
                    checkboxFieldDiv.appendChild(optionDiv);
                });
                entryContainer.appendChild(checkboxFieldDiv);
            } else if (field.type === 'date') {
                // Add line break above date field
                const brBeforeDate = document.createElement('br');
                entryContainer.appendChild(brBeforeDate);
                // Handle date fields
                const fieldId = field.nodeId + "_" + j;
                const dateDiv = document.createElement('div');
                dateDiv.style.cssText = 'margin: 10px 0; padding: 12px; background-color: white; border: 1px solid #ddd; border-radius: 8px; display: flex; flex-direction: column; align-items: center;';
                const label = document.createElement('label');
                label.textContent = field.label + ":";
                label.style.cssText = 'display: block; margin-bottom: 8px; font-weight: bold; color: #2c3e50; font-size: 15px; text-align: center;';
                const input = document.createElement('input');
                input.type = 'date';
                input.id = fieldId;
                input.name = fieldId;
                input.style.cssText = 'width: 200px; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; background-color: white; color: #2c3e50; cursor: pointer; transition: all 0.2s ease; margin: 0 auto;';
                // Add hover effect
                input.addEventListener('mouseenter', function() {
                    this.style.borderColor = '#999';
                    this.style.backgroundColor = '#f9f9f9';
                });
                input.addEventListener('mouseleave', function() {
                    this.style.borderColor = '#ddd';
                    this.style.backgroundColor = 'white';
                });
                // Ensure clicking anywhere on the input opens the calendar
                input.addEventListener('click', function() {
                    this.showPicker();
                });
                // Also handle focus to ensure calendar opens
                input.addEventListener('focus', function() {
                    this.showPicker();
                });
                dateDiv.appendChild(label);
                dateDiv.appendChild(input);
                entryContainer.appendChild(dateDiv);
            } else if (field.type === 'dropdown') {
                // Add line break above dropdown field
                const brBeforeDropdown = document.createElement('br');
                entryContainer.appendChild(brBeforeDropdown);
                // Handle dropdown fields
                const dropdownFieldDiv = document.createElement('div');
                dropdownFieldDiv.style.cssText = 'margin: 15px 0; padding: 20px; border: 2px solid #2196F3; border-radius: 12px; background: linear-gradient(135deg, #f0f8ff 0%, #e3f2fd 100%); box-shadow: 0 2px 8px rgba(33, 150, 243, 0.15);';
                // Add field name as a label
                const fieldNameLabel = document.createElement('h4');
                fieldNameLabel.textContent = field.fieldName;
                fieldNameLabel.style.cssText = 'margin: 0 0 15px 0; color: #1976D2; font-size: 18px; font-weight: 600; text-align: center;';
                dropdownFieldDiv.appendChild(fieldNameLabel);
                // Create dropdown select element
                const select = document.createElement('select');
                // Sanitize fieldName: remove question marks, replace spaces and non-word chars with underscores, convert to lowercase
                const sanitizedFieldName = field.fieldName
                    .toLowerCase()  // Convert to lowercase FIRST before processing
                    .replace(/[?]/g, '')  // Remove question marks (use character class to avoid regex escaping issues)
                    .replace(/[^a-z0-9_]+/g, '_')  // Replace non-word characters with underscores (use character class instead of W)
                    .replace(/^_+|_+$/g, '');  // Remove leading/trailing underscores
                select.id = sanitizedFieldName + "_" + j;
                select.name = select.id;
                select.style.cssText = 'width: 100%; padding: 12px; border: 1px solid #2196F3; border-radius: 8px; font-size: 14px; background-color: white; color: #2c3e50; cursor: pointer; transition: all 0.2s ease;';
                // Add placeholder option
                const placeholderOption = document.createElement('option');
                placeholderOption.value = '';
                placeholderOption.textContent = 'Select an option...';
                placeholderOption.disabled = true;
                placeholderOption.selected = true;
                select.appendChild(placeholderOption);
                // Add dropdown options
                const dropdownOptions = field.options || [];
                dropdownOptions.forEach((option, optionIndex) => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option.text;
                    optionElement.textContent = option.text;
                    optionElement.setAttribute('data-node-id', option.nodeId);
                    select.appendChild(optionElement);
                });
                // Function to reset all fields in a trigger sequence container
                function resetTriggerSequenceFields(container) {
                    if (!container) return;
                    // Reset text inputs (labels)
                    const textInputs = container.querySelectorAll('input[type="text"]:not([style*="display: none"])');
                    textInputs.forEach(input => {
                        input.value = '';
                    });
                    // Reset number inputs (like Zip)
                    const numberInputs = container.querySelectorAll('input[type="number"]');
                    numberInputs.forEach(input => {
                        input.value = '';
                    });
                    // Reset date inputs
                    const dateInputs = container.querySelectorAll('input[type="date"]');
                    dateInputs.forEach(input => {
                        input.value = '';
                    });
                    // Reset checkboxes (uncheck all)
                    const checkboxes = container.querySelectorAll('input[type="checkbox"]');
                    checkboxes.forEach(checkbox => {
                        checkbox.checked = false;
                    });
                    // Reset radio buttons (uncheck all)
                    const radios = container.querySelectorAll('input[type="radio"]');
                    radios.forEach(radio => {
                        radio.checked = false;
                        // Remove hidden checkboxes created by radio buttons
                        const originalNodeId = radio.id.replace('_radio', '');
                        const hiddenCheckbox = document.getElementById(originalNodeId);
                        if (hiddenCheckbox && hiddenCheckbox.type === 'checkbox' && hiddenCheckbox.style.display === 'none') {
                            hiddenCheckbox.remove();
                        }
                    });
                    // Reset dropdowns (select elements) - set to placeholder/default option
                    const selects = container.querySelectorAll('select');
                    selects.forEach(select => {
                        // Find the first disabled option (placeholder) or first option
                        const placeholderOption = select.querySelector('option[disabled]');
                        if (placeholderOption) {
                            select.value = '';
                            placeholderOption.selected = true;
                        } else if (select.options.length > 0) {
                            select.selectedIndex = 0;
                        }
                        // Also reset any hidden dropdown inputs
                        const hiddenDropdownInput = document.getElementById(select.id + '_dropdown');
                        if (hiddenDropdownInput) {
                            hiddenDropdownInput.value = '';
                        }
                        // Clear hidden checkboxes created by dropdownMirror
                        const dropdownWrapper = document.getElementById('dropdowntext_' + select.id);
                        if (dropdownWrapper) {
                            dropdownWrapper.innerHTML = '';
                            // Re-add the hidden input if it was removed
                            const existingHiddenInput = document.getElementById(select.id + '_dropdown');
                            if (!existingHiddenInput) {
                                const hiddenInput = document.createElement('input');
                                hiddenInput.type = 'text';
                                hiddenInput.id = select.id + '_dropdown';
                                hiddenInput.name = select.id + '_dropdown';
                                hiddenInput.style.display = 'none';
                                dropdownWrapper.appendChild(hiddenInput);
                            }
                        }
                    });
                    // Reset state dropdowns (they have hidden short fields)
                    const stateSelects = container.querySelectorAll('select.address-select-main');
                    stateSelects.forEach(select => {
                        const shortHiddenId = select.id.replace('_state_', '_state_short_');
                        const shortHidden = document.getElementById(shortHiddenId);
                        if (shortHidden) {
                            shortHidden.value = '';
                        }
                    });
                }
                // Function to handle conditional logic
                function handleConditionalLogic() {
                    const selectedValue = select.value;
                    const selectedOption = select.options[select.selectedIndex];
                    const nodeId = selectedOption ? selectedOption.getAttribute('data-node-id') : '';
                    // Handle trigger sequences
                    if (field.triggerSequences && field.triggerSequences.length > 0) {
                        field.triggerSequences.forEach((sequence, sequenceIndex) => {
                            if (sequence.condition === selectedValue) {
                                // Show trigger fields for this condition
                                const triggerFieldsContainer = document.getElementById('triggerFields_' + questionId + '_' + j + '_' + sequenceIndex);
                                if (triggerFieldsContainer) {
                                    triggerFieldsContainer.style.display = 'block';
                                } else {
                                    // Create trigger fields container if it doesn't exist
                                    const triggerTitle = sequence.title || 'Additional Information';
                                    // Extract parent dropdown's base nodeId from first option's nodeId
                                    let parentDropdownBaseNodeId = '';
                                    if (field.options && field.options.length > 0 && field.options[0].nodeId) {
                                      const firstOptionNodeId = field.options[0].nodeId;
                                      const lastUnderscoreIndex = firstOptionNodeId.lastIndexOf('_');
                                      if (lastUnderscoreIndex > 0) {
                                        parentDropdownBaseNodeId = firstOptionNodeId.substring(0, lastUnderscoreIndex);
                                      } else {
                                        parentDropdownBaseNodeId = firstOptionNodeId;
                                      }
                                    }
                                    const triggerCondition = sequence.condition || '';
                                    createTriggerFieldsContainer(questionId, j, sequenceIndex, sequence.fields, dropdownFieldDiv, field.fieldName, triggerTitle, parentDropdownBaseNodeId, triggerCondition, false);
                                }
                            } else {
                                // Hide trigger fields for other conditions and reset their values
                                const triggerFieldsContainer = document.getElementById('triggerFields_' + questionId + '_' + j + '_' + sequenceIndex);
                                if (triggerFieldsContainer) {
                                    // Reset all fields before hiding
                                    resetTriggerSequenceFields(triggerFieldsContainer);
                                    triggerFieldsContainer.style.display = 'none';
                                }
                            }
                        });
                        // ðŸ”§ NEW: Trigger navigation refresh after showing/hiding trigger fields
                        // This ensures the Next button state updates correctly
                        setTimeout(() => {
                            const questionContainer = document.getElementById('question-container-' + questionId);
                            if (questionContainer) {
                                const sectionEl = questionContainer.closest('.section');
                                if (sectionEl && window.questionNavControllers) {
                                    const sectionId = sectionEl.id;
                                    const navController = window.questionNavControllers[sectionId];
                                    if (typeof navController === 'function') {
                                        // Trigger navigation refresh by dispatching a custom event
                                        const refreshEvent = new CustomEvent('refreshNavigation', { 
                                            detail: { questionId: questionId } 
                                        });
                                        questionContainer.dispatchEvent(refreshEvent);
                                    }
                                }
                            }
                        }, 150);
                    }
                }
                // Add change event listener for conditional logic and dropdown mirror
                select.addEventListener('change', function() {
                    handleConditionalLogic();
                    // Call dropdownMirror to create hidden checkboxes
                    if (typeof dropdownMirror === 'function') {
                        dropdownMirror(this, this.id);
                    }
                    // Update hidden logic if needed
                    if (typeof updateHiddenLogic === 'function') {
                        updateHiddenLogic(this.id, this.value);
                    }
                });
                // Also check on load in case Firebase autofills the dropdown
                setTimeout(handleConditionalLogic, 100);
                // Additional checks for Firebase autofill with longer delays
                setTimeout(handleConditionalLogic, 500);
                setTimeout(handleConditionalLogic, 1000);
                setTimeout(handleConditionalLogic, 2000);
                // Also check when the page is fully loaded
                if (document.readyState === 'complete') {
                    setTimeout(handleConditionalLogic, 100);
                } else {
                    window.addEventListener('load', () => {
                        setTimeout(handleConditionalLogic, 100);
                    });
                }
                // Watch for value changes using MutationObserver (for Firebase autofill)
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'value') {
                            setTimeout(handleConditionalLogic, 50);
                        }
                    });
                });
                // Start observing the select element for value changes
                observer.observe(select, { 
                    attributes: true, 
                    attributeFilter: ['value'] 
                });
                // Also watch for input events that might be triggered by autofill
                select.addEventListener('input', handleConditionalLogic);
                dropdownFieldDiv.appendChild(select);
                // Create wrapper div for hidden checkboxes (required for dropdownMirror)
                const dropdownWrapper = document.createElement('div');
                dropdownWrapper.id = 'dropdowntext_' + select.id;
                dropdownWrapper.style.display = 'none';
                dropdownFieldDiv.appendChild(dropdownWrapper);
                // Create hidden text input for dropdown value (matching regular dropdown structure)
                const hiddenDropdownInput = document.createElement('input');
                hiddenDropdownInput.type = 'text';
                hiddenDropdownInput.id = select.id + '_dropdown';
                hiddenDropdownInput.name = select.id + '_dropdown';
                hiddenDropdownInput.readOnly = true;
                hiddenDropdownInput.style.display = 'none';
                dropdownFieldDiv.appendChild(hiddenDropdownInput);
                entryContainer.appendChild(dropdownFieldDiv);
            }
            lastWasLocation = isLocationField;
            firstField = false;
        }
        // Append the entry container to the main container
        container.appendChild(entryContainer);
        // Add 1 <br> tag after each entry for better visual separation
        const br = document.createElement('br');
        container.appendChild(br);
    }
    attachCalculationListeners();   // keep this
    // Update linked fields after creating new textboxes
    updateLinkedFields();
    // ðŸ”§ NEW: Trigger navigation refresh after fields are created so Next button updates
    // Find the question container and trigger navigation refresh
    const questionContainer = document.getElementById('question-container-' + questionId);
    if (questionContainer) {
        // Use setTimeout to ensure DOM is fully updated
        setTimeout(() => {
            // Find which section this question is in
            const sectionEl = questionContainer.closest('.section');
            if (sectionEl) {
                // Find all question containers in this section
                const questionItems = Array.from(sectionEl.querySelectorAll('.question-container.question-item'));
                const containerIdx = questionItems.indexOf(questionContainer);
                if (containerIdx !== -1 && window.questionNavControllers) {
                    const sectionId = sectionEl.id;
                    // Get the navigation controller function
                    const navController = window.questionNavControllers[sectionId];
                    if (typeof navController === 'function') {
                        // The navigation controller has access to refreshNav - we need to trigger it
                        // Dispatch a custom event that the navigation code can listen for
                        const refreshEvent = new CustomEvent('refreshNavigation', { 
                            detail: { questionId: questionId, containerIdx: containerIdx } 
                        });
                        questionContainer.dispatchEvent(refreshEvent);
                        // Also try to directly call refreshNav if it's accessible
                        // We'll rely on the event delegation listeners to catch user input
                        // and the mutation observer to catch DOM changes
                    }
                }
            }
        }, 100);
    }
    // ðŸ”§ NEW: Immediately autofill newly created fields if Firebase data is available
    // This ensures fields are autofilled instantly instead of waiting for delayed passes
    if (window.mappedData && typeof window.mappedData === 'object') {
        const allCreatedFields = container.querySelectorAll('input, select, textarea');
        allCreatedFields.forEach(field => {
            if (field.id || field.name) {
                const fieldId = field.id || field.name;
                let autofillValue = null;
                // Check both by name and by ID for autofill
                if (window.mappedData.hasOwnProperty(field.name)) {
                    autofillValue = window.mappedData[field.name];
                } else if (fieldId && window.mappedData.hasOwnProperty(fieldId)) {
                    autofillValue = window.mappedData[fieldId];
                }
                if (autofillValue !== null && autofillValue !== '') {
                    // Skip current_date field - it should be set dynamically
                    if (fieldId === 'current_date' || field.name === 'current_date') {
                        return;
                    }
                    if (field.type === 'checkbox' || field.type === 'radio') {
                        if (field.type === 'radio') {
                            // For radio buttons, check if this specific radio should be selected
                            if (field.value === autofillValue) {
                                field.checked = true;
                                const changeEvent = new Event('change', { bubbles: true });
                                field.dispatchEvent(changeEvent);
                            } else {
                                field.checked = false;
                            }
                        } else {
                            // For checkboxes, use the boolean value
                            const wasChecked = field.checked;
                            field.checked = !!autofillValue;
                            if (field.checked !== wasChecked) {
                                const changeEvent = new Event('change', { bubbles: true });
                                field.dispatchEvent(changeEvent);
                            }
                        }
                    } else {
                        const previousValue = field.value;
                        field.value = autofillValue;
                        // Dispatch input and change events for text inputs to trigger linked textbox syncing
                        if (field.tagName === 'INPUT' && (field.type === 'text' || field.type === 'number' || !field.type)) {
                            const inputEvent = new Event('input', { bubbles: true });
                            field.dispatchEvent(inputEvent);
                            const changeEvent = new Event('change', { bubbles: true });
                            field.dispatchEvent(changeEvent);
                        }
                        // If this is a select element (dropdown), trigger change event
                        if (field.tagName === 'SELECT') {
                            const changeEvent = new Event('change', { bubbles: true });
                            field.dispatchEvent(changeEvent);
                        }
                    }
                }
            }
        });
    }
    // Attach autosave listeners to newly generated textbox inputs
    const newInputs = container.querySelectorAll('input[type="text"], input[type="number"]');
    newInputs.forEach(input => {
        input.addEventListener('input', function() {
            // Add a small delay to ensure the value is properly set before saving
            setTimeout(() => {
                if (typeof isUserLoggedIn !== 'undefined' && isUserLoggedIn) {
                    if (typeof saveAnswers === 'function') {
                        saveAnswers();
                    }
                } else {
                    if (typeof saveAnswersToLocalStorage === 'function') {
                        saveAnswersToLocalStorage();
                    }
                }
            }, 100); // 100ms delay to ensure value is set
        });
        input.addEventListener('change', function() {
            // Add a small delay to ensure the value is properly set before saving
            setTimeout(() => {
                if (typeof isUserLoggedIn !== 'undefined' && isUserLoggedIn) {
                    if (typeof saveAnswers === 'function') {
                        saveAnswers(true); // Save immediately on change
                    }
                } else {
                    if (typeof saveAnswersToLocalStorage === 'function') {
                        saveAnswersToLocalStorage();
                    }
                }
            }, 100); // 100ms delay to ensure value is set
        });
    });
    // ðŸ”§ NEW: Clear flag after function completes
    isCreatingFields = false;
}
// Reset all fields in a numbered dropdown question to their default values
function resetNumberedDropdownFields(questionId) {
    // Reset the main dropdown select to its default (empty/placeholder)
    const dropdownId = questionNameIds[questionId] || ("answer" + questionId);
    const dropdown = document.getElementById(dropdownId);
    if (dropdown) {
        dropdown.value = '';
        // Find and select the placeholder option
        const placeholderOption = dropdown.querySelector('option[disabled]');
        if (placeholderOption) {
            placeholderOption.selected = true;
        } else if (dropdown.options.length > 0) {
            dropdown.selectedIndex = 0;
        }
        // Don't trigger change event here - it causes initialization issues with isCreatingFields
        // Instead, we'll clear the container directly
    } else {
    }
    // Get the label container
    const container = document.getElementById("labelContainer" + questionId);
    if (!container) {
        return;
    }
    // Reset all text inputs (labels)
    const textInputs = container.querySelectorAll('input[type="text"]:not([style*="display: none"])');
    textInputs.forEach(input => {
        input.value = '';
    });
    // Reset number inputs (like Zip in location fields)
    const numberInputs = container.querySelectorAll('input[type="number"]');
    numberInputs.forEach(input => {
        input.value = '';
    });
    // Reset date inputs
    const dateInputs = container.querySelectorAll('input[type="date"]');
    dateInputs.forEach(input => {
        input.value = '';
    });
    // Reset checkboxes (uncheck all)
    const checkboxes = container.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach(checkbox => {
        checkbox.checked = false;
    });
    // Reset radio buttons (uncheck all)
    const radios = container.querySelectorAll('input[type="radio"]');
    radios.forEach(radio => {
        radio.checked = false;
        // Remove hidden checkboxes created by radio buttons
        const originalNodeId = radio.id.replace('_radio', '');
        const hiddenCheckbox = document.getElementById(originalNodeId);
        if (hiddenCheckbox && hiddenCheckbox.type === 'checkbox' && hiddenCheckbox.style.display === 'none') {
            hiddenCheckbox.remove();
        }
    });
    // Reset dropdowns (select elements) - set to placeholder/default option
    const selects = container.querySelectorAll('select');
    selects.forEach(select => {
        // Find the first disabled option (placeholder) or first option
        const placeholderOption = select.querySelector('option[disabled]');
        if (placeholderOption) {
            select.value = '';
            placeholderOption.selected = true;
        } else if (select.options.length > 0) {
            select.selectedIndex = 0;
        }
        // Also reset any hidden dropdown inputs
        const hiddenDropdownInput = document.getElementById(select.id + '_dropdown');
        if (hiddenDropdownInput) {
            hiddenDropdownInput.value = '';
        }
        // Clear hidden checkboxes created by dropdownMirror
        const dropdownWrapper = document.getElementById('dropdowntext_' + select.id);
        if (dropdownWrapper) {
            dropdownWrapper.innerHTML = '';
            // Re-add the hidden input if it was removed
            const existingHiddenInput = document.getElementById(select.id + '_dropdown');
            if (!existingHiddenInput) {
                const hiddenInput = document.createElement('input');
                hiddenInput.type = 'text';
                hiddenInput.id = select.id + '_dropdown';
                hiddenInput.name = select.id + '_dropdown';
                hiddenInput.style.display = 'none';
                dropdownWrapper.appendChild(hiddenInput);
            }
        }
    });
    // Reset state dropdowns (they have hidden short fields)
    const stateSelects = container.querySelectorAll('select.address-select-main');
    stateSelects.forEach(select => {
        const shortHiddenId = select.id.replace('_state_', '_state_short_');
        const shortHidden = document.getElementById(shortHiddenId);
        if (shortHidden) {
            shortHidden.value = '';
        }
    });
    // Clear all entries by directly clearing the container instead of calling showTextboxLabels
    // This avoids the isCreatingFields initialization issue
    const labelContainer = document.getElementById("labelContainer" + questionId);
    if (labelContainer) {
        labelContainer.innerHTML = '';
    }
    // Also update hidden checkboxes
    if (typeof updateHiddenCheckboxes === 'function') {
        updateHiddenCheckboxes(questionId, 0);
    }
    // Don't trigger change event - we've already cleared everything manually
}
// Generate hidden checkboxes for numbered dropdown questions
function generateHiddenCheckboxes(questionId, questionSafe, selectedCount) {
    // Get the dropdown element to find the range
    const dropdown = document.getElementById("answer" + questionId);
    if (!dropdown) return;
    // Find the maximum possible value from the dropdown options
    let maxRange = 0;
    for (let i = 0; i < dropdown.options.length; i++) {
        const optionValue = parseInt(dropdown.options[i].value);
        if (!isNaN(optionValue) && optionValue > maxRange) {
            maxRange = optionValue;
        }
    }
    // Remove any existing hidden checkboxes for this question
    const existingCheckboxes = document.querySelectorAll('input[type="checkbox"][id^="' + questionSafe + '_"]');
    existingCheckboxes.forEach(checkbox => checkbox.remove());
    // Generate hidden checkboxes for the full range
    for (let i = 1; i <= maxRange; i++) {
        const checkboxId = questionSafe + "_" + i;
        const checkboxName = questionSafe + "_" + i;
        // Create hidden checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = checkboxId;
        checkbox.name = checkboxName;
        checkbox.style.display = 'none'; // Hidden
        checkbox.checked = i <= selectedCount; // Check if this number is within the selected range
        // Add to the form (find the form element or add to body)
        const form = document.querySelector('form') || document.body;
        form.appendChild(checkbox);
    }
}
// Helper function to get fields in order for a question
function getFieldsInOrderForQuestion(questionId) {
    // Try to get unified fields first, fallback to old arrays
    const qBlock = document.querySelector('#question-container-' + questionId)?.closest('.question-block') || 
                   document.querySelector('[id*="' + questionId + '"]')?.closest('.question-block');
    let allFieldsInOrder = [];
    if (qBlock) {
        const unifiedFields = Array.from(qBlock.querySelectorAll('#unifiedFields' + questionId + ' .unified-field'));
        if (unifiedFields.length > 0) {
            // Use unified container data
            const allElements = [];
            unifiedFields.forEach((el) => {
                const fieldType = el.getAttribute('data-type');
                const fieldOrder = parseInt(el.getAttribute('data-order'));
                const labelTextEl = el.querySelector('#labelText' + questionId + '_' + fieldOrder);
                const nodeIdTextEl = el.querySelector('#nodeIdText' + questionId + '_' + fieldOrder);
                const prefillValue = el.getAttribute('data-prefill') || '';
                if (labelTextEl && nodeIdTextEl) {
                    const fieldData = {
                        type: fieldType,
                        label: labelTextEl.textContent.trim(),
                        nodeId: nodeIdTextEl.textContent.trim(),
                        order: fieldOrder
                    };
                    // Include prefill for label fields
                    if (fieldType === 'label') {
                        fieldData.prefill = prefillValue;
                    }
                    allElements.push(fieldData);
                }
            });
            // Sort by data-order attribute (creation order)
            allElements.sort((a, b) => a.order - b.order);
            allFieldsInOrder = allElements;
        }
    }
    // Fallback to unified fields map or old arrays if no unified fields found
    if (allFieldsInOrder.length === 0) {
        // Try unified fields map first
        if (window.unifiedFieldsMap && window.unifiedFieldsMap[questionId]) {
            allFieldsInOrder = window.unifiedFieldsMap[questionId];
        } else {
            // Fallback to old arrays
            const theseLabels = labelMap[questionId] || [];
            const theseAmounts = amountMap[questionId] || [];
            allFieldsInOrder = [
                ...theseLabels.map((lbl, index) => ({
                    type: 'label',
                    label: lbl,
                    nodeId: (window.labelNodeIdsMap && window.labelNodeIdsMap[questionId] ? window.labelNodeIdsMap[questionId] : [])[index] || "",
                    order: index
                })),
                ...theseAmounts.map((amt, index) => ({
                    type: 'amount',
                    label: amt,
                    nodeId: "",
                    order: index
                }))
            ];
        }
    }
    return allFieldsInOrder;
}
// Update hidden checkboxes when dropdown selection changes
function updateHiddenCheckboxes(questionId, selectedCount) {
    // Get the question's safe name
    const questionH3 = document
        .getElementById("question-container-" + questionId)
        ?.querySelector("h3")?.textContent || ("answer" + questionId);
    const qSafe = sanitizeQuestionText(questionH3);
    // Get the dropdown element to find the range
    const dropdown = document.getElementById("answer" + questionId);
    if (!dropdown) return;
    // Find the maximum possible value from the dropdown options
    let maxRange = 0;
    for (let i = 0; i < dropdown.options.length; i++) {
        const optionValue = parseInt(dropdown.options[i].value);
        if (!isNaN(optionValue) && optionValue > maxRange) {
            maxRange = optionValue;
        }
    }
    // Update existing checkboxes or create new ones if they don't exist
    for (let i = 1; i <= maxRange; i++) {
        const checkboxId = qSafe + "_" + i;
        let checkbox = document.getElementById(checkboxId);
        if (!checkbox) {
            // Create new checkbox if it doesn't exist
            checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = checkboxId;
            checkbox.name = qSafe + "_" + i;
            checkbox.style.display = 'none'; // Hidden
            // Add to the form
            const form = document.querySelector('form') || document.body;
            form.appendChild(checkbox);
        }
        // Update the checked state based on the selected count
        checkbox.checked = i <= selectedCount;
    }
    // Also update hidden address textboxes if this question has location fields
    const questionContainer = document.getElementById('question-container-' + questionId);
    if (questionContainer) {
        const allFieldsInOrder = getFieldsInOrderForQuestion(questionId);
        if (allFieldsInOrder && allFieldsInOrder.length > 0) {
            generateHiddenAddressTextboxes(questionId, selectedCount, allFieldsInOrder);
        }
    }
}
// Handle linked dropdown logic
function handleLinkedDropdowns(sourceName, selectedValue) {
    if (typeof linkedDropdowns === 'undefined' || !linkedDropdowns || linkedDropdowns.length === 0 || typeof isHandlingLink !== 'undefined' && isHandlingLink) return;
    try {
        isHandlingLink = true;  // Set flag before handling links
        linkedDropdowns.forEach(linkPair => {
            if (linkPair.sourceNameId === sourceName) {
                const targetDropdown = document.getElementById(linkPair.targetNameId);
                if (targetDropdown && targetDropdown.value !== selectedValue) {  // Only if value is different
                    let optionExists = false;
                    for (let i = 0; i < targetDropdown.options.length; i++) {
                        if (targetDropdown.options[i].value === selectedValue) {
                            optionExists = true;
                            targetDropdown.value = selectedValue;
                            // Trigger change event only if value actually changed
                            const event = new Event('change');
                            targetDropdown.dispatchEvent(event);
                            break;
                        }
                    }
                    if (!optionExists && selectedValue) {
                    }
                }
            }
            else if (linkPair.targetNameId === sourceName) {
                const sourceDropdown = document.getElementById(linkPair.sourceNameId);
                if (sourceDropdown && sourceDropdown.value !== selectedValue) {  // Only if value is different
                    let optionExists = false;
                    for (let i = 0; i < sourceDropdown.options.length; i++) {
                        if (sourceDropdown.options[i].value === selectedValue) {
                            optionExists = true;
                            sourceDropdown.value = selectedValue;
                            // Trigger change event only if value actually changed
                            const event = new Event('change');
                            sourceDropdown.dispatchEvent(event);
                            break;
                        }
                    }
                    if (!optionExists && selectedValue) {
                    }
                }
            }
        });
    } finally {
        isHandlingLink = false;  // Always reset flag when done
    }
}
/*â”€â”€â”€â”€â”€â”€â”€â”€ mirror a dropdown â†’ textbox and checkbox â”€â”€â”€â”€â”€â”€â”€â”€*/
function dropdownMirror(selectEl, baseName){
    const wrap = document.getElementById("dropdowntext_"+baseName);
    if(!wrap) {
        return;
    }
    const val = selectEl.value.trim();
    if(!val) {
        // When value is cleared, we need to dispatch events for any checkboxes that were removed
        const existingCheckboxes = wrap.querySelectorAll('input[type="checkbox"]');
        const removedCheckboxIds = [];
        existingCheckboxes.forEach(checkbox => {
            removedCheckboxIds.push(checkbox.id);
        });
        wrap.innerHTML = "";
        // Dispatch events for removed checkboxes so conditional logic can re-evaluate
        if (removedCheckboxIds.length > 0) {
            const lastUnderscoreIndex = baseName.lastIndexOf('_');
            if (lastUnderscoreIndex !== -1) {
                const potentialEntryNumber = baseName.substring(lastUnderscoreIndex + 1);
                if (/^[0-9]+$/.test(potentialEntryNumber)) {
                    const entryNumber = parseInt(potentialEntryNumber);
                    removedCheckboxIds.forEach(checkboxId => {
                        const triggerDropdownEvent = new CustomEvent('triggerDropdownChanged', {
                            detail: {
                                entryNumber: entryNumber,
                                checkboxId: checkboxId,
                                baseName: baseName,
                                removed: true
                            }
                        });
                        window.dispatchEvent(triggerDropdownEvent);
                    });
                }
            }
        }
        return;
    }
    const textId = baseName + "_dropdown";
    const textField = document.getElementById(textId);
    if(textField) {
        textField.value = val;
        textField.style.display = "none";
    }
    const existingCheckboxes = wrap.querySelectorAll("div");
    existingCheckboxes.forEach(div => div.remove());
    // Sanitize option value: replace all non-word characters (including spaces) with underscores
    // Use character class [^A-Za-z0-9_] instead of W to avoid backslash escaping issues in template literals
    const idSuffix = val.replace(/[^A-Za-z0-9_]+/g, "_").toLowerCase().replace(/^_+|_+$/g, '');
    // Check if baseName ends with an entry number (for numbered dropdowns or trigger sequence dropdowns)
    // Format should be: {questionNodeId}_{triggerTitle}_{fieldName}_optionValue_entryNumber (entry number last)
    // OR: fieldName_optionValue_entryNumber for numbered dropdowns
    const lastUnderscoreIndex = baseName.lastIndexOf('_');
    let checkboxId;
    if (lastUnderscoreIndex !== -1) {
        // Check if the part after last underscore is a number (entry number)
        // Use [0-9] instead of d to avoid backslash escaping issues when embedded in HTML
        const potentialEntryNumber = baseName.substring(lastUnderscoreIndex + 1);
        if (/^[0-9]+$/.test(potentialEntryNumber)) {
            // It's a numbered dropdown or trigger sequence dropdown
            const baseWithoutEntry = baseName.substring(0, lastUnderscoreIndex);
            const underscoreCount = (baseWithoutEntry.match(/_/g) || []).length;
            if (underscoreCount >= 1) {
                // This is likely a trigger sequence dropdown: {questionNodeId}_{dropdownFieldName}_{entryNumber}
                // We want: {questionNodeId}_{dropdownFieldName}_{optionValue}_{entryNumber}
                // So we just insert the option value before the entry number
                checkboxId = baseWithoutEntry + "_" + idSuffix + "_" + potentialEntryNumber;
            } else {
                // This is a numbered dropdown: fieldName_entryNumber -> fieldName_optionValue_entryNumber
                const fieldName = baseWithoutEntry;
                const entryNumber = potentialEntryNumber;
                checkboxId = fieldName + "_" + idSuffix + "_" + entryNumber;
            }
        } else {
            // Regular dropdown: keep original format
            checkboxId = baseName + "_" + idSuffix;
        }
    } else {
        // No underscore, keep original format
        checkboxId = baseName + "_" + idSuffix;
    }
    const checkboxDiv = document.createElement("div");
    checkboxDiv.style.display = "none";
    checkboxDiv.innerHTML = "<input type='checkbox' id='" + checkboxId + "' name='" + checkboxId + "' checked>" +
                     "<label for='" + checkboxId + "'> " + baseName + "_" + idSuffix + "</label>";
    wrap.appendChild(checkboxDiv);
    // Get the actual checkbox element that was just created
    const newCheckbox = document.getElementById(checkboxId);
    if (newCheckbox) {
        // Dispatch a change event on the newly created checkbox so conditional logic can react
        // Use setTimeout to ensure the checkbox is fully in the DOM
        setTimeout(() => {
            const changeEvent = new Event('change', { bubbles: true });
            newCheckbox.dispatchEvent(changeEvent);
            // Also dispatch a custom event for trigger dropdown changes
            // Extract entry number and question info from baseName if possible
            const lastUnderscoreIndex = baseName.lastIndexOf('_');
            if (lastUnderscoreIndex !== -1) {
                const potentialEntryNumber = baseName.substring(lastUnderscoreIndex + 1);
                if (/^[0-9]+$/.test(potentialEntryNumber)) {
                    // Try to extract questionId from the baseName or find it from the select element
                    const entryNumber = parseInt(potentialEntryNumber);
                    // Dispatch event that conditional logic can listen to
                    const triggerDropdownEvent = new CustomEvent('triggerDropdownChanged', {
                        detail: {
                            entryNumber: entryNumber,
                            checkboxId: checkboxId,
                            baseName: baseName
                        }
                    });
                    window.dispatchEvent(triggerDropdownEvent);
                }
            }
        }, 50);
        // Check if this checkbox is part of any linked checkbox configuration
        const linkedCheckboxesArray = (typeof linkedCheckboxes !== 'undefined' && linkedCheckboxes) ? linkedCheckboxes : [];
        if (linkedCheckboxesArray && linkedCheckboxesArray.length > 0) {
            linkedCheckboxesArray.forEach(linkedCheckboxGroup => {
                const checkboxIds = linkedCheckboxGroup.checkboxes || [];
                if (checkboxIds.includes(checkboxId)) {
                    // Attach event listeners to the newly created checkbox
                    const linkedCheckboxId = linkedCheckboxGroup.linkedCheckboxId;
                    newCheckbox.addEventListener('change', function() {
                        if (typeof window.updateAllLinkedCheckboxes === 'function') {
                            window.updateAllLinkedCheckboxes();
                        }
                    });
                }
            });
        }
        // Update all linked checkboxes after creating the new checkbox
        if (typeof window.updateAllLinkedCheckboxes === 'function') {
            // Use a longer delay to ensure DOM is fully updated
            setTimeout(() => {
                // Verify checkbox still exists before calling update
                const verifyCheckbox = document.getElementById(checkboxId);
                if (verifyCheckbox) {
                } else {
                }
                window.updateAllLinkedCheckboxes();
                // Also update inverse checkboxes after linked checkbox update
                if (typeof window.updateAllInverseCheckboxes === 'function') {
                    window.updateAllInverseCheckboxes();
                }
            }, 200);
        } else {
        }
    } else {
    }
    handleLinkedDropdowns(baseName, val);
}
// Function to handle hidden logic for dropdowns
function updateHiddenLogic(dropdownName, selectedValue) {
    // Find ALL hidden logic configurations for this dropdown
    const matchingConfigs = hiddenLogicConfigs.filter(c => c.questionNameId === dropdownName);
    if (matchingConfigs.length === 0) {
        return;
    }
    // Group configurations by nodeId to handle multiple triggers for the same element
    const configsByNodeId = {};
    matchingConfigs.forEach(config => {
        if (!configsByNodeId[config.nodeId]) {
            configsByNodeId[config.nodeId] = [];
        }
        configsByNodeId[config.nodeId].push(config);
    });
    // Process each nodeId
    Object.keys(configsByNodeId).forEach(nodeId => {
        const configsForNode = configsByNodeId[nodeId];
        // Check if ANY config for this nodeId matches the selected value
        const matchingConfig = configsForNode.find(config => config.trigger === selectedValue);
        if (matchingConfig) {
            // Check if the hidden element already exists
            let hiddenElement = document.getElementById(nodeId);
            if (!hiddenElement) {
                // Create the hidden element based on type
                if (matchingConfig.type === 'checkbox') {
                    hiddenElement = document.createElement('input');
                    hiddenElement.type = 'checkbox';
                    hiddenElement.id = nodeId;
                    hiddenElement.name = nodeId;
                    hiddenElement.checked = true;
                    hiddenElement.style.display = 'none';
                } else if (matchingConfig.type === 'textbox') {
                    hiddenElement = document.createElement('input');
                    hiddenElement.type = 'text';
                    hiddenElement.id = nodeId;
                    hiddenElement.name = nodeId;
                    hiddenElement.value = matchingConfig.textboxText || '';
                    hiddenElement.style.display = 'none';
                }
                // Add the hidden element to the form
                const form = document.getElementById('customForm');
                if (form) {
                    form.appendChild(hiddenElement);
                } else {
                    document.body.appendChild(hiddenElement);
                }
            } else {
                // Update existing element
                if (matchingConfig.type === 'checkbox') {
                    hiddenElement.checked = true;
                } else if (matchingConfig.type === 'textbox') {
                    hiddenElement.value = matchingConfig.textboxText || '';
                }
            }
        } else {
            // No matching config found, uncheck/clear the existing element
            const existingElement = document.getElementById(nodeId);
            if (existingElement) {
                if (configsForNode[0].type === 'checkbox') {
                    existingElement.checked = false;
                } else if (configsForNode[0].type === 'textbox') {
                    existingElement.value = '';
                }
            }
        }
    }); // End of forEach loop for nodeIds
}
// Function to show/hide questions based on conditional logic
function updateQuestionVisibility(questionId, shouldShow) {
    const questionContainer = document.getElementById('question-container-' + questionId);
    if (questionContainer) {
        if (shouldShow) {
            questionContainer.classList.remove('hidden');
        } else {
            questionContainer.classList.add('hidden');
        }
    } else {
    }
}
// Function to handle business type selection and show county question
function handleBusinessTypeSelection() {
    // Show the county question (question-container-16) when any business type is selected
    updateQuestionVisibility(16, true);
}
// Function to handle linked fields synchronization
function updateLinkedFields() {
    if (!linkedFields || linkedFields.length === 0) return;
    linkedFields.forEach(linkedField => {
        const { linkedFieldId, fields } = linkedField;
        // Find the hidden textbox for this linked field
        let hiddenField = document.getElementById(linkedFieldId);
        if (!hiddenField) {
            // Create the hidden textbox if it doesn't exist
            hiddenField = document.createElement('input');
            hiddenField.type = 'text';
            hiddenField.id = linkedFieldId;
            hiddenField.name = linkedFieldId;
            hiddenField.style.display = 'none';
            // Append to the form instead of document.body so it gets submitted
            const form = document.getElementById('customForm');
            if (form) {
                form.appendChild(hiddenField);
            } else {
                document.body.appendChild(hiddenField);
            }
        }
        // Get all the linked textboxes (filter out null/undefined - textboxes that have been removed)
        const linkedTextboxes = fields.map(fieldId => document.getElementById(fieldId)).filter(el => el);
        // If no linked textboxes exist (all have been removed), clear the hidden field
        if (linkedTextboxes.length === 0) {
            hiddenField.value = '';
            return;
        }
        // Find which textbox has content
        const textboxesWithContent = linkedTextboxes.filter(tb => tb.value.trim() !== '');
        if (textboxesWithContent.length === 0) {
            // No textboxes have content, clear the hidden field
            hiddenField.value = '';
        } else if (textboxesWithContent.length === 1) {
            // Only one textbox has content, use its value
            const val = textboxesWithContent[0].value.trim();
            hiddenField.value = (textboxesWithContent[0].type === 'date') ? formatDateForServer(val) : val;
        } else {
            // Multiple textboxes have content
            const allAreDates = textboxesWithContent.every(tb => tb.type === 'date' || /^d{2}[-/]d{2}[-/]d{4}$/.test(tb.value.trim()) || /^d{4}-d{2}-d{2}$/.test(tb.value.trim()));
            if (allAreDates) {
                // Choose the latest date
                const parseDate = (val) => {
                    const trimmed = val.trim();
                    // If yyyy-mm-dd, convert to mm-dd-yyyy for comparison consistency
                    const normalized = /^d{4}-d{2}-d{2}$/.test(trimmed) ? formatDateForServer(trimmed) : trimmed;
                    const parts = normalized.split(/[-/]/);
                    if (parts.length === 3) {
                        return new Date(parts[2], parseInt(parts[0],10)-1, parseInt(parts[1],10));
                    }
                    return null;
                };
                let latest = textboxesWithContent[0];
                let latestDate = parseDate(latest.value);
                textboxesWithContent.slice(1).forEach(tb => {
                    const d = parseDate(tb.value);
                    if (d && (!latestDate || d > latestDate)) {
                        latest = tb;
                        latestDate = d;
                    }
                });
                const chosenVal = latest.value.trim();
                hiddenField.value = latest.type === 'date'
                    ? formatDateForServer(chosenVal)
                    : (/^d{4}-d{2}-d{2}$/.test(chosenVal) ? formatDateForServer(chosenVal) : chosenVal);
            } else {
                // Fall back to longest text
                const longestTextbox = textboxesWithContent.reduce((longest, current) => 
                    current.value.length > longest.value.length ? current : longest
                );
                hiddenField.value = longestTextbox.value.trim();
            }
        }
    });
}
// Function to clear inactive linked textboxes (with delay to avoid interfering with typing)
function clearInactiveLinkedFields() {
    if (!linkedFields || linkedFields.length === 0) return;
    // Use setTimeout to avoid interfering with user typing
    setTimeout(() => {
        linkedFields.forEach(linkedField => {
            const { fields } = linkedField;
            // Get all the linked textboxes
            const linkedTextboxes = fields.map(fieldId => document.getElementById(fieldId)).filter(el => el);
            if (linkedTextboxes.length === 0) return;
            // Find which textboxes are currently visible (not hidden by conditional logic)
            const visibleTextboxes = linkedTextboxes.filter(tb => {
                const container = tb.closest('.question-container');
                return container && !container.classList.contains('hidden');
            });
            // Find which textboxes have content
            const textboxesWithContent = linkedTextboxes.filter(tb => tb.value.trim() !== '');
            // Clear all hidden textboxes that have content
            linkedTextboxes.forEach(tb => {
                const container = tb.closest('.question-container');
                if (container && container.classList.contains('hidden') && tb.value.trim() !== '') {
                    tb.value = '';
                }
            });
            // If multiple visible textboxes have content, keep only the longest one
            const visibleTextboxesWithContent = visibleTextboxes.filter(tb => tb.value.trim() !== '');
            if (visibleTextboxesWithContent.length > 1) {
                const longestTextbox = visibleTextboxesWithContent.reduce((longest, current) => 
                    current.value.length > longest.value.length ? current : longest
                );
                // Clear all other visible textboxes that aren't the longest
                visibleTextboxes.forEach(tb => {
                    if (tb !== longestTextbox && tb.value.trim() !== '') {
                        tb.value = '';
                    }
                });
            }
        });
    }, 100); // 100ms delay to avoid interfering with typing
}
// Function to set up linked fields event listeners
function setupLinkedFields() {
    if (!linkedFields || linkedFields.length === 0) return;
    // Use event delegation to handle dynamically created textboxes
    document.addEventListener('input', function(event) {
        if (event.target.tagName === 'INPUT' && event.target.type === 'text') {
            // Check if this input is part of any linked field
            const fieldId = event.target.id;
            const isLinkedField = linkedFields.some(linkedField => 
                linkedField.fields.includes(fieldId)
            );
            if (isLinkedField) {
                updateLinkedFields();
            }
        }
    });
    document.addEventListener('change', function(event) {
        if (event.target.tagName === 'INPUT' && event.target.type === 'text') {
            // Check if this input is part of any linked field
            const fieldId = event.target.id;
            const isLinkedField = linkedFields.some(linkedField => 
                linkedField.fields.includes(fieldId)
            );
            if (isLinkedField) {
                updateLinkedFields();
            }
        }
    });
    // Initial update
    updateLinkedFields();
}
function getQuestionInputs (questionId, type = null) {
  /* 1ï¸âƒ£ First look inside the question container, if it exists */
  const container = document.getElementById('question-container-' + questionId);
  if (container) {
    return container.querySelectorAll(
      type ? 'input[type="' + type + '"]' : 'input, select, textarea'
    );
  }
  /* 2ï¸âƒ£ Fallback to the old prefixâ€‘style that your generator sometimes uses */
  const prefix = 'input[id^="' + getCbPrefix(questionId) + '"]';
  return document.querySelectorAll(
    type ? prefix + '[type="' + type + '"]' : prefix + ', select[id^="answer' + questionId + '"]'
  );
}
/*------------------------------------------------------------------
 *  handleNext(currentSection)
 *  â€“ pushes the section you are leaving and works out where to go
 *-----------------------------------------------------------------*/
function handleNext(currentSection){
    runAllHiddenCheckboxCalculations();
    runAllHiddenTextCalculations();
    /* remember the place we're leaving - push BEFORE evaluating jumps */
    sectionStack.push(currentSection);
    let nextSection = currentSection + 1;
    /* ---------- evaluate jump rules ---------- */
    const relevantJumps = jumpLogics.filter(jl => jl.section === currentSection);
    let jumpDetected = false;
    for (const jl of relevantJumps){
        const nmId = questionNameIds[jl.questionId] || ('answer'+jl.questionId);
        if (['radio','dropdown','numberedDropdown'].includes(jl.questionType)){
            const el = document.getElementById(nmId);
            if (el && el.value.trim().toLowerCase() === jl.jumpOption.trim().toLowerCase()){
                nextSection = jl.jumpTo.toLowerCase();
                jumpDetected = true;
                break;
            }
        } else if (jl.questionType === 'checkbox'){
            const cbs = getQuestionInputs(jl.questionId, 'checkbox');
            const chosen = Array.from(cbs).filter(cb=>cb.checked)
                                .map(cb=>cb.value.trim().toLowerCase());
            if (chosen.includes(jl.jumpOption.trim().toLowerCase())){
                nextSection = jl.jumpTo.toLowerCase();
                jumpDetected = true;
                break;
            }
        }
    }
    /* ---------- special "end" shortcut ---------- */
    if (nextSection === 'end'){
        processAllPdfs().then(()=>navigateSection('end'));
        return;
    }
    nextSection = parseInt(nextSection,10);
    if (isNaN(nextSection)) nextSection = currentSection + 1;
    navigateSection(nextSection);
    /* recalc hidden fields after navigation */
    runAllHiddenCheckboxCalculations();
    runAllHiddenTextCalculations();
}
/*------------------------------------------------------------------
 *  resetHiddenQuestionsToDefaults(sectionNumber)
 *  â€“ resets hidden questions in the current section to their default values
 *    This prevents Firebase autosave from keeping values for questions
 *    that are hidden due to conditional logic
 *-----------------------------------------------------------------*/
function resetHiddenQuestionsToDefaults(sectionNumber) {
    // Get the current section
    const currentSection = document.getElementById('section' + sectionNumber);
    if (!currentSection) {
        return;
    }
    // Find all hidden question containers in this section
    const hiddenQuestions = currentSection.querySelectorAll('.question-container.hidden');
    if (hiddenQuestions.length === 0) {
        return;
    }
    hiddenQuestions.forEach((questionContainer, index) => {
        // Get all form elements within this hidden question
        const formElements = questionContainer.querySelectorAll('input, select, textarea');
        formElements.forEach(element => {
            const elementName = element.name || element.id || 'unnamed';
            const oldValue = element.value || element.checked;
            if (element.tagName === 'SELECT') {
                // Reset dropdown to default "Select an option"
                element.value = '';
                // Find the default option and set it as selected
                const defaultOption = element.querySelector('option[disabled][selected]');
                if (defaultOption) {
                    defaultOption.selected = true;
                }
            } else if (element.type === 'checkbox' || element.type === 'radio') {
                // Reset checkboxes and radio buttons to unchecked
                element.checked = false;
            } else if (element.type === 'text' || element.type === 'email' || element.type === 'tel' || 
                      element.type === 'number' || element.type === 'date' || element.tagName === 'TEXTAREA') {
                // Reset text inputs to empty
                element.value = '';
            }
        });
    });
}
/*------------------------------------------------------------------
 *  navigateSection(sectionNumber)
 *  â€“ shows exactly one section (or Thankâ€‘you) and records history
 *-----------------------------------------------------------------*/
function navigateSection(sectionNumber, isBackNavigation = false){
    const sections  = document.querySelectorAll('.section');
    const form      = document.getElementById('customForm');
    const thankYou  = document.getElementById('thankYouMessage');
    /* hide everything first */
    sections.forEach(sec => sec.classList.remove('active'));
    thankYou.style.display = 'none';
    form.style.display     = 'block';
    if (sectionNumber === 'end'){
        form.style.display   = 'none';
        thankYou.style.display = 'block';
        currentSectionNumber = 'end';
        updateProgressBar();
        return;
    }
    /* â”€â”€ corrected bounds check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const maxSection = sections.length;   // 1â€‘based section numbers
    if (sectionNumber < 1)           sectionNumber = 1;
    if (sectionNumber > maxSection)  sectionNumber = maxSection;
    /* show the requested section */
    const target = document.getElementById('section' + sectionNumber);
    (target || sections[maxSection - 1]).classList.add('active');
    // Update currentSectionNumber
    const previousSectionNumber = currentSectionNumber;
    currentSectionNumber = sectionNumber;
    // Reset hidden questions to default values after Firebase autosave
    // BUT NOT during initial autofill to preserve autofilled values
    if (!window.isInitialAutofill) {
    resetHiddenQuestionsToDefaults(sectionNumber);
    }
    updateProgressBar();
}
/*------------------------------------------------------------------
 *  goBack()
 *  â€“ pops the history stack; falls back to numeric âˆ’1 if empty
 *-----------------------------------------------------------------*/
function goBack(){
    if (sectionStack.length > 0){
        const prev = sectionStack.pop();
        // Ensure prev is a number, not a string
        const prevSection = typeof prev === 'string' ? parseInt(prev, 10) : prev;
        if (!isNaN(prevSection) && prevSection >= 1) {
            navigateSection(prevSection, true);
        } else {
            if (typeof currentSectionNumber === 'number' && currentSectionNumber > 1){
                // Fallback only if stack value is invalid
                navigateSection(currentSectionNumber - 1, true);
            }
        }
    }else {
        if (typeof currentSectionNumber === 'number' && currentSectionNumber > 1){
            navigateSection(currentSectionNumber - 1, true);
        } else {
        }
    }
    updateProgressBar();
}
/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function setCurrentDate () {
    const t = new Date();
    const month = String(t.getMonth() + 1).padStart(2, '0');
    const day = String(t.getDate()).padStart(2, '0');
    const year = t.getFullYear();
    const currentDateElement = document.getElementById('current_date');
    if (currentDateElement) {
        // Format as mm-dd-yyyy for server
        currentDateElement.value = month + '-' + day + '-' + year;
        // Mark this field as protected from autofill
        currentDateElement.setAttribute('data-protected', 'true');
    }
}
// Helper function to format date from yyyy-mm-dd to mm-dd-yyyy
function formatDateForServer(dateString) {
    if (!dateString) return '';
    const parts = dateString.split('-');
    if (parts.length === 3) {
        return parts[1] + '-' + parts[2] + '-' + parts[0];
    }
    return dateString;
}
// Helper for displaying dates in the debug menu (yyyy-mm-dd â†’ mm-dd-yyyy)
function formatDateForDisplay(dateString) {
    const parts = (dateString || '').split('-');
    if (parts.length === 3 && parts[0].length === 4) {
        // Avoid template literal to prevent parsing issues in generated output
        return parts[1] + '-' + parts[2] + '-' + parts[0];
    }
    return dateString;
}
window.onload=function(){
    setCurrentDate();
    attachCalculationListeners();
    // Trigger visibility updates on page load to show dependent questions
    setTimeout(() => {
        if (typeof triggerVisibilityUpdates === 'function') {
            triggerVisibilityUpdates();
        }
    }, 200);
};
function handleConditionalAlerts(){
    for(var i=0; i<conditionalAlerts.length; i++){
        var obj = conditionalAlerts[i];
        var prevQEl= document.getElementById("answer"+obj.prevQuestionId);
        if(prevQEl){
            if(prevQEl.value.trim().toLowerCase() === obj.prevAnswer.trim().toLowerCase()){
                alert(obj.alertText);
            }
        } else {
            var cbs= document.querySelectorAll('[name^="answer'+obj.prevQuestionId+'_"]');
            for(var x=0; x<cbs.length; x++){
                if(cbs[x].checked && cbs[x].value.trim().toLowerCase()=== obj.prevAnswer.trim().toLowerCase()){
                    alert(obj.alertText);
                }
            }
        }
    }
}
/*â”€â”€â”€â”€ main submit handler â”€â”€â”€â”€*/
function showThankYouMessage (event) {
    // Safely prevent default if an event was provided
    if (event && typeof event.preventDefault === 'function') {
        event.preventDefault();
    }
    // Check authentication before submitting form
    if (typeof isUserLoggedIn === 'undefined' || !isUserLoggedIn) {
        if (typeof showSignInRequiredModal === 'function') {
            showSignInRequiredModal();
        }
        return false;
    }
    // Show thank you message immediately (no PDF processing)
    document.getElementById('customForm').style.display = 'none';
    document.getElementById('thankYouMessage').style.display = 'block';
    // Display checklist if there are items
    const checklistDisplay = document.getElementById('checklistDisplay');
    const checklistItemsContainer = document.getElementById('checklistItems');
    // Combine static and dynamic checklist items
    const allChecklistItems = [...(checklistItems || []), ...(userChecklist || [])];
    if (checklistDisplay && checklistItemsContainer && allChecklistItems.length > 0) {
        checklistDisplay.style.display = 'block';
        // Create checklist items HTML
        let checklistHTML = '';
        allChecklistItems.forEach((item, index) => {
            checklistHTML += '<div style="margin: 8px 0; padding: 10px; background: white; border-radius: 8px; border-left: 4px solid #2980b9; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">' +
                '<input type="checkbox" id="checklistItem' + index + '" style="margin-right: 10px;">' +
                '<label for="checklistItem' + index + '" style="color: #2c3e50; font-weight: 500; cursor: pointer;">' + item + '</label>' +
            '</div>';
        });
        checklistItemsContainer.innerHTML = checklistHTML;
    }
    return false;                       // prevent page reload
}
// Form submission is now handled by the inline onsubmit attribute
/*â”€â”€â”€â”€ process all PDFs sequentially â”€â”€â”€â”€*/
async function processAllPdfs() {
    // Track processed PDFs to prevent duplicates
    const processedPdfs = new Set();
    // Process main PDFs - use the actual PDF filename, not the form name
    if (pdfOutputFileName) {
        // Remove .pdf extension if present since server adds it automatically
        const baseName = pdfOutputFileName.replace(/.pdf$/i, '');
        if (!processedPdfs.has(baseName)) {
            processedPdfs.add(baseName);
        await editAndDownloadPDF(baseName);
        } else {
        }
    }
    // Process Conditional PDFs
    if (conditionalPDFs && conditionalPDFs.length > 0) {
        for (const conditionalPDF of conditionalPDFs) {
            if (conditionalPDF.pdfName) {
                // Check if conditions are met
                let shouldDownload = false;
                // Get the question element
                const questionElement = document.getElementById(questionNameIds[conditionalPDF.questionId]) || 
                                      document.getElementById('answer' + conditionalPDF.questionId);
                if (questionElement) {
                    let questionValue = '';
                    if (questionElement.type === 'checkbox') {
                        questionValue = questionElement.checked ? questionElement.value : '';
                    } else {
                        questionValue = questionElement.value;
                    }
                    // Check if the condition matches
                    if (questionValue.toString().toLowerCase() === conditionalPDF.conditionalAnswer.toLowerCase()) {
                        shouldDownload = true;
                    }
                }
                // Download PDF if conditions are met
                if (shouldDownload) {
                    const baseName = conditionalPDF.pdfName.replace(/.pdf$/i, '');
                    if (!processedPdfs.has(baseName)) {
                        processedPdfs.add(baseName);
                        await editAndDownloadPDF(baseName);
                    } else {
                    }
                }
            }
        }
    }
    // Process PDF Logic PDFs
    if (pdfLogicPDFs && pdfLogicPDFs.length > 0) {
        for (const pdfLogic of pdfLogicPDFs) {
            if (pdfLogic.pdfName) {
                // Check if conditions are met
                let shouldDownload = false;
                if (pdfLogic.isBigParagraph) {
                    // For Big Paragraph questions, check character limit
                    pdfLogic.conditions.forEach(condition => {
                        if (condition.characterLimit) {
                            // Get the Big Paragraph question's value
                            const questionElement = document.getElementById(questionNameIds[pdfLogic.questionId]) || 
                                                  document.getElementById('answer' + pdfLogic.questionId);
                            if (questionElement) {
                                const questionValue = questionElement.value || '';
                                // Check if the text length exceeds the character limit
                                if (questionValue.length > condition.characterLimit) {
                                    shouldDownload = true;
                                }
                            }
                        }
                    });
                } else {
                    // For other question types, check previous question conditions
                // First check if this is a numbered dropdown with trigger option
                if (pdfLogic.triggerOption) {
                    // For numbered dropdown with trigger option, check if the selected value matches the trigger
                    const questionElement = document.getElementById(questionNameIds[pdfLogic.questionId]) || 
                                          document.getElementById('answer' + pdfLogic.questionId);
                    if (questionElement) {
                        const selectedValue = questionElement.value;
                        // Check if the selected value matches the trigger option
                        if (selectedValue === pdfLogic.triggerOption) {
                            shouldDownload = true;
                        } else {
                        }
                    } else {
                    }
                } else if (pdfLogic.numberTrigger && pdfLogic.numberValue) {
                    // For number questions with trigger conditions, check if the number meets the condition
                    const questionElement = document.getElementById(questionNameIds[pdfLogic.questionId]) || 
                                          document.getElementById('answer' + pdfLogic.questionId);
                    if (questionElement) {
                        const selectedValue = parseFloat(questionElement.value) || 0;
                        const triggerValue = parseFloat(pdfLogic.numberValue) || 0;
                        let conditionMet = false;
                        if (pdfLogic.numberTrigger === '=') {
                            conditionMet = selectedValue === triggerValue;
                        } else if (pdfLogic.numberTrigger === '>') {
                            conditionMet = selectedValue > triggerValue;
                        } else if (pdfLogic.numberTrigger === '<') {
                            conditionMet = selectedValue < triggerValue;
                        }
                        if (conditionMet) {
                            shouldDownload = true;
                        } else {
                        }
                    } else {
                    }
                } else if (pdfLogic.isTriggerSequencePdf) {
                    // For trigger sequence PDFs, check if the trigger sequence condition is met for the specific entry

                    // First, check that the numbered dropdown has a value (entries exist)
                    const numberedDropdownEl = document.getElementById(questionNameIds[pdfLogic.questionId]) || 
                                                document.getElementById('answer' + pdfLogic.questionId);

                    if (numberedDropdownEl && numberedDropdownEl.value) {
                        const entryCount = parseInt(numberedDropdownEl.value) || 0;
                        const targetEntryNumber = parseInt(pdfLogic.pdfEntryNumber) || 1;

                        // Check if target entry exists
                        if (targetEntryNumber <= entryCount) {
                            // Find the trigger sequence dropdown for this entry (uses character classes to avoid backslash escaping issues)
                            const sanitizedFieldName = String(pdfLogic.triggerSequenceFieldName || 'dropdown')
                                .toLowerCase()
                                .replace(/[?]/g, '')  // Remove question marks
                                .replace(/[^a-z0-9_]+/g, '_')  // Replace non-word characters with underscore
                                .replace(/^_+|_+$/g, '');  // Remove leading/trailing underscores
                            const triggerDropdownId = sanitizedFieldName + '_' + targetEntryNumber;

                            const triggerDropdownEl = document.getElementById(triggerDropdownId);

                            if (triggerDropdownEl) {
                                const selectedValue = triggerDropdownEl.value || '';

                                if (selectedValue === pdfLogic.triggerSequenceCondition) {

                                    shouldDownload = true;
                                } else {

                                }
                            } else {

                            }
                        } else {

                        }
                    } else {

                    }
                } else {
                        // For regular conditions, check previous question logic
                pdfLogic.conditions.forEach(condition => {
                    const prevQuestionId = condition.prevQuestion;
                    const prevAnswer = condition.prevAnswer;
                    // Get the previous question's value
                    const prevQuestionElement = document.getElementById(questionNameIds[prevQuestionId]) || 
                                              document.getElementById('answer' + prevQuestionId);
                    if (prevQuestionElement) {
                        let prevValue = '';
                        if (prevQuestionElement.type === 'checkbox') {
                            prevValue = prevQuestionElement.checked ? prevQuestionElement.value : '';
                        } else {
                            prevValue = prevQuestionElement.value;
                        }
                        // Handle wildcard condition (*) - means any value is fine
                        if (prevAnswer === '*' && prevValue !== '') {
                            shouldDownload = true;
                        } else if (prevValue.toString().toLowerCase() === prevAnswer.toLowerCase()) {
                            shouldDownload = true;
                        }
                    }
                });
                    }
                }
                // Download PDF if conditions are met
                if (shouldDownload) {
                    const baseName = pdfLogic.pdfName.replace(/.pdf$/i, '');
                    if (!processedPdfs.has(baseName)) {
                        processedPdfs.add(baseName);
                        await editAndDownloadPDF(baseName);
                    } else {
                    }
                }
            }
        }
    }
    // Process Checkbox PDF Entries
    // These PDFs are already "approved" since the checkbox is checked, so download them directly
    if (window.checkboxPdfEntries && window.checkboxPdfEntries.length > 0) {
        for (const pdfEntry of window.checkboxPdfEntries) {
            if (pdfEntry.pdfFile) {
                // Remove .pdf extension if present since server adds it automatically
                const baseName = pdfEntry.pdfFile.replace(/.pdf$/i, '');
                if (!processedPdfs.has(baseName)) {
                    processedPdfs.add(baseName);
                    await editAndDownloadPDF(baseName);
                } else {
                }
            }
        }
    } else {
    }
    // Process Uploaded File PDFs
    if (window.uploadedFiles && typeof window.uploadedFiles === 'object' && window.fileUploadQuestions && Array.isArray(window.fileUploadQuestions)) {
        for (const fileUploadQ of window.fileUploadQuestions) {
            const uploadedFile = window.uploadedFiles[fileUploadQ.questionId];
            if (uploadedFile && uploadedFile.type === 'application/pdf') {
                // Use fileTitle as the base name for the PDF
                const baseName = fileUploadQ.fileTitle || ('uploaded_' + fileUploadQ.questionId);
                if (!processedPdfs.has(baseName)) {
                    processedPdfs.add(baseName);
                    // Download the uploaded file directly (it's already a PDF, no server processing needed)
                    const url = URL.createObjectURL(uploadedFile);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = (fileUploadQ.fileTitle.endsWith('.pdf') ? fileUploadQ.fileTitle : (fileUploadQ.fileTitle + '.pdf'));
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    // Small delay to prevent browser from blocking multiple downloads
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
        }
    }

    // Process LaTeX Preview PDFs (if "Attach to packet" is selected)
    if (window.latexPdfs && typeof window.latexPdfs === 'object' && window.latexPreviewQuestions && Array.isArray(window.latexPreviewQuestions)) {
        for (const latexPreviewQ of window.latexPreviewQuestions) {
            const latexPdf = window.latexPdfs[latexPreviewQ.questionId];
            if (latexPdf && latexPdf instanceof Blob) {
                // Use title as the base name for the PDF
                const baseName = latexPreviewQ.title || ('latex_preview_' + latexPreviewQ.questionId);
                if (!processedPdfs.has(baseName)) {
                    processedPdfs.add(baseName);
                    // Download the LaTeX PDF directly (it's already a PDF blob)
                    const url = URL.createObjectURL(latexPdf);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = (latexPreviewQ.title.endsWith('.pdf') ? latexPreviewQ.title : (latexPreviewQ.title + '.pdf'));
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    // Small delay to prevent browser from blocking multiple downloads
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
        }
    }
}
// Function to collect all PDFs that would be downloaded (for preview)
async function getAllPdfsList() {
    const pdfsList = [];
    const processedPdfs = new Set();

    // Process main PDF
    if (pdfOutputFileName) {
        const baseName = pdfOutputFileName.replace(/.pdf$/i, '');
        if (!processedPdfs.has(baseName)) {
            processedPdfs.add(baseName);
            pdfsList.push({
                baseName: baseName,
                displayName: pdfOutputFileName.replace(/.pdf$/i, ''),
                type: 'main'
            });
        }
    }

    // Process Conditional PDFs
    if (conditionalPDFs && conditionalPDFs.length > 0) {
        for (const conditionalPDF of conditionalPDFs) {
            if (conditionalPDF.pdfName) {
                let shouldInclude = false;
                const questionElement = document.getElementById(questionNameIds[conditionalPDF.questionId]) || 
                                      document.getElementById('answer' + conditionalPDF.questionId);
                if (questionElement) {
                    let questionValue = '';
                    if (questionElement.type === 'checkbox') {
                        questionValue = questionElement.checked ? questionElement.value : '';
                    } else {
                        questionValue = questionElement.value;
                    }
                    if (questionValue.toString().toLowerCase() === conditionalPDF.conditionalAnswer.toLowerCase()) {
                        shouldInclude = true;
                    }
                }
                if (shouldInclude) {
                    const baseName = conditionalPDF.pdfName.replace(/.pdf$/i, '');
                    if (!processedPdfs.has(baseName)) {
                        processedPdfs.add(baseName);
                        pdfsList.push({
                            baseName: baseName,
                            displayName: conditionalPDF.pdfName.replace(/.pdf$/i, ''),
                            type: 'conditional'
                        });
                    }
                }
            }
        }
    }

    // Process PDF Logic PDFs
    if (pdfLogicPDFs && pdfLogicPDFs.length > 0) {
        for (const pdfLogic of pdfLogicPDFs) {
            if (pdfLogic.pdfName) {
                let shouldInclude = false;
                if (pdfLogic.isBigParagraph) {
                    pdfLogic.conditions.forEach(condition => {
                        if (condition.characterLimit) {
                            const questionElement = document.getElementById(questionNameIds[pdfLogic.questionId]) || 
                                                  document.getElementById('answer' + pdfLogic.questionId);
                            if (questionElement) {
                                const questionValue = questionElement.value || '';
                                if (questionValue.length > condition.characterLimit) {
                                    shouldInclude = true;
                                }
                            }
                        }
                    });
                } else {
                    if (pdfLogic.triggerOption) {
                        const questionElement = document.getElementById(questionNameIds[pdfLogic.questionId]) || 
                                              document.getElementById('answer' + pdfLogic.questionId);
                        if (questionElement) {
                            const selectedValue = questionElement.value;
                            if (selectedValue === pdfLogic.triggerOption) {
                                shouldInclude = true;
                            }
                        }
                    } else if (pdfLogic.numberTrigger && pdfLogic.numberValue) {
                        const questionElement = document.getElementById(questionNameIds[pdfLogic.questionId]) || 
                                              document.getElementById('answer' + pdfLogic.questionId);
                        if (questionElement) {
                            const selectedValue = parseFloat(questionElement.value) || 0;
                            const triggerValue = parseFloat(pdfLogic.numberValue) || 0;
                            let conditionMet = false;
                            if (pdfLogic.numberTrigger === '=') {
                                conditionMet = selectedValue === triggerValue;
                            } else if (pdfLogic.numberTrigger === '>') {
                                conditionMet = selectedValue > triggerValue;
                            } else if (pdfLogic.numberTrigger === '<') {
                                conditionMet = selectedValue < triggerValue;
                            }
                            if (conditionMet) {
                                shouldInclude = true;
                            }
                        }
                    } else if (pdfLogic.isTriggerSequencePdf) {

                        const numberedDropdownEl = document.getElementById(questionNameIds[pdfLogic.questionId]) || 
                                                    document.getElementById('answer' + pdfLogic.questionId);

                        if (numberedDropdownEl && numberedDropdownEl.value) {
                            const entryCount = parseInt(numberedDropdownEl.value) || 0;
                            const targetEntryNumber = parseInt(pdfLogic.pdfEntryNumber) || 1;

                            if (targetEntryNumber <= entryCount) {
                                // Uses character classes to avoid backslash escaping issues
                                const sanitizedFieldName = String(pdfLogic.triggerSequenceFieldName || 'dropdown')
                                    .toLowerCase()
                                    .replace(/[?]/g, '')  // Remove question marks
                                    .replace(/[^a-z0-9_]+/g, '_')  // Replace non-word characters with underscore
                                    .replace(/^_+|_+$/g, '');  // Remove leading/trailing underscores
                                const triggerDropdownId = sanitizedFieldName + '_' + targetEntryNumber;

                                const triggerDropdownEl = document.getElementById(triggerDropdownId);

                                if (triggerDropdownEl) {
                                    const selectedValue = triggerDropdownEl.value || '';

                                    if (selectedValue === pdfLogic.triggerSequenceCondition) {

                                        shouldInclude = true;
                                    } else {

                                    }
                                } else {

                                }
                            } else {

                            }
                        } else {

                        }
                    } else {
                        pdfLogic.conditions.forEach(condition => {
                            const prevQuestionId = condition.prevQuestion;
                            const prevAnswer = condition.prevAnswer;
                            const prevQuestionElement = document.getElementById(questionNameIds[prevQuestionId]) || 
                                                      document.getElementById('answer' + prevQuestionId);
                            if (prevQuestionElement) {
                                let prevValue = '';
                                if (prevQuestionElement.type === 'checkbox') {
                                    prevValue = prevQuestionElement.checked ? prevQuestionElement.value : '';
                                } else {
                                    prevValue = prevQuestionElement.value;
                                }
                                if (prevAnswer === '*' && prevValue !== '') {
                                    shouldInclude = true;
                                } else if (prevValue.toString().toLowerCase() === prevAnswer.toLowerCase()) {
                                    shouldInclude = true;
                                }
                            }
                        });
                    }
                }
                if (shouldInclude) {
                    const baseName = pdfLogic.pdfName.replace(/.pdf$/i, '');
                    if (!processedPdfs.has(baseName)) {
                        processedPdfs.add(baseName);
                        pdfsList.push({
                            baseName: baseName,
                            displayName: pdfLogic.pdfDisplayName || pdfLogic.pdfName.replace(/.pdf$/i, ''),
                            type: 'pdfLogic'
                        });
                    }
                }
            }
        }
    }

    // Process Checkbox PDF Entries
    if (window.checkboxPdfEntries && window.checkboxPdfEntries.length > 0) {
        for (const pdfEntry of window.checkboxPdfEntries) {
            if (pdfEntry.pdfFile) {
                const baseName = pdfEntry.pdfFile.replace(/.pdf$/i, '');
                if (!processedPdfs.has(baseName)) {
                    processedPdfs.add(baseName);
                    pdfsList.push({
                        baseName: baseName,
                        displayName: pdfEntry.pdfName || pdfEntry.pdfFile.replace(/.pdf$/i, ''),
                        type: 'checkbox'
                    });
                }
            }
        }
    }

    // Process Uploaded File PDFs
    if (window.uploadedFiles && typeof window.uploadedFiles === 'object' && window.fileUploadQuestions && Array.isArray(window.fileUploadQuestions)) {
        for (const fileUploadQ of window.fileUploadQuestions) {
            const uploadedFile = window.uploadedFiles[fileUploadQ.questionId];
            if (uploadedFile && uploadedFile.type === 'application/pdf') {
                // Use fileTitle as the base name for the PDF
                const baseName = fileUploadQ.fileTitle || ('uploaded_' + fileUploadQ.questionId);
                if (!processedPdfs.has(baseName)) {
                    processedPdfs.add(baseName);
                    pdfsList.push({
                        baseName: baseName,
                        displayName: fileUploadQ.fileTitle || uploadedFile.name.replace(/.pdf$/i, ''),
                        type: 'uploaded',
                        questionId: fileUploadQ.questionId,
                        file: uploadedFile
                    });
                }
            }
        }
    }

    // Process LaTeX Preview PDFs (if "Attach to packet" is selected)
    if (window.latexPdfs && typeof window.latexPdfs === 'object' && window.latexPreviewQuestions && Array.isArray(window.latexPreviewQuestions)) {
        for (const latexPreviewQ of window.latexPreviewQuestions) {
            const latexPdf = window.latexPdfs[latexPreviewQ.questionId];
            if (latexPdf && latexPdf instanceof Blob) {
                // Use title as the base name for the PDF
                const baseName = latexPreviewQ.title || ('latex_preview_' + latexPreviewQ.questionId);
                if (!processedPdfs.has(baseName)) {
                    processedPdfs.add(baseName);
                    pdfsList.push({
                        baseName: baseName,
                        displayName: latexPreviewQ.title || ('LaTeX Preview ' + latexPreviewQ.questionId),
                        type: 'latex',
                        questionId: latexPreviewQ.questionId,
                        file: latexPdf
                    });
                }
            }
        }
    }

    return pdfsList;
}

// Function to show the PDF list modal
async function showPreviewPdfsModal() {
    const modal = document.getElementById('previewPdfsListModal');
    const listContainer = document.getElementById('previewPdfsList');

    if (!modal || !listContainer) {
        alert('Preview modals not found. Please refresh the page.');
        return;
    }

    // Show loading state
    listContainer.innerHTML = '<p style="text-align: center; padding: 20px;">Loading PDFs...</p>';
    modal.style.display = 'flex';

    try {
        // Get all PDFs
        const pdfsList = await getAllPdfsList();

        if (pdfsList.length === 0) {
            listContainer.innerHTML = '<p style="text-align: center; padding: 20px; color: #666;">No PDFs available for preview.</p>';
            return;
        }

        // Create list of PDFs
        let listHTML = '<style>.pdf-preview-item { padding: 15px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; cursor: pointer; transition: all 0.3s; } .pdf-preview-item:hover { background: #e9ecef; border-color: #2980b9; }</style>';
        listHTML += '<div style="display: flex; flex-direction: column; gap: 10px;">';
        pdfsList.forEach((pdf, index) => {
            const escapedBaseName = pdf.baseName.replace(/'/g, "\'").replace(/"/g, '&quot;');
            const escapedDisplayName = pdf.displayName.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
            // Use data attributes to store PDF info (including type and file object for uploaded/LaTeX PDFs)
            const isUploaded = pdf.type === 'uploaded' ? 'true' : 'false';
            const isLatex = pdf.type === 'latex' ? 'true' : 'false';
            const questionId = pdf.questionId || '';
            listHTML += '<div class="pdf-preview-item" data-pdf-name="' + escapedBaseName.replace(/"/g, '&quot;') + '" data-is-uploaded="' + isUploaded + '" data-is-latex="' + isLatex + '" data-question-id="' + questionId + '">' +
                    '<strong style="color: #2c3e50; font-size: 1.1em;">' + escapedDisplayName + '</strong>' +
                    '<span style="color: #6c757d; font-size: 0.9em; display: block; margin-top: 5px;">Click to preview</span>' +
                '</div>';
        });
        listHTML += '</div>';
        // Insert HTML first
        listContainer.innerHTML = listHTML;
        // Attach click handlers using data attributes (after HTML is inserted)
        const pdfItems = listContainer.querySelectorAll('.pdf-preview-item');
        pdfItems.forEach(item => {
            item.addEventListener('click', function() {
                const pdfName = this.getAttribute('data-pdf-name');
                const isUploaded = this.getAttribute('data-is-uploaded') === 'true';
                const isLatex = this.getAttribute('data-is-latex') === 'true';
                const questionId = this.getAttribute('data-question-id');
                if (pdfName) {
                    previewPdf(pdfName, isUploaded, isLatex, questionId);
                }
            });
        });
    } catch (error) {

        listContainer.innerHTML = '<p style="text-align: center; padding: 20px; color: #dc3545;">Error loading PDFs. Please try again.</p>';
    }
}

// Function to close the PDF list modal
function closePreviewPdfsListModal() {
    const modal = document.getElementById('previewPdfsListModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// Function to preview a PDF in full screen
async function previewPdf(baseName, isUploaded, isLatex, questionId) {
    const modal = document.getElementById('previewPdfFullscreenModal');
    const iframe = document.getElementById('previewPdfIframe');

    if (!modal || !iframe) {
        alert('Preview modal not found. Please refresh the page.');
        return;
    }

    // Close the list modal
    closePreviewPdfsListModal();

    // Show loading in fullscreen modal
    modal.style.display = 'flex';
    iframe.style.display = 'none';

    try {
        let url;
        
        // Check if this is a LaTeX PDF
        if (isLatex && questionId && window.latexPdfs && window.latexPdfs[questionId]) {
            // For LaTeX PDFs, use the Blob directly
            const latexPdf = window.latexPdfs[questionId];
            url = URL.createObjectURL(latexPdf);
        } else if (isUploaded && questionId && window.uploadedFiles && window.uploadedFiles[questionId]) {
            // For uploaded files, use the File object directly
            const uploadedFile = window.uploadedFiles[questionId];
            url = URL.createObjectURL(uploadedFile);
        } else {
            // For server-side PDFs, fetch from server
            // Collect form data
            const form = document.getElementById('customForm');
            const fd = new FormData();
            const formElements = form.querySelectorAll('input, textarea, select');
            const externalFormElements = document.querySelectorAll('input[form="customForm"], textarea[form="customForm"], select[form="customForm"]');
            const allFormElements = [...formElements, ...externalFormElements];

            allFormElements.forEach(element => {
                if (element.name && !element.disabled) {
                    if (element.type === 'checkbox' || element.type === 'radio') {
                        if (element.checked) {
                            fd.append(element.name, 'on');
                        }
                    } else {
                        let value = element.value;
                        if (element.type === 'date' && value) {
                            value = formatDateForServer(value);
                        }
                        if (value && value.trim() !== '') {
                            fd.append(element.name, value);
                        }
                    }
                }
            });

            // Fetch the filled PDF (keep extension and include credentials for sessioned APIs)
            const pdfParam = baseName.endsWith('.pdf') ? baseName : (baseName + '.pdf');
            const endpoint = '/edit_pdf?pdf=' + encodeURIComponent(pdfParam);
            const res = await fetch(endpoint, { 
                method: 'POST', 
                body: fd, 
                credentials: 'include' 
            });

            if (!res.ok) {
                throw new Error("HTTP error! status: " + res.status);
            }

            const blob = await res.blob();
            if (blob.size === 0) {
                throw new Error("Received empty PDF blob from server");
            }

            url = URL.createObjectURL(blob);
        }

        iframe.src = url;
        iframe.style.display = 'block';

        // Store the URL for cleanup
        iframe.dataset.pdfUrl = url;

    } catch (error) {

        alert('Error loading PDF preview: ' + error.message);
        modal.style.display = 'none';
    }
}

// Function to close the fullscreen PDF preview
function closePreviewPdfFullscreen() {
    const modal = document.getElementById('previewPdfFullscreenModal');
    const iframe = document.getElementById('previewPdfIframe');
    if (modal) {
        modal.style.display = 'none';
    }
    if (iframe) {
        // Clean up the object URL if it exists
        if (iframe.dataset.pdfUrl) {
            URL.revokeObjectURL(iframe.dataset.pdfUrl);
            delete iframe.dataset.pdfUrl;
        }
        iframe.src = '';
    }
}

// Function to go back to the form from the thank you screen
function goBackToForm() {
    // Hide the thank you message
    const thankYouMessage = document.getElementById('thankYouMessage');
    if (thankYouMessage) {
        thankYouMessage.style.display = 'none';
    }
    // Show the form again
    const formContainer = document.querySelector('form');
    if (formContainer) {
        formContainer.style.display = 'block';
    }
    // Scroll back to the top of the form
    window.scrollTo({ top: 0, behavior: 'smooth' });
}
// Manual PDF download function (called when user clicks "Download PDF" button)
async function downloadAllPdfs() {
    try {
        // Show loading state
        const downloadButton = document.querySelector('button[onclick="downloadAllPdfs()"]');
        if (downloadButton) {
            downloadButton.textContent = 'Processing...';
            downloadButton.disabled = true;
        }
        await processAllPdfs();
        // Reset button
        if (downloadButton) {
            downloadButton.textContent = 'Download PDF';
            downloadButton.disabled = false;
        }
    } catch (error) {
        // Reset button on error
        const downloadButton = document.querySelector('button[onclick="downloadAllPdfs()"]');
        if (downloadButton) {
            downloadButton.textContent = 'Download PDF';
            downloadButton.disabled = false;
        }
    }
}
/*â”€â”€â”€â”€ build FormData with **everything inside the form** â”€â”€â”€â”€*/
async function editAndDownloadPDF (pdfName) {
    try {
        /* this grabs every control that belongs to <form id="customForm">,
           including those specified with form="customForm" attributes   */
        const form = document.getElementById('customForm');
        const fd = new FormData();
        // Manually collect form data to format dates
        // Include both elements inside the form AND elements with form="customForm" attribute
        const formElements = form.querySelectorAll('input, textarea, select');
        const externalFormElements = document.querySelectorAll('input[form="customForm"], textarea[form="customForm"], select[form="customForm"]');
        const allFormElements = [...formElements, ...externalFormElements];
        // Log all elements we're about to process
        allFormElements.forEach((element, index) => {
        });
        allFormElements.forEach(element => {
            if (element.name && !element.disabled) {
                // For checkboxes and radios, only include if checked
                if (element.type === 'checkbox' || element.type === 'radio') {
                    if (element.checked) {
                        fd.append(element.name, 'on'); // Send 'on' for checked checkboxes (standard HTML form behavior)
                    } else {
                    }
                    // Skip unchecked checkboxes entirely - don't send them to server
                } else {
                    let value = element.value;
                    // Format date inputs to mm/dd/yyyy
                    if (element.type === 'date' && value) {
                        const originalValue = value;
                        value = formatDateForServer(value);
                    }
                    // Include ALL fields with values, including hidden ones
                    if (value && value.trim() !== '') {
                        fd.append(element.name, value);
                    } else {
                    }
                }
            } else {
            }
        });
        // Use the /edit_pdf endpoint with the PDF name as a query parameter.
        // Keep the extension and include credentials so the backend can find the file and respect the current session.
        const baseName = pdfName.replace(/.pdf$/i, '');
        const pdfParam = baseName.endsWith('.pdf') ? baseName : (baseName + '.pdf');
        const endpoint = '/edit_pdf?pdf=' + encodeURIComponent(pdfParam);
        const res = await fetch(endpoint, { 
            method: 'POST', 
            body: fd, 
            credentials: 'include' 
        });
        if (!res.ok) {
            const errorText = await res.text();
            throw new Error("HTTP error! status: " + res.status + " - " + errorText);
        }
        const blob = await res.blob();
        if (blob.size === 0) {
            throw new Error("Received empty PDF blob from server");
        }
        const url = URL.createObjectURL(blob);
        // Trigger download
        const a = document.createElement('a');
        a.href = url;
        a.download = 'Edited_' + pdfName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        // Clean up the object URL after a delay
        setTimeout(() => {
            URL.revokeObjectURL(url);
        }, 1000);
        // inline preview - only show the last one
        const frame = document.getElementById('pdfFrame');
        if (frame) {
            frame.src = url;
            frame.style.display = 'block';
        }
        const preview = document.getElementById('pdfPreview');
        if (preview) {
            preview.style.display = 'none';
        }
    } catch (error) {
        throw error; // Re-throw to be handled by the caller
    }
}
/***********************************************
 * Hidden Checkbox Calculations
 ***********************************************/
function runAllHiddenCheckboxCalculations(){
    if(!hiddenCheckboxCalculations || hiddenCheckboxCalculations.length===0) return;
    for(var i=0; i<hiddenCheckboxCalculations.length; i++){
        runSingleHiddenCheckboxCalculation(hiddenCheckboxCalculations[i]);
    }
}
function runSingleHiddenCheckboxCalculation(calcObj){
    var cbox = document.getElementById(calcObj.hiddenFieldName);
    if(!cbox) return;  // hidden field not found
    var finalState = false;  // start with unchecked, only check if calculation conditions are met
    // Evaluate each multi-term condition in 'calculations'
    for(var c=0; c<calcObj.calculations.length; c++){
        var oneCalc = calcObj.calculations[c];
        var val = 0;
        // Sum up the terms
        if(oneCalc.terms && oneCalc.terms.length>0){
            val = parseFloat( getMoneyValue(oneCalc.terms[0].questionNameId) )||0;
            for(var t=1; t<oneCalc.terms.length; t++){
                var term = oneCalc.terms[t];
                var op   = term.operator||'';
                var nextVal = parseFloat(getMoneyValue(term.questionNameId))||0;
                if(op==='+') val += nextVal;
                else if(op==='-') val -= nextVal;
                else if(op==='x') val *= nextVal;
                else if(op==='/'){
                    if(nextVal!==0) val /= nextVal;
                    else val=0;
                }
            }
        }
        // Compare val to threshold
        var thr = parseFloat(oneCalc.threshold)||0;
        var matched = false;
        if(oneCalc.compareOperator==='=') matched = (val===thr);
        else if(oneCalc.compareOperator==='<') matched = (val<thr);
        else if(oneCalc.compareOperator==='>') matched = (val>thr);
        // If matched, set final state
        if(matched){
            finalState = (oneCalc.result==='checked');
        }
    }
    // Set the hidden checkbox state
    cbox.checked = finalState;
    // Handle mutually exclusive checkboxes for suing amount
    if(calcObj.hiddenFieldName === 'suing_over_2500' && finalState) {
        // If suing_over_2500 is checked, ensure suing_under_2500 is unchecked
        var underCheckbox = document.getElementById('suing_under_2500');
        if(underCheckbox) {
            underCheckbox.checked = false;
        }
    } else if(calcObj.hiddenFieldName === 'suing_under_2500' && finalState) {
        // If suing_under_2500 is checked, ensure suing_over_2500 is unchecked
        var overCheckbox = document.getElementById('suing_over_2500');
        if(overCheckbox) {
            overCheckbox.checked = false;
        }
    }
}
/***********************************************
 * Hidden Text Calculations (with placeholders)
 ***********************************************/
function runAllHiddenTextCalculations(){
    if(!hiddenTextCalculations || hiddenTextCalculations.length===0) return;
    for(var i=0; i<hiddenTextCalculations.length; i++){
        runSingleHiddenTextCalculation(hiddenTextCalculations[i]);
    }
}
/**
 * Evaluate each multi-term calculation and set the hidden text field.
 * If fillValue format is "##fieldName##", we store the numeric sum of the terms
 * using the field's own name (or any other field name).
 */
function runSingleHiddenTextCalculation(calcObj) {
    const textField = document.getElementById(calcObj.hiddenFieldName);
    if (!textField) return;
    // We'll assume that the last matched condition takes precedence
    let finalValue = "";
    calcObj.calculations.forEach(function(oneCalc) {
        let val = 0;
        // Calculate the sum of all terms
        if (oneCalc.terms && oneCalc.terms.length > 0) {
            // Get the first term's value
            const firstTerm = oneCalc.terms[0];
            val = parseFloat(getMoneyValue(firstTerm.questionNameId)) || 0;
            // Process remaining terms
            for (let t = 1; t < oneCalc.terms.length; t++) {
                const term = oneCalc.terms[t];
                const termVal = parseFloat(getMoneyValue(term.questionNameId)) || 0;
                switch(term.operator) {
                    case '+': val += termVal; break;
                    case '-': val -= termVal; break;
                    case 'x': val *= termVal; break;
                    case '/': val = termVal !== 0 ? val / termVal : 0; break;
                }
            }
        }
        // Compare to threshold
        const threshold = parseFloat(oneCalc.threshold) || 0;
        let matched = false;
        switch(oneCalc.compareOperator) {
            case '>': matched = val > threshold; break;
            case '<': matched = val < threshold; break;
            case '=': matched = Math.abs(val - threshold) < 0.000001; break; // Use epsilon for float comparison
        }
        if (matched) {
            // Handle special fillValue formats
            if (oneCalc.fillValue === "##total##" || oneCalc.fillValue.match(/^##(.+)##$/)) {
                finalValue = val.toFixed(2); // Format money values with 2 decimal places
            } else {
                finalValue = oneCalc.fillValue;
            }
        }
    });
    // Update the text field
    textField.value = finalValue;
}
function replacePlaceholderTokens (str){
    /* note the doubled back-slashes in the delimiters $$ */
    return str.replace(/\$\$(.*?)\$\$/g, function (_match, innerExpr){
        return evaluatePlaceholderExpression(innerExpr);
    });
}
function evaluatePlaceholderExpression (exprString){
    /* split on +  -  x  /   (all kept as separate tokens) */
    var tokens = exprString.split(/([+-x/])/);          // â† every  is **doubled**
    if (!tokens.length) return '0';
    var currentVal = parseTokenValue(tokens[0]);
    for (var i = 1; i < tokens.length; i += 2){
        var op   = tokens[i];
        var next = parseTokenValue(tokens[i + 1] || '0');
        if      (op === '+') currentVal += next;
        else if (op === '-') currentVal -= next;
        else if (op === 'x') currentVal *= next;
        else if (op === '/') currentVal  = next !== 0 ? currentVal / next : 0;
    }
    return currentVal.toString();
}
function parseTokenValue(token){
    token = token.trim();
    if(!token) return 0;
    var el= document.getElementById(token);
    if(!el) return 0;
    var val= parseFloat(el.value);
    return isNaN(val) ? 0 : val;
}
/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*
 * 3.  getMoneyValue(qId)
 *     â€“ tiny regex fix so legacy "amountX_Y_Z" can still resolve
 *       (note the escaped \d+ instead of stray 'd').
 *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
function getMoneyValue(qId) {
    /* direct hit first */
    const el = document.getElementById(qId);
    if (el) {
        if (el.type === "checkbox") {
            const amt = document.getElementById(el.id + "_amount");
            if (amt && el.checked) return parseFloat(amt.value) || 0;
            return el.checked ? 1 : 0;
        }
        return parseFloat(el.value) || 0;
    }
    /* legacy builderâ€‘shorthand amountX_Y_Z */
    if (/^amountd+_d+_.+/.test(qId)) {
        const el2 = document.getElementById(normaliseDesignerFieldRef(qId));
        if (el2) return parseFloat(el2.value) || 0;
    }
    /* nameâ€‘attribute fallback */
    const byName = document.getElementsByName(qId);
    if (byName.length) return parseFloat(byName[0].value) || 0;
    return 0;
}
function attachCalculationListeners() {
    // Universal function to attach listeners in a consistent way
    function attachListenersToCalculationTerms(calculations, runCalculationFunction) {
        for (let i = 0; i < calculations.length; i++) {
            const calcObj = calculations[i];
            for (let c = 0; c < calcObj.calculations.length; c++) {
                const oneCalc = calcObj.calculations[c];
                const terms = oneCalc.terms || [];
                for (let t = 0; t < terms.length; t++) {
                    const qNameId = terms[t].questionNameId;
                    // 1. Try direct element
                    const el = document.getElementById(qNameId);
                    if (el) {
                        el.addEventListener('change', runCalculationFunction);
                        el.addEventListener('input', runCalculationFunction);
                        // If it's a checkbox, also listen to its amount field
                        if (el.type === 'checkbox') {
                            const amountField = document.getElementById(el.id + '_amount');
                            if (amountField) {
                                amountField.addEventListener('input', runCalculationFunction);
                            }
                        }
                        continue; // Found and attached, go to next term
                    }
                    // 2. Try elements with this name
                    const namedElements = document.getElementsByName(qNameId);
                    if (namedElements.length > 0) {
                        for (let n = 0; n < namedElements.length; n++) {
                            namedElements[n].addEventListener('change', runCalculationFunction);
                            namedElements[n].addEventListener('input', runCalculationFunction);
                        }
                        continue;
                    }
                    // 3. Look for prefixed IDs like "answerX_qId"
                    const prefixPattern = new RegExp('.*_' + qNameId + '$');
                    const allInputs = document.querySelectorAll('input, select, textarea');
                    for (let inp = 0; inp < allInputs.length; inp++) {
                        const input = allInputs[inp];
                        if (prefixPattern.test(input.id)) {
                            input.addEventListener('change', runCalculationFunction);
                            input.addEventListener('input', runCalculationFunction);
                            // If it's a checkbox with amount field
                            if (input.type === 'checkbox') {
                                const amountField = document.getElementById(input.id + '_amount');
                                if (amountField) {
                                    amountField.addEventListener('input', runCalculationFunction);
                                }
                            }
                        }
                    }
                    // 4. Look specifically for amount fields with this name
                    const amountElements = document.querySelectorAll('input[name="' + qNameId + '"]');
                    for (let a = 0; a < amountElements.length; a++) {
                        amountElements[a].addEventListener('input', runCalculationFunction);
                        // Also find and attach to the controlling checkbox
                        if (amountElements[a].id.includes('_amount')) {
                            const checkboxId = amountElements[a].id.replace('_amount', '');
                            const checkbox = document.getElementById(checkboxId);
                            if (checkbox) {
                                checkbox.addEventListener('change', runCalculationFunction);
                            }
                        }
                    }
                    // 5. Try direct amount field
                    const directAmountField = document.getElementById(qNameId + '_amount');
                    if (directAmountField) {
                        directAmountField.addEventListener('input', runCalculationFunction);
                        // Find the checkbox controlling this amount field
                        const checkboxSelector = 'input[type="checkbox"][onchange*="' + directAmountField.id + '"]';
                        const checkbox = document.querySelector(checkboxSelector);
                        if (checkbox) {
                            checkbox.addEventListener('change', runCalculationFunction);
                        }
                    }
                }
            }
        }
    }
    // For hidden checkbox calculations
    if (hiddenCheckboxCalculations && hiddenCheckboxCalculations.length > 0) {
        const runAllCheckboxCalcs = function() {
            runAllHiddenCheckboxCalculations();
        };
        attachListenersToCalculationTerms(hiddenCheckboxCalculations, runAllCheckboxCalcs);
    }
    // For hidden text calculations
    if (hiddenTextCalculations && hiddenTextCalculations.length > 0) {
        const runAllTextCalcs = function() {
            runAllHiddenTextCalculations();
        };
        attachListenersToCalculationTerms(hiddenTextCalculations, runAllTextCalcs);
    }
    // Run calculations once on page load to set initial values
    runAllHiddenCheckboxCalculations();
    runAllHiddenTextCalculations();
}
// Progress Bar Logic
function updateProgressBar() {
  // Stepper logic
  const stepper = document.getElementById('stepperProgressBar');
  if (!stepper) return;
  const steps = stepper.querySelectorAll('.stepper-step');
  // Check if we're using group-based progress
  if (window.groupToSectionMap && window.sectionToGroupMap) {
    // Group-based progress bar
    let activeGroupStep = 1;
    if (typeof currentSectionNumber === 'number') {
      // Find which section we're currently on
      const currentSectionEl = document.querySelector('#section' + currentSectionNumber);
      if (currentSectionEl) {
        const sectionTitleEl = currentSectionEl.querySelector('.section-title');
        if (sectionTitleEl) {
          const currentSectionName = sectionTitleEl.textContent.trim();
          const currentGroupId = window.sectionToGroupMap[currentSectionName];
          if (currentGroupId) {
            // Find the step number for this group
            const groupIds = Object.keys(window.groupToSectionMap).sort((a, b) => parseInt(a) - parseInt(b));
            activeGroupStep = groupIds.indexOf(currentGroupId) + 1;
          }
        }
      }
    } else if (currentSectionNumber === 'end') {
      activeGroupStep = steps.length;
    }
    steps.forEach((step, idx) => {
      step.classList.remove('active', 'completed');
      if (idx + 1 < activeGroupStep) {
        step.classList.add('completed');
      } else if (idx + 1 === activeGroupStep) {
        step.classList.add('active');
      }
    });
    // Animate lines between completed steps
    const lines = stepper.querySelectorAll('.stepper-line');
    lines.forEach((line, idx) => {
      if (idx < activeGroupStep - 1) {
        line.classList.add('filled');
      } else {
        line.classList.remove('filled');
      }
    });
  } else {
    // Section-based progress bar (fallback)
    let activeStep = 1;
    if (typeof currentSectionNumber === 'number') {
      activeStep = currentSectionNumber;
    } else if (currentSectionNumber === 'end') {
      activeStep = steps.length;
    }
    steps.forEach((step, idx) => {
      step.classList.remove('active', 'completed');
      if (idx + 1 < activeStep) {
        step.classList.add('completed');
      } else if (idx + 1 === activeStep) {
        step.classList.add('active');
      }
    });
    // Animate lines between completed steps
    const lines = stepper.querySelectorAll('.stepper-line');
    lines.forEach((line, idx) => {
      if (idx < activeStep - 1) {
        line.classList.add('filled');
      } else {
        line.classList.remove('filled');
      }
    });
  }
}
// Animate the progress bar fill width smoothly
function animateProgressBarFill(fillEl, targetPercent) {
  if (!fillEl) return;
  // Cancel any previous animation
  if (fillEl._progressAnimFrame) {
    cancelAnimationFrame(fillEl._progressAnimFrame);
    fillEl._progressAnimFrame = null;
  }
  const currentWidth = parseFloat(fillEl.style.width) || 0;
  const start = currentWidth;
  const end = targetPercent;
  const duration = 500; // ms, should match CSS transition
  const startTime = performance.now();
  function animate(now) {
    const elapsed = now - startTime;
    const t = Math.min(elapsed / duration, 1);
    // Use easeInOutCubic for a nice effect
    const ease = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    const newWidth = start + (end - start) * ease;
    fillEl.style.width = newWidth + '%';
    if (t < 1) {
      fillEl._progressAnimFrame = requestAnimationFrame(animate);
    } else {
      fillEl.style.width = end + '%';
      fillEl._progressAnimFrame = null;
    }
  }
  requestAnimationFrame(animate);
}
document.addEventListener('DOMContentLoaded', function() {
  updateProgressBar();
});
// Modal logic
function showLoginRequiredModal() {
  document.getElementById('loginRequiredModal').style.display = 'flex';
}
function hideLoginRequiredModal() {
  document.getElementById('loginRequiredModal').style.display = 'none';
}
document.addEventListener('DOMContentLoaded', function() {
  var backBtn = document.getElementById('modalBackBtn');
  var contBtn = document.getElementById('modalContinueBtn');
  if (backBtn) backBtn.onclick = hideLoginRequiredModal;
  if (contBtn) contBtn.onclick = function() {
    window.location.href = '../Pages/account.html';
  };
});
// Patch handleNext to check login before advancing
if (typeof handleNext === 'function') {
  var originalHandleNext = handleNext;
  window.handleNext = function(currentSection) {
    if (!isUserLoggedIn) {
      var loginModal = document.getElementById('loginRequiredModal');
      if (loginModal && typeof showLoginRequiredModal === 'function') {
      showLoginRequiredModal();
      return;
      }
    }
    originalHandleNext(currentSection);
  };
}
// AUTOSAVE, RESTORE, AND WIPE LOGIC FOR ALL GENERATED FORMS
(function() {
    // Wait for Firebase and DOM
    function onReady(fn) {
        if (document.readyState !== 'loading') fn();
        else document.addEventListener('DOMContentLoaded', fn);
    }
    onReady(function() {
        if (typeof firebase === 'undefined' || !firebase.auth || !firebase.firestore) return;
        const db = firebase.firestore();
        const urlParams = new URLSearchParams(window.location.search);
        const baseFormId = urlParams.get('formId') || window.formId || 'default';
        const county = urlParams.get('county') || '';
        const portfolioId = urlParams.get('portfolioId') || '';
        // Create a unique form ID that includes county and portfolio information for autosave separation
        let formId = baseFormId;
        if (county) formId += '_' + county.replace(/W+/g, '_');
        if (portfolioId) formId += '_' + portfolioId;
        let userId = null;
        let isUserLoggedIn = false;
        // Helper: get all form fields to save
        function getFormFields() {
            const form = document.getElementById('customForm');
            if (!form) {
                return [];
            }
            // Include both elements inside the form AND elements with form="customForm" attribute
            const formElements = Array.from(form.elements);
            const externalFormElements = Array.from(document.querySelectorAll('input[form="customForm"], textarea[form="customForm"], select[form="customForm"]'));
            const allFormElements = [...formElements, ...externalFormElements];
            const fields = allFormElements.filter(el =>
                el.name &&
                !el.disabled &&
                ['INPUT', 'TEXTAREA', 'SELECT'].includes(el.tagName) &&
                !['button', 'submit', 'reset'].includes(el.type) &&
                // Include hidden fields except for specific ones we don't want to send
                (el.type !== 'hidden' || el.id === 'current_date' || el.id === 'form_zip' || el.id === 'form_county' || el.id === 'form_defendant' || el.id === 'form_ID')
            );
            return fields;
        }
        // Helper: quick visibility check for logging
        function isElementActuallyVisible(el) {
            return !!(el && (el.offsetParent || el.getClientRects().length));
        }
        // Debounce and queue management for saveAnswers
        let saveAnswersTimeout = null;
        let isSaving = false;
        let pendingSave = false;
        let saveRetryCount = 0;
        const MAX_RETRIES = 3;
        const DEBOUNCE_DELAY = 1000; // Wait 1 second after last change before saving

        // Helper: save answers (with debouncing, error handling, and visibility prioritization)
        async function saveAnswers(immediate = false) {
            if (!isUserLoggedIn || !userId) return;

            // If immediate save requested, clear any pending debounced save
            if (immediate && saveAnswersTimeout) {
                clearTimeout(saveAnswersTimeout);
                saveAnswersTimeout = null;
            }

            // If already saving, mark that we need to save again after current save completes
            if (isSaving) {
                pendingSave = true;
                return;
            }

            // Debounce: wait for user to stop typing
            if (!immediate) {
                clearTimeout(saveAnswersTimeout);
                saveAnswersTimeout = setTimeout(() => {
                    saveAnswers(true);
                }, DEBOUNCE_DELAY);
                return;
            }

            // ðŸ”§ NEW: Prevent blank values from being saved in first 3 seconds
            if (window.preventBlankSaves) {
                return;
            }

            isSaving = true;
            try {
                const fields = getFormFields();
                const answers = {};
                const fieldVisibility = {}; // Track which fields are visible

                fields.forEach(el => {
                    const isVisible = isElementActuallyVisible(el);
                    const fieldName = el.name;

                    // Skip if we already have a visible field's value and this field is hidden
                    if (fieldVisibility[fieldName] === true && !isVisible) {
                        return; // Skip this hidden field, we already have a visible one
                    }

                    // Store the value
                    if (el.type === 'checkbox') {
                        // For checkboxes, save true/false
                        answers[fieldName] = el.checked;
                    } else if (el.type === 'radio') {
                        // For radio buttons, save the selected value or null if none selected
                        const selectedRadio = document.querySelector('input[name="' + fieldName + '"]:checked');
                        answers[fieldName] = selectedRadio ? selectedRadio.value : null;
                    } else {
                        // For other fields, save the value
                        answers[fieldName] = el.value;
                    }

                    // Track visibility for this field name
                    fieldVisibility[fieldName] = isVisible;
                });

                // Write to Firestore with error handling and retry logic
                await db.collection('users').doc(userId).collection('formAnswers').doc(formId).set(answers, { merge: true });
                saveRetryCount = 0; // Reset retry count on success
            } catch (error) {

                // Handle resource-exhausted error specifically
                if (error.code === 'resource-exhausted' || (error.message && error.message.includes('queued writes'))) {

                    // Retry with exponential backoff
                    if (saveRetryCount < MAX_RETRIES) {
                        saveRetryCount++;
                        const backoffDelay = Math.min(1000 * Math.pow(2, saveRetryCount), 10000); // Max 10 seconds

                        setTimeout(() => {
                            saveAnswers(true); // Retry immediately
                        }, backoffDelay);
                    } else {

                        saveRetryCount = 0;
                    }
                } else {
                    // For other errors, just log and reset

                    saveRetryCount = 0;
                }
            } finally {
                isSaving = false;

                // If there's a pending save, trigger it after a short delay
                if (pendingSave) {
                    pendingSave = false;
                    setTimeout(() => {
                        saveAnswers(true);
                    }, 500);
                }
            }
        }
        // Helper function to check paragraph limits for autofilled textareas
        function triggerParagraphLimitCheckForAutofilledTextareas() {
            // Find all textareas and check if they need paragraph limit checking
            const textareas = document.querySelectorAll('textarea');
            textareas.forEach(textarea => {
                if (textarea.value && textarea.value.length > 0) {
                    // Check if this textarea has a paragraph limit by looking for the checkParagraphLimit function
                    // We'll trigger the oninput event which will call checkParagraphLimit if it's set up
                    const event = new Event('input', { bubbles: true });
                    textarea.dispatchEvent(event);
                }
            });
        }
        // Helper function to trigger line splitting for autofilled textareas
        function triggerLineSplittingForAutofilledTextareas() {
            // Find all textareas that have a line limit data attribute
            const textareas = document.querySelectorAll('textarea[data-line-limit]');
            textareas.forEach(textarea => {
                const lineLimit = parseInt(textarea.getAttribute('data-line-limit'));
                if (lineLimit && textarea.value && textarea.value.length > 0) {
                    // Call the handleLineSplitting function if it exists
                    if (typeof handleLineSplitting === 'function') {
                        handleLineSplitting(textarea.id, lineLimit);
                    } else {
                        // Fallback: manually trigger the line splitting logic
                        const text = textarea.value;
                        const totalChars = text.length;
                        const linesNeeded = Math.ceil(totalChars / lineLimit);
                        // Create or update hidden textboxes for each line
                        for (let i = 1; i <= linesNeeded; i++) {
                            const startIndex = (i - 1) * lineLimit;
                            const endIndex = Math.min(startIndex + lineLimit, totalChars);
                            const lineText = text.substring(startIndex, endIndex);
                            const hiddenInputId = textarea.id + '_line' + i;
                            let hiddenInput = document.getElementById(hiddenInputId);
                            if (!hiddenInput) {
                                // Create new hidden input
                                hiddenInput = document.createElement('input');
                                hiddenInput.type = 'hidden';
                                hiddenInput.id = hiddenInputId;
                                hiddenInput.name = hiddenInputId;
                                textarea.parentNode.appendChild(hiddenInput);
                            }
                            hiddenInput.value = lineText;
                        }
                        // Remove any extra hidden inputs that are no longer needed
                        let lineNum = linesNeeded + 1;
                        while (true) {
                            const extraInput = document.getElementById(textarea.id + '_line' + lineNum);
                            if (extraInput) {
                                extraInput.remove();
                                lineNum++;
                            } else {
                                break;
                            }
                        }
                    }
                }
            });
        }
        // Helper: load answers
        async function loadAnswers() {
            if (!isUserLoggedIn || !userId) {
                return;
            }
            try {
                // First, try to load user profile data from a user profile document
                const userProfileDoc = await db.collection('users').doc(userId).get();
                let userProfileData = {};
                if (userProfileDoc.exists) {
                    userProfileData = userProfileDoc.data();
                }
                // Then, try to load form-specific data
                const doc = await db.collection('users').doc(userId).collection('formAnswers').doc(formId).get();
                let formData = {};
                if (doc.exists) {
                    formData = doc.data();
                }
                // Combine user profile data with form data
                const data = { ...userProfileData, ...formData };
                // Helper function to map Firebase data to form field names
                function mapFirebaseDataToFormFields(firebaseData) {
                    const mappedData = { ...firebaseData };
                    // Map user info fields from Firebase structure to form field names
                    if (firebaseData.firstName) mappedData.user_firstname = firebaseData.firstName;
                    if (firebaseData.lastName) mappedData.user_lastname = firebaseData.lastName;
                    if (firebaseData.email) mappedData.user_email = firebaseData.email;
                    if (firebaseData.phone) mappedData.user_phone = firebaseData.phone;
                    // Map address fields
                    if (firebaseData.address) {
                        if (firebaseData.address.street) mappedData.user_street = firebaseData.address.street;
                        if (firebaseData.address.city) mappedData.user_city = firebaseData.address.city;
                        if (firebaseData.address.state) mappedData.user_state = firebaseData.address.state;
                        if (firebaseData.address.zip) mappedData.user_zip = firebaseData.address.zip;
                    }
                    return mappedData;
                }
                const mappedData = mapFirebaseDataToFormFields(data);
                // ðŸ”§ NEW: Store mappedData globally so showTextboxLabels can access it for immediate autofill
                window.mappedData = mappedData;
                // ðŸ”§ NEW: Debug all radio buttons in the form
                const allRadioButtons = document.querySelectorAll('input[type="radio"]');
        // ðŸ”§ NEW: Add flag to prevent autosave during initial load
        window.isInitialAutofill = true;
        // ðŸ”§ NEW: Prevent blank values from being sent to Firebase in first 3 seconds
        window.preventBlankSaves = true;
        setTimeout(() => {
            window.preventBlankSaves = false;
        }, 3000);
                    const fields = getFormFields();
                    // First pass: identify which field names have visible fields
                    const visibleFieldNames = new Set();
                    fields.forEach(el => {
                        if (isElementActuallyVisible(el) && el.name) {
                            visibleFieldNames.add(el.name);
                        }
                    });
                    fields.forEach(el => {
                    // Skip hidden fields if there's a visible field with the same name
                    const isVisible = isElementActuallyVisible(el);
                    if (!isVisible && el.name && visibleFieldNames.has(el.name)) {
                        return; // Skip this hidden field, there's a visible one
                    }
                    // Check both by name and by ID for autofill
                    let autofillValue = null;
                    if (mappedData.hasOwnProperty(el.name)) {
                        autofillValue = mappedData[el.name];
                    } else if (el.id && mappedData.hasOwnProperty(el.id)) {
                        autofillValue = mappedData[el.id];
                    }
                    if (autofillValue !== null) {
                            // Skip current_date field - it should be set dynamically
                            if (el.id === 'current_date' || el.name === 'current_date') {
                                return;
                            }
                            // Check if this answer would trigger a jump to the end
                        if (wouldTriggerJumpToEnd(el, autofillValue)) {
                                // Don't autofill this answer - keep it as default
                                return;
                            }
                            if (el.type === 'checkbox' || el.type === 'radio') {
                            if (el.type === 'radio') {
                                // For radio buttons, we need to check if this specific radio button should be selected
                                if (el.value === autofillValue) {
                                    el.checked = true;
                                    // Dispatch change event to trigger linked textbox creation
                                    const changeEvent = new Event('change', { bubbles: true });
                                    el.dispatchEvent(changeEvent);
                            } else {
                                    el.checked = false;
                                }
                            } else {
                                // For checkboxes, use the boolean value
                                const wasChecked = el.checked;
                                el.checked = !!autofillValue;
                                // Dispatch change event if checkbox state changed to trigger linked textbox creation
                                if (el.checked !== wasChecked) {
                                    const changeEvent = new Event('change', { bubbles: true });
                                    el.dispatchEvent(changeEvent);
                                }
                            }
                        } else {
                            el.value = autofillValue;
                            // Dispatch input and change events for text inputs to trigger linked textbox syncing
                            if (el.tagName === 'INPUT' && (el.type === 'text' || el.type === 'number' || !el.type)) {
                                const inputEvent = new Event('input', { bubbles: true });
                                el.dispatchEvent(inputEvent);
                                const changeEvent = new Event('change', { bubbles: true });
                                el.dispatchEvent(changeEvent);
                            }
                            // If this is a select element (dropdown), trigger change event to update conditional logic
                            if (el.tagName === 'SELECT') {
                                // Trigger change event to call dropdownMirror and update conditional logic
                                const changeEvent = new Event('change', { bubbles: true });
                                el.dispatchEvent(changeEvent);
                            }
                            }
                        }
                    });
                    // After autofilling, trigger visibility updates for dependent questions
                    // Use a longer delay to ensure conditional logic scripts are fully loaded and executed
                    setTimeout(() => {
                        // Trigger change events on all autofilled elements to ensure conditional logic runs
                        fields.forEach(el => {
                            if (el.value || el.checked) {
                                const event = new Event('change', { bubbles: true });
                                el.dispatchEvent(event);
                            }
                        });
                        // Also call the global visibility updates function
                        if (typeof triggerVisibilityUpdates === 'function') {
                            triggerVisibilityUpdates();
                        }
                    }, 2000);
                    // Trigger numbered dropdown textbox generation for any numbered dropdowns that were autofilled
                    fields.forEach(el => {
                    if (el.tagName === 'SELECT' && (el.id.startsWith('answer') || el.id.startsWith('how_many')) && el.value) {
                        let questionId;
                        // First, try to get questionId from data attribute
                        if (el.dataset && el.dataset.questionId) {
                            questionId = el.dataset.questionId;
                        } else if (el.id.startsWith('answer')) {
                            questionId = el.id.replace('answer', '');
                        } else if (el.id.startsWith('how_many')) {
                            // For how_many dropdowns, use the helper function to extract from onchange
                            const dropdownElement = document.getElementById(el.id);
                            const qFromOnchange = extractQuestionIdFromOnchange(dropdownElement && dropdownElement.onchange);
                            if (qFromOnchange) {
                                questionId = qFromOnchange;
                            } else {
                                // Final fallback: try to find the container by checking which labelContainer exists
                                for (let i = 1; i <= 10; i++) {
                                    if (document.getElementById('labelContainer' + i)) {
                                        questionId = i.toString();
                                        break;
                                    }
                                }
                            }
                        }
                            if (typeof showTextboxLabels === 'function') {
                                showTextboxLabels(questionId, el.value);
                            }
                            if (typeof updateHiddenCheckboxes === 'function') {
                                updateHiddenCheckboxes(questionId, el.value);
                            }
                        }
                    });
                // Trigger state hidden field updates for any state dropdowns that were autofilled
                fields.forEach(el => {
                    if (el.tagName === 'SELECT' && el.id && el.value && el.classList.contains('address-select')) {
                        // This is a state dropdown that was autofilled
                        const hiddenFullId = el.id; // use the select's id as the full field reference
                        const hiddenShortId = window.toShortIdFromBase(el.id);
                        if (typeof updateStateHiddenFields === 'function') {
                            updateStateHiddenFields(el, hiddenFullId, hiddenShortId);
                            }
                        }
                    });
                    // Trigger hidden checkbox generation for any regular dropdowns that were autofilled
                    fields.forEach(el => {
                        if (el.tagName === 'SELECT' && el.id && !el.id.startsWith('answer') && el.value) {
                            if (typeof dropdownMirror === 'function') {
                                dropdownMirror(el, el.id);
                            }
                        // Trigger hidden logic for autofilled dropdowns
                        if (typeof updateHiddenLogic === 'function') {
                            updateHiddenLogic(el.id, el.value);
                            }
                        }
                    });
                    // Create hidden checkboxes for all autofilled dropdowns
                    if (typeof createHiddenCheckboxesForAutofilledDropdowns === 'function') {
                        createHiddenCheckboxesForAutofilledDropdowns();
                    }
                // Trigger line splitting for autofilled textareas
                triggerLineSplittingForAutofilledTextareas();
                // Trigger paragraph limit checking for autofilled textareas
                triggerParagraphLimitCheckForAutofilledTextareas();
                    // Second autofill pass for dynamically generated textbox inputs
                    // Use a longer delay to ensure textbox inputs are fully generated
                    setTimeout(() => {
                        const allFields = getFormFields();
                        // Also try to find fields by ID directly as a fallback
                        const fieldsById = {};
                        allFields.forEach(el => {
                            if (el.id) {
                                fieldsById[el.id] = el;
                            }
                        });
                        allFields.forEach(el => {
                            if (mappedData.hasOwnProperty(el.name)) {
                                // Skip current_date field - it should be set dynamically
                                if (el.id === 'current_date' || el.name === 'current_date') {
                                    return;
                                }
                                if (el.type === 'checkbox') {
                                    el.checked = !!mappedData[el.name];
                                } else if (el.type === 'radio') {
                                    // For radio buttons, only check the one that matches the value
                                    if (el.value === mappedData[el.name]) {
                                        el.checked = true;
                                    } else {
                                        el.checked = false;
                                    }
                                } else {
                                    el.value = mappedData[el.name];
                                }
                            }
                        });
                        // Additional pass: try to autofill by ID for any fields that might have been missed
                        Object.keys(mappedData).forEach(fieldName => {
                            // Skip current_date field - it should be set dynamically
                            if (fieldName === 'current_date') {
                                return;
                            }
                            const fieldById = fieldsById[fieldName];
                            if (fieldById && mappedData[fieldName]) {
                                // Check if field needs autofilling (different logic for different field types)
                                const needsAutofill = (fieldById.type === 'checkbox' || fieldById.type === 'radio') 
                                    ? !fieldById.checked 
                                    : !fieldById.value;
                                if (needsAutofill) {
                                if (fieldById.type === 'checkbox' || fieldById.type === 'radio') {
                                        if (fieldById.type === 'radio') {
                                            // For radio buttons, check if this specific radio should be selected
                                            if (fieldById.value === mappedData[fieldName]) {
                                                fieldById.checked = true;
                                            } else {
                                                fieldById.checked = false;
                                            }
                                        } else {
                                            // For checkboxes, use boolean value
                                    fieldById.checked = !!mappedData[fieldName];
                                        }
                                } else {
                                    fieldById.value = mappedData[fieldName];
                                    }
                                }
                            }
                        });
                        // Trigger line splitting again after the second autofill pass
                        triggerLineSplittingForAutofilledTextareas();
                        // Trigger paragraph limit checking again after the second autofill pass
                        triggerParagraphLimitCheckForAutofilledTextareas();
                        // Trigger numbered dropdown textbox generation for any numbered dropdowns that were autofilled in second pass
                        allFields.forEach(el => {
                            if (el.tagName === 'SELECT' && (el.id.startsWith('answer') || el.id.startsWith('how_many')) && el.value) {
                                let questionId;
                                // First, try to get questionId from data attribute
                                if (el.dataset && el.dataset.questionId) {
                                    questionId = el.dataset.questionId;
                                } else if (el.id.startsWith('answer')) {
                                    questionId = el.id.replace('answer', '');
                                } else if (el.id.startsWith('how_many')) {
                                    // For how_many dropdowns, use the helper function to extract from onchange
                                    const dropdownElement = document.getElementById(el.id);
                                    const qFromOnchange = extractQuestionIdFromOnchange(dropdownElement && dropdownElement.onchange);
                                    if (qFromOnchange) {
                                        questionId = qFromOnchange;
                                    } else {
                                        // Final fallback: try to find the container by checking which labelContainer exists
                                        for (let i = 1; i <= 10; i++) {
                                            if (document.getElementById('labelContainer' + i)) {
                                                questionId = i.toString();
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (typeof showTextboxLabels === 'function') {
                                    showTextboxLabels(questionId, el.value);
                                    // After creating numbered fields, autofill them with Firebase data
                                    setTimeout(() => {
                                        const count = parseInt(el.value);
                                        if (count > 0) {
                                            // Get the base field name from the dropdown
                                            const baseFieldName = el.id;
                                            // Try to autofill numbered fields for each count
                                            for (let i = 1; i <= count; i++) {
                                                // Common field patterns to check - using the actual Firebase naming pattern
                                                const fieldPatterns = [
                                                    'name', 
                                                    'phone_number', 
                                                    'mailing_address',
                                                    'street',
                                                    'city', 
                                                    'state', 
                                                    'zip'
                                                ];
                                                fieldPatterns.forEach(pattern => {
                                                    // Try both naming patterns: sc100_how_many_people_are_suing_with_you_1_name and how_many_people_are_suing_with_you_name_1
                                                    const fieldId1 = 'sc100_' + baseFieldName + '_' + i + '_' + pattern;
                                                    const fieldId2 = baseFieldName + '_' + pattern + '_' + i;
                                                    // Check first pattern
                                                    let fieldElement = document.getElementById(fieldId1);
                                                    if (fieldElement && mappedData[fieldId1]) {
                                                        fieldElement.value = mappedData[fieldId1];
                                                    }
                                                    // Check second pattern
                                                    fieldElement = document.getElementById(fieldId2);
                                                    if (fieldElement && mappedData[fieldId2]) {
                                                        fieldElement.value = mappedData[fieldId2];
                                                    }
                                                });
                                            }
                                        } else {
                                        }
                                    }, 500); // Increased delay to ensure fields are created and DOM is updated
                                }
                                if (typeof updateHiddenCheckboxes === 'function') {
                                    updateHiddenCheckboxes(questionId, el.value);
                                }
                            }
                        });
                        // Trigger state hidden field updates for any state dropdowns that were autofilled in second pass
                        allFields.forEach(el => {
                            if (el.tagName === 'SELECT' && el.id && el.value && el.classList.contains('address-select')) {
                                // This is a state dropdown that was autofilled
                                const hiddenFullId = el.id + '_hidden'; // Add _hidden suffix to avoid conflict with dropdown
                                const hiddenShortId = window.toShortIdFromBase(el.id);
                                if (typeof updateStateHiddenFields === 'function') {
                                    updateStateHiddenFields(el, hiddenFullId, hiddenShortId);
                                }
                            }
                        });
                    }, 1500);
                        // Reset hidden questions to defaults after autofill and visibility updates
                        // BUT NOT during initial autofill to preserve autofilled values
                        if (typeof currentSectionNumber === 'number' && !window.isInitialAutofill) {
                            resetHiddenQuestionsToDefaults(currentSectionNumber);
                }
                // ðŸ”§ NEW: Additional fallback for numbered dropdown autofill - try again after a longer delay
                setTimeout(() => {
                    const numberedDropdowns = document.querySelectorAll('select[id*="how_many"], select[id*="answer"]');
                    numberedDropdowns.forEach(dropdown => {
                        if (dropdown.value && parseInt(dropdown.value) > 0) {
                            // Trigger the autofill logic again for any missed dropdowns
                            const questionId = dropdown.dataset.questionId || dropdown.id.replace(/^(answer|how_many)/, '');
                            if (typeof showTextboxLabels === 'function') {
                                showTextboxLabels(questionId, dropdown.value);
                                // ðŸ”§ NEW: Add the missing autofill logic for numbered fields
                                setTimeout(() => {
                                    const count = parseInt(dropdown.value);
                                    if (count > 0) {
                                        // Get the base field name from the dropdown
                                        const baseFieldName = dropdown.id;
                                        // Try to autofill numbered fields for each count
                                        for (let i = 1; i <= count; i++) {
                                            // Common field patterns to check - using the actual Firebase naming pattern
                                            const fieldPatterns = [
                                                'name', 
                                                'phone_number', 
                                                'mailing_address',
                                                'street',
                                                'city', 
                                                'state',
                                                'zip',
                                                'zip_code',
                                                'email',
                                                'address'
                                            ];
                                            fieldPatterns.forEach(pattern => {
                                                // Try both naming patterns: sc100_how_many_people_are_suing_with_you_1_name and how_many_people_are_suing_with_you_name_1
                                                const fieldId1 = 'sc100_' + baseFieldName + '_' + i + '_' + pattern;
                                                const fieldId2 = baseFieldName + '_' + pattern + '_' + i;
                                                // Check first pattern
                                                let fieldElement = document.getElementById(fieldId1);
                                                if (fieldElement && mappedData[fieldId1]) {
                                                    fieldElement.value = mappedData[fieldId1];
                                                }
                                                // Check second pattern
                                                fieldElement = document.getElementById(fieldId2);
                                                if (fieldElement && mappedData[fieldId2]) {
                                                    fieldElement.value = mappedData[fieldId2];
                                                }
                                            });
                                        }
                                    } else {
                                    }
                                }, 500); // 500ms delay to ensure fields are created
                            }
                        }
                    });
                }, 1000); // 1 second delay for fallback
        // ðŸ”§ NEW: Delayed autofill for conditional fields that are created after initial autofill
        setTimeout(() => {
            const conditionalFields = getFormFields();
            conditionalFields.forEach(el => {
                // Check both by name and by ID for autofill
                let autofillValue = null;
                if (mappedData.hasOwnProperty(el.name)) {
                    autofillValue = mappedData[el.name];
                } else if (el.id && mappedData.hasOwnProperty(el.id)) {
                    autofillValue = mappedData[el.id];
                }
                // Debug conditional fields that are part of trigger sequences
                const isConditionalField = isFieldPartOfTriggerSequence(el.name, el.id);
                if (el.name && isConditionalField) {
                }
                if (autofillValue !== null) {
                    // Skip current_date field - it should be set dynamically
                    if (el.id === 'current_date' || el.name === 'current_date') {
                        return;
                    }
                    if (el.type === 'checkbox' || el.type === 'radio') {
                        if (el.type === 'radio') {
                            // For radio buttons, we need to check if this specific radio button should be selected
                            if (el.value === autofillValue) {
                                el.checked = true;
                                // Dispatch change event to trigger linked textbox creation
                                const changeEvent = new Event('change', { bubbles: true });
                                el.dispatchEvent(changeEvent);
                            } else {
                                el.checked = false;
                            }
                        } else {
                            // For checkboxes, use the boolean value
                            const wasChecked = el.checked;
                            el.checked = !!autofillValue;
                            // Dispatch change event if checkbox state changed to trigger linked textbox creation
                            if (el.checked !== wasChecked) {
                                const changeEvent = new Event('change', { bubbles: true });
                                el.dispatchEvent(changeEvent);
                            }
                        }
                    } else {
                        el.value = autofillValue;
                        // Dispatch input and change events for text inputs to trigger linked textbox syncing
                        if (el.tagName === 'INPUT' && (el.type === 'text' || el.type === 'number' || !el.type)) {
                            const inputEvent = new Event('input', { bubbles: true });
                            el.dispatchEvent(inputEvent);
                            const changeEvent = new Event('change', { bubbles: true });
                            el.dispatchEvent(changeEvent);
                        }
                        // If this is a select element (dropdown), trigger change event to update conditional logic
                        if (el.tagName === 'SELECT') {
                            // Trigger change event to call dropdownMirror and update conditional logic
                            const changeEvent = new Event('change', { bubbles: true });
                            el.dispatchEvent(changeEvent);
                        }
                    }
                    // Debug successful autofill
                    if (el.name && isConditionalField) {
                    }
                }
            });
            // ðŸ”§ NEW: Additional delayed autofill with longer delay for stubborn fields
            setTimeout(() => {
                const stubbornFields = getFormFields();
                stubbornFields.forEach(el => {
                    // Check both by name and by ID for autofill
                    let autofillValue = null;
                    if (mappedData.hasOwnProperty(el.name)) {
                        autofillValue = mappedData[el.name];
                    } else if (el.id && mappedData.hasOwnProperty(el.id)) {
                        autofillValue = mappedData[el.id];
                    }
                    // Only process fields that have autofill data but are still empty
                    if (autofillValue !== null && (!el.value || el.value === '') && el.type !== 'checkbox' && el.type !== 'radio') {
                        el.value = autofillValue;
                        // Dispatch input and change events for text inputs to trigger linked textbox syncing
                        if (el.tagName === 'INPUT' && (el.type === 'text' || el.type === 'number' || !el.type)) {
                            const inputEvent = new Event('input', { bubbles: true });
                            el.dispatchEvent(inputEvent);
                            const changeEvent = new Event('change', { bubbles: true });
                            el.dispatchEvent(changeEvent);
                        }
                        // If this is a select element (dropdown), trigger change event to update conditional logic
                        if (el.tagName === 'SELECT') {
                            // Trigger change event to call dropdownMirror and update conditional logic
                            const changeEvent = new Event('change', { bubbles: true });
                            el.dispatchEvent(changeEvent);
                        }
                    } else if (autofillValue !== null && el.type === 'checkbox' && !el.checked) {
                        el.checked = !!autofillValue;
                    }
                });
            }, 1000); // Additional 1 second delay for stubborn fields
        }, 2000); // Wait 2 seconds for conditional fields to be created
        // ðŸ”§ NEW: Clear autofill flag after fallback autofill is complete
        setTimeout(() => {
            window.isInitialAutofill = false;
            // ðŸ”§ NEW: Restore prefill values for any blank fields after Firebase autofill
            if (window.unifiedFieldsMap) {
                Object.keys(window.unifiedFieldsMap).forEach(questionId => {
                    const fields = window.unifiedFieldsMap[questionId];
                    if (Array.isArray(fields)) {
                        fields.forEach(field => {
                            // Handle both label and amount fields
                            if ((field.type === 'label' || field.type === 'amount') && field.nodeId) {
                                // Find all input fields that match this nodeId pattern
                                // For numberedDropdown: field.nodeId + "_" + number (e.g., "how_many_extra_defendants_name_1")
                                // For multipleTextboxes: exact match (e.g., "example_name")
                                const inputsWithSuffix = document.querySelectorAll('input[id^="' + field.nodeId + '_"]');
                                const exactMatchInput = document.getElementById(field.nodeId);
                                // Combine both results
                                const allInputs = [];
                                inputsWithSuffix.forEach(input => allInputs.push(input));
                                if (exactMatchInput && !allInputs.includes(exactMatchInput)) {
                                    allInputs.push(exactMatchInput);
                                }
                                allInputs.forEach(input => {
                                    // Extract entry number from input ID
                                    // For numberedDropdown: "how_many_extra_defendants_name_1" â†’ "1"
                                    // For multipleTextboxes: "example_name" â†’ null (treat as entry 1)
                                    let entryNumber = null;
                                    if (input.id === field.nodeId) {
                                        // Exact match (multipleTextboxes) - treat as entry 1
                                        entryNumber = '1';
                                    } else {
                                        // Has suffix (numberedDropdown) - extract entry number
                                        // Check if input.id starts with field.nodeId + "_" and extract the number
                                        const prefix = field.nodeId + '_';
                                        if (input.id.startsWith(prefix)) {
                                            const suffix = input.id.substring(prefix.length);
                                            // Check if suffix is all digits
                                            if (/^d+$/.test(suffix)) {
                                                entryNumber = suffix;
                                            }
                                        }
                                    }
                                    // Only set prefill if the field is empty or blank
                                    if (!input.value || input.value.trim() === '') {
                                        let prefillValue = null;
                                        // First, check for conditional prefills
                                        if (field.conditionalPrefills && Array.isArray(field.conditionalPrefills) && entryNumber) {
                                            const matchingConditional = field.conditionalPrefills.find(cp => cp.trigger == entryNumber);
                                            if (matchingConditional && matchingConditional.value) {
                                                prefillValue = replaceUrlParametersInText(matchingConditional.value);
                                            }
                                        }
                                        // If no conditional prefill matched, use regular prefill (only for label fields)
                                        if (!prefillValue && field.type === 'label' && field.prefill) {
                                            prefillValue = replaceUrlParametersInText(field.prefill);
                                        }
                                        // Apply the prefill value if we found one
                                        if (prefillValue) {
                                            input.value = prefillValue;
                                        } else {
                                        }
                                    } else {
                                    }
                                });
                            }
                        });
                    }
                });
            } else {
            }
            // ðŸ”§ NEW: Update all hidden address fields after autofill completes
            if (typeof updateAllHiddenAddressFields === 'function') {
                updateAllHiddenAddressFields();
            }
            // ðŸ”§ NEW: Update all linked checkboxes after autofill completes
            if (typeof window.updateAllLinkedCheckboxes === 'function') {
                window.updateAllLinkedCheckboxes();
            }
            // Also update inverse checkboxes after autofill
            if (typeof window.updateAllInverseCheckboxes === 'function') {
                window.updateAllInverseCheckboxes();
            }
            // ðŸ”§ NEW: Create hidden checkboxes for any autofilled radio buttons in numbered dropdowns
            const autofilledRadioButtons = document.querySelectorAll('input[type="radio"][id*="_radio"]:checked');
            autofilledRadioButtons.forEach(radio => {
                // Create hidden checkbox for the selected radio button
                const originalNodeId = radio.id.replace('_radio', '');
                if (typeof createHiddenCheckboxForRadio === 'function') {
                    createHiddenCheckboxForRadio(originalNodeId, radio.name, radio.value);
                }
                // Extract entry number from radio name (format: "radio_group_ENTRYNUMBER")
                const entryNumberMatch = radio.name.match(/radio_group_(d+)/);
                if (entryNumberMatch) {
                    const entryNumber = entryNumberMatch[1];
                    // Dispatch radioGroupChanged event to trigger conditional logic re-evaluation
                    window.dispatchEvent(new CustomEvent('radioGroupChanged', {
                        detail: { entryNumber: parseInt(entryNumber), radioGroup: radio.name }
                    }));
                }
            });
        }, 2000); // 2 second delay to ensure fallback autofill completes
            } catch (e) {
            }
        }
        // Helper: check if an answer would trigger a jump to the end
        function wouldTriggerJumpToEnd(element, answerValue) {
            if (!jumpLogics || jumpLogics.length === 0) return false;
            // Find the question ID for this element
            let questionId = null;
            for (const [qId, nameId] of Object.entries(questionNameIds)) {
                if (element.name === nameId || element.id === nameId) {
                    questionId = qId;
                    break;
                }
            }
            if (!questionId) return false;
            // Check if there's a jump logic for this question that would go to 'end'
            const relevantJumps = jumpLogics.filter(jl => jl.questionId === questionId);
            for (const jl of relevantJumps) {
                if (jl.jumpTo.toLowerCase() === 'end') {
                    // Check if the answer matches the jump condition
                    if (jl.questionType === 'dropdown' || jl.questionType === 'radio' || jl.questionType === 'numberedDropdown') {
                        if (answerValue.toString().toLowerCase() === jl.jumpOption.trim().toLowerCase()) {
                            return true;
                        }
                    } else if (jl.questionType === 'checkbox') {
                        if (answerValue.toString().toLowerCase() === jl.jumpOption.trim().toLowerCase()) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        // Helper: wipe answers
        function wipeAnswers() {
            if (!isUserLoggedIn || !userId) return;
            db.collection('users').doc(userId).collection('formAnswers').doc(formId).delete();
        }
        // Attach listeners to all fields
        function attachAutosaveListeners() {
            const fields = getFormFields();
            fields.forEach(el => {
                el.addEventListener('input', function() {
                    if (isUserLoggedIn) {
                        saveAnswers(); // This is now debounced
                    } else {
                        saveAnswersToLocalStorage();
                    }
                    // Update full name if first or last name changed
                    if (el.id === 'user_firstname' || el.id === 'user_lastname') {
                        if (typeof updateUserFullName === 'function') {
                            updateUserFullName();
                        }
                    }
                    // Update address fields if any address field changed
                    if (el.id === 'user_street' || el.id === 'user_city' || el.id === 'user_state' || el.id === 'user_zip') {
                        if (typeof updateUserAddressFields === 'function') {
                            updateUserAddressFields();
                        }
                    }
                });
                el.addEventListener('change', function() {
                    if (isUserLoggedIn) {
                        saveAnswers(true); // Save immediately on change (dropdowns, checkboxes, etc.)
                    } else {
                        saveAnswersToLocalStorage();
                    }
                    // Update full name if first or last name changed
                    if (el.id === 'user_firstname' || el.id === 'user_lastname') {
                        if (typeof updateUserFullName === 'function') {
                            updateUserFullName();
                        }
                    }
                    // Update address fields if any address field changed
                    if (el.id === 'user_street' || el.id === 'user_city' || el.id === 'user_state' || el.id === 'user_zip') {
                        if (typeof updateUserAddressFields === 'function') {
                            updateUserAddressFields();
                        }
                    }
                });
            });
            // ðŸ”§ REMOVED: Periodic autosave interval - now using debounced saves on input/change events
            // This prevents overwhelming Firestore with too many write requests
        }
        // Cart Modal Logic - now handled by global functions outside Firebase IIFE
        // Helper: save answers to localStorage for non-logged-in users
        function saveAnswersToLocalStorage() {
            try {
                // ðŸ”§ NEW: Prevent blank values from being saved in first 3 seconds
                if (window.preventBlankSaves) {
                    return;
                }
                const fields = getFormFields();
                const answers = {};
                fields.forEach(el => {
                    if (el.type === 'checkbox') {
                        // For checkboxes, save true/false
                        answers[el.name] = el.checked;
                    } else if (el.type === 'radio') {
                        // For radio buttons, save the selected value or null if none selected
                        const selectedRadio = document.querySelector('input[name="' + el.name + '"]:checked');
                        answers[el.name] = selectedRadio ? selectedRadio.value : null;
                    } else {
                        // For other fields, save the value
                        answers[el.name] = el.value;
                    }
                });
                localStorage.setItem('formData_' + formId, JSON.stringify(answers));
            } catch (e) {
            }
        }
        // Helper: load answers from localStorage for non-logged-in users
        function loadAnswersFromLocalStorage() {
            try {
                const savedData = localStorage.getItem('formData_' + formId);
                if (savedData) {
                    const data = JSON.parse(savedData);
                    const fields = getFormFields();
                    fields.forEach(el => {
                        if (data.hasOwnProperty(el.name)) {
                            if (el.type === 'checkbox') {
                                el.checked = !!data[el.name];
                            } else if (el.type === 'radio') {
                                // For radio buttons, set the value and check the matching radio button
                                if (data[el.name] && el.value === data[el.name]) {
                                    el.checked = true;
                            } else {
                                    el.checked = false;
                                }
                            } else {
                                // Skip current_date field and any field marked as protected - they should be set dynamically
                                if (el.id !== 'current_date' && el.name !== 'current_date' && !el.hasAttribute('data-protected')) {
                                el.value = data[el.name];
                                }
                            }
                        }
                    });
                    // Update full name and address fields after autofilling with delay to ensure DOM is ready
                    setTimeout(() => {
                        if (typeof updateUserFullName === 'function') {
                            updateUserFullName();
                        }
                        if (typeof updateUserAddressFields === 'function') {
                            updateUserAddressFields();
                        }
                        // Always set current_date to today's date after autofill
                        if (typeof setCurrentDate === 'function') {
                            setCurrentDate();
                        }
                    }, 2000);
                    // Trigger visibility updates for dependent questions
                    setTimeout(() => {
                        // Trigger change events on all autofilled elements to ensure conditional logic runs
                        const fields = getFormFields();
                        fields.forEach(el => {
                            if (el.value || el.checked) {
                                const event = new Event('change', { bubbles: true });
                                el.dispatchEvent(event);
                            }
                        });
                        // Also call the global visibility updates function
                        if (typeof triggerVisibilityUpdates === 'function') {
                            triggerVisibilityUpdates();
                        }
                        // Trigger numbered dropdown textbox generation for any numbered dropdowns that were autofilled
                        fields.forEach(el => {
                            if (el.tagName === 'SELECT' && el.id.startsWith('answer') && el.value) {
                                const questionId = el.id.replace('answer', '');
                                if (typeof showTextboxLabels === 'function') {
                                    showTextboxLabels(questionId, el.value);
                                }
                                if (typeof updateHiddenCheckboxes === 'function') {
                                    updateHiddenCheckboxes(questionId, el.value);
                                }
                            }
                        });
                        // Trigger state hidden field updates for any state dropdowns that were autofilled
                        fields.forEach(el => {
                            if (el.tagName === 'SELECT' && el.id && el.value && el.classList.contains('address-select')) {
                                // This is a state dropdown that was autofilled
                                const hiddenFullId = el.id + '_hidden'; // Add _hidden suffix to avoid conflict with dropdown
                                const hiddenShortId = window.toShortIdFromBase(el.id);
                                if (typeof updateStateHiddenFields === 'function') {
                                    updateStateHiddenFields(el, hiddenFullId, hiddenShortId);
                                }
                            }
                        });
                        // Trigger hidden checkbox generation for any regular dropdowns that were autofilled
                        fields.forEach(el => {
                            if (el.tagName === 'SELECT' && el.id && !el.id.startsWith('answer') && el.value) {
                                if (typeof dropdownMirror === 'function') {
                                    dropdownMirror(el, el.id);
                                }
                                // Trigger hidden logic for autofilled dropdowns
                                if (typeof updateHiddenLogic === 'function') {
                                    updateHiddenLogic(el.id, el.value);
                                }
                            }
                        });
                        // Create hidden checkboxes for all autofilled dropdowns
                        if (typeof createHiddenCheckboxesForAutofilledDropdowns === 'function') {
                            createHiddenCheckboxesForAutofilledDropdowns();
                        }
                        // Trigger line splitting for autofilled textareas
                        triggerLineSplittingForAutofilledTextareas();
                        // Trigger paragraph limit checking for autofilled textareas
                        triggerParagraphLimitCheckForAutofilledTextareas();
                        // Second autofill pass for dynamically generated textbox inputs
                        // Use a longer delay to ensure textbox inputs are fully generated
                        setTimeout(() => {
                            const allFields = getFormFields();
                            // Also try to find fields by ID directly as a fallback
                            const fieldsById = {};
                            allFields.forEach(el => {
                                if (el.id) {
                                    fieldsById[el.id] = el;
                                }
                            });
                            allFields.forEach(el => {
                                if (data.hasOwnProperty(el.name)) {
                                    if (el.type === 'checkbox' || el.type === 'radio') {
                                        el.checked = !!data[el.name];
                                    } else {
                                        // Skip current_date field and any field marked as protected - they should be set dynamically
                                        if (el.id !== 'current_date' && el.name !== 'current_date' && !el.hasAttribute('data-protected')) {
                                        el.value = data[el.name];
                                        }
                                    }
                                }
                            });
                            // Additional pass: try to autofill by ID for any fields that might have been missed
                            Object.keys(data).forEach(fieldName => {
                                const fieldById = fieldsById[fieldName];
                                if (fieldById && !fieldById.value && data[fieldName]) {
                                    if (fieldById.type === 'checkbox' || fieldById.type === 'radio') {
                                        fieldById.checked = !!data[fieldName];
                                    } else {
                                        fieldById.value = data[fieldName];
                                    }
                                }
                            });
                            // Trigger line splitting again after the second autofill pass
                            triggerLineSplittingForAutofilledTextareas();
                            // Trigger paragraph limit checking again after the second autofill pass
                            triggerParagraphLimitCheckForAutofilledTextareas();
                            // Trigger state hidden field updates for any state dropdowns that were autofilled in second pass
                            allFields.forEach(el => {
                                if (el.tagName === 'SELECT' && el.id && el.value && el.classList.contains('address-select')) {
                                    // This is a state dropdown that was autofilled
                                    const hiddenFullId = el.id + '_hidden'; // Add _hidden suffix to avoid conflict with dropdown
                                    const hiddenShortId = window.toShortIdFromBase(el.id);
                                    if (typeof updateStateHiddenFields === 'function') {
                                        updateStateHiddenFields(el, hiddenFullId, hiddenShortId);
                                    }
                                }
                            });
                            // Always set current_date to today's date after second autofill pass
                            if (typeof setCurrentDate === 'function') {
                                setCurrentDate();
                            }
                        }, 1500);
                    }, 2000);
                    // ðŸ”§ NEW: Delayed autofill for conditional fields that are created after initial autofill
                    setTimeout(() => {
                        const conditionalFields = getFormFields();
                        conditionalFields.forEach(el => {
                            // Check both by name and by ID for autofill
                            let autofillValue = null;
                            if (data.hasOwnProperty(el.name)) {
                                autofillValue = data[el.name];
                            } else if (el.id && data.hasOwnProperty(el.id)) {
                                autofillValue = data[el.id];
                            }
                            // Debug conditional fields that are part of trigger sequences
                            const isConditionalField = isFieldPartOfTriggerSequence(el.name, el.id);
                            if (el.name && isConditionalField) {
                            }
                            if (autofillValue !== null) {
                                // Skip current_date field - it should be set dynamically
                                if (el.id === 'current_date' || el.name === 'current_date') {
                                    return;
                                }
                                if (el.type === 'checkbox' || el.type === 'radio') {
                                    if (el.type === 'radio') {
                                        // For radio buttons, we need to check if this specific radio button should be selected
                                        if (el.value === autofillValue) {
                                            el.checked = true;
                                            // Dispatch change event to trigger linked textbox creation
                                            const changeEvent = new Event('change', { bubbles: true });
                                            el.dispatchEvent(changeEvent);
                                        } else {
                                            el.checked = false;
                                        }
                                    } else {
                                        // For checkboxes, use the boolean value
                                        const wasChecked = el.checked;
                                        el.checked = !!autofillValue;
                                        // Dispatch change event if checkbox state changed to trigger linked textbox creation
                                        if (el.checked !== wasChecked) {
                                            const changeEvent = new Event('change', { bubbles: true });
                                            el.dispatchEvent(changeEvent);
                                        }
                                    }
                                } else {
                                    el.value = autofillValue;
                                    // Dispatch input and change events for text inputs to trigger linked textbox syncing
                                    if (el.tagName === 'INPUT' && (el.type === 'text' || el.type === 'number' || !el.type)) {
                                        const inputEvent = new Event('input', { bubbles: true });
                                        el.dispatchEvent(inputEvent);
                                        const changeEvent = new Event('change', { bubbles: true });
                                        el.dispatchEvent(changeEvent);
                                    }
                                    // If this is a select element (dropdown), trigger change event to update conditional logic
                                    if (el.tagName === 'SELECT') {
                                        // Trigger change event to call dropdownMirror and update conditional logic
                                        const changeEvent = new Event('change', { bubbles: true });
                                        el.dispatchEvent(changeEvent);
                                    }
                                }
                                // Debug successful autofill
                                if (el.name && isConditionalField) {
                                }
                            }
                        });
                        // ðŸ”§ NEW: Additional delayed autofill with longer delay for stubborn fields
                        setTimeout(() => {
                            const stubbornFields = getFormFields();
                            stubbornFields.forEach(el => {
                                // Check both by name and by ID for autofill
                                let autofillValue = null;
                                if (data.hasOwnProperty(el.name)) {
                                    autofillValue = data[el.name];
                                } else if (el.id && data.hasOwnProperty(el.id)) {
                                    autofillValue = data[el.id];
                                }
                                // Only process fields that have autofill data but are still empty
                                if (autofillValue !== null && (!el.value || el.value === '') && el.type !== 'checkbox' && el.type !== 'radio') {
                                    el.value = autofillValue;
                                    // Dispatch input and change events for text inputs to trigger linked textbox syncing
                                    if (el.tagName === 'INPUT' && (el.type === 'text' || el.type === 'number' || !el.type)) {
                                        const inputEvent = new Event('input', { bubbles: true });
                                        el.dispatchEvent(inputEvent);
                                        const changeEvent = new Event('change', { bubbles: true });
                                        el.dispatchEvent(changeEvent);
                                    }
                                    // If this is a select element (dropdown), trigger change event to update conditional logic
                                    if (el.tagName === 'SELECT') {
                                        // Trigger change event to call dropdownMirror and update conditional logic
                                        const changeEvent = new Event('change', { bubbles: true });
                                        el.dispatchEvent(changeEvent);
                                    }
                                } else if (autofillValue !== null && el.type === 'checkbox' && !el.checked) {
                                    el.checked = !!autofillValue;
                                    // Dispatch change event to trigger linked textbox creation
                                    if (el.checked) {
                                        const changeEvent = new Event('change', { bubbles: true });
                                        el.dispatchEvent(changeEvent);
                                    }
                                }
                            });
                        }, 1000); // Additional 1 second delay for stubborn fields
                    }, 3000); // Wait 3 seconds for conditional fields to be created
                }
            } catch (e) {
            }
        }
        // On auth state change
        firebase.auth().onAuthStateChanged(function(user) {
            isUserLoggedIn = !!user;
            userId = user ? user.uid : null;
            if (isUserLoggedIn) {
                const params = new URLSearchParams(window.location.search);
                if (params.get('payment') === 'success') {
                    loadAnswers().then(() => {
                        processAllPdfs().then(() => {
                            wipeAnswers();
                            window.history.replaceState({}, document.title, "/" + pdfOutputFileName);
                            navigateSection('end');
                        });
                    });
                } else {
                    loadAnswers().then(attachAutosaveListeners);
                }
            } else {
                // For non-logged-in users, try to load from localStorage
                loadAnswersFromLocalStorage();
                attachAutosaveListeners();
            }
        });
        // Form submission now shows thank you message first, then user can continue to cart
        // Update cart count
        function updateCartCount() {
            const cartCountElement = document.getElementById('cart-count');
            if (cartCountElement && typeof getCartCount === 'function') {
                const count = getCartCount();
                cartCountElement.textContent = count;
                cartCountElement.style.display = count > 0 ? 'inline' : 'none';
            }
        }
        // Update cart count on page load and periodically
        document.addEventListener('DOMContentLoaded', function() {
            updateCartCount();
            // Update cart count every 5 seconds
            setInterval(updateCartCount, 5000);
        });
    });
})();
    // Header functionality
    document.addEventListener('DOMContentLoaded', function() {
        // Use existing Firebase instance instead of creating a new one
        if (typeof firebase !== 'undefined' && firebase.apps.length > 0) {
            const auth = firebase.auth();
            const db = firebase.firestore();
            // Function to update button display based on auth state
            function updateAuthButtons(user) {
                const signInBtn = document.getElementById('sign-in-btn');
                const logoutBtn = document.getElementById('logout-btn');
                if (user) {
                    // User is signed in
                    if (signInBtn) signInBtn.style.display = 'none';
                    if (logoutBtn) logoutBtn.style.display = 'inline-block';
                } else {
                    // User is signed out
                    if (signInBtn) signInBtn.style.display = 'inline-block';
                    if (logoutBtn) logoutBtn.style.display = 'none';
                }
            }
            // Authentication state observer
            auth.onAuthStateChanged(function(user) {
                updateAuthButtons(user);
            });
            // Check current auth state immediately with a small delay to ensure Firebase is ready
            setTimeout(function() {
                const currentUser = auth.currentUser;
                updateAuthButtons(currentUser);
            }, 200);
            // Logout functionality
            const logoutBtn = document.getElementById('logout-btn');
            if (logoutBtn) {
                logoutBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    auth.signOut().then(function() {
                        window.location.href = '../index.html';
                    }).catch(function(error) {
                    });
                });
            }
            // Dropdown for Forms nav
            const formsWrapper = document.getElementById('forms-dropdown-wrapper');
            const formsLink = document.getElementById('forms-nav-link');
            const dropdownMenu = document.getElementById('forms-dropdown-menu');
            let dropdownOpen = false;
            function openDropdown() {
                formsWrapper.classList.add('open');
                dropdownOpen = true;
            }
            function closeDropdown() {
                formsWrapper.classList.remove('open');
                dropdownOpen = false;
            }
            if (formsLink) {
                formsLink.addEventListener('click', function(e) {
                    e.preventDefault();
                    dropdownOpen ? closeDropdown() : openDropdown();
                });
            }
            document.addEventListener('mousedown', function(e) {
                if (formsWrapper && !formsWrapper.contains(e.target)) {
                    closeDropdown();
                }
            });
            // Keyboard accessibility
            if (formsLink) {
                formsLink.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        dropdownOpen ? closeDropdown() : openDropdown();
                    }
                });
            }
            // Update cart count badge in header
            function updateCartCountBadge() {
                const cartCountElement = document.getElementById('cart-count-badge');
                if (cartCountElement) {
                    let count = 0;
                    // Try to get count from getCartCount function first
                    if (typeof getCartCount === 'function') {
                        count = getCartCount();
                    } else {
                        // Fallback to localStorage
                        try {
                            const cartData = localStorage.getItem('formwiz_cart');
                            if (cartData) {
                                const cart = JSON.parse(cartData);
                                count = Array.isArray(cart) ? cart.length : 0;
                            }
                        } catch (e) {
                            count = 0;
                        }
                    }
                    // Always update the text content, even if count is 0
                    cartCountElement.textContent = count;
                    if (count > 0) {
                        cartCountElement.style.display = 'flex';
                    } else {
                        cartCountElement.style.display = 'none';
                    }
                }
            }
            // Also update auth buttons when cart count updates
            function updateAuthButtonsAndCart() {
                const currentUser = auth.currentUser;
                updateAuthButtons(currentUser);
                updateCartCountBadge();
            }
            // Initialize auth buttons and cart count badge with a small delay to ensure DOM is ready
            setTimeout(updateAuthButtonsAndCart, 100);
            // Update more frequently to ensure cart count is always current
            setInterval(updateAuthButtonsAndCart, 2000);
            // Also update cart count immediately when page loads
            setTimeout(updateCartCountBadge, 500);
            // Sliding Cart Menu
            const cartIconLink = document.getElementById('cart-icon-link');
            const cartOverlay = document.getElementById('cart-overlay');
            const cartSideMenu = document.getElementById('cart-side-menu');
            const cartCloseBtn = document.getElementById('cart-close-btn');
            function openCart() {
                cartOverlay.classList.add('active');
                cartSideMenu.classList.add('active');
                document.body.style.overflow = 'hidden'; // Prevent scrolling when menu is open
                // Update cart content based on auth state
                updateCartContent();
            }
            function closeCart() {
                cartOverlay.classList.remove('active');
                cartSideMenu.classList.remove('active');
                document.body.style.overflow = ''; // Restore scrolling
            }
            if (cartIconLink) {
                cartIconLink.addEventListener('click', function(e) {
                    e.preventDefault();
                    openCart();
                });
            }
            if (cartCloseBtn) {
                cartCloseBtn.addEventListener('click', closeCart);
            }
            if (cartOverlay) {
                cartOverlay.addEventListener('click', function(e) {
                    if (e.target === cartOverlay) {
                        closeCart();
                    }
                });
            }
            // Update cart content based on authentication state
            function updateCartContent() {
                const cartMessage = document.getElementById('cart-message');
                const cartDescription = document.getElementById('cart-description');
                const cartSignupBtn = document.getElementById('cart-signup-btn');
                const cartItemsList = document.getElementById('cart-items-list');
                const cartCheckoutBtn = document.getElementById('cart-checkout-btn');
                const cartIconLarge = document.querySelector('.cart-icon-large');
                if (auth.currentUser) {
                    // User is signed in - show cart items
                    if (cartMessage) cartMessage.textContent = 'Your Cart';
                    if (cartDescription) cartDescription.textContent = 'Review your selected forms and proceed to checkout.';
                    if (cartSignupBtn) cartSignupBtn.style.display = 'none';
                    if (cartIconLarge) cartIconLarge.textContent = 'ðŸ›’';
                    // Load and display cart items
                    loadCartItems();
                } else {
                    // User is not signed in - show signup message
                    if (cartMessage) cartMessage.textContent = 'Create an account to start shopping!';
                    if (cartDescription) cartDescription.textContent = 'To add forms to your cart and make purchases, you\'ll need to create a FormStar account. Sign up now to access our complete library of legal forms and start simplifying your paperwork.';
                    if (cartSignupBtn) cartSignupBtn.style.display = 'inline-block';
                    if (cartItemsList) cartItemsList.style.display = 'none';
                    if (cartCheckoutBtn) cartCheckoutBtn.style.display = 'none';
                    if (cartIconLarge) cartIconLarge.textContent = 'ðŸ›’';
                }
            }
            // Load cart items for logged-in users
            async function loadCartItems() {
                const cartItemsList = document.getElementById('cart-items-list');
                const cartCheckoutBtn = document.getElementById('cart-checkout-btn');
                if (!cartItemsList || !auth.currentUser) {
                    return;
                }
                try {
                    // Get cart data from cookies or localStorage
                    function getCookie(name) {
                        const value = '; ' + document.cookie;
                        const parts = value.split('; ' + name + '=');
                        if (parts.length === 2) return parts.pop().split(';').shift();
                        return null;
                    }
                    const cartData = getCookie('formwiz_cart') || localStorage.getItem('formwiz_cart');
                    let cart = [];
                    if (cartData) {
                        try {
                            // Decode URL-encoded cart data if it comes from cookie
                            let decodedCartData = cartData;
                            if (cartData.startsWith('%')) {
                                decodedCartData = decodeURIComponent(cartData);
                            }
                            cart = JSON.parse(decodedCartData);
                        } catch (e) {
                        }
                    }
                    if (cart.length === 0) {
                        cartItemsList.innerHTML = '<p style="color:#7f8c8d;font-style:italic;">Your cart is empty</p>';
                        cartItemsList.style.display = 'block';
                        if (cartCheckoutBtn) cartCheckoutBtn.style.display = 'none';
                        return;
                    }
                    // Fetch Stripe prices for cart items
                    async function fetchStripePrice(priceId) {
                        try {
                            const response = await fetch('/stripe-price/' + priceId);
                            if (!response.ok) return null;
                            const data = await response.json();
                            return data && data.unit_amount != null ? (data.unit_amount / 100).toFixed(2) : null;
                        } catch (e) {
                            return null;
                        }
                    }
                    // Render cart items
                    let total = 0;
                    let itemsHtml = '';
                    let itemIndex = 0;
                    for (const item of cart) {
                        const price = await fetchStripePrice(item.priceId);
                        const itemPrice = price ? parseFloat(price) : 0;
                        total += itemPrice;
                        // Defendant and county fields
                        let defendantHtml = '';
                        let countyHtml = '';
                        if (item.defendantName) {
                            const capName = String(item.defendantName)
                              .split(/s+/)
                              .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
                              .join(' ');
                            defendantHtml = '<div style=\"color:#e74c3c;font-weight:600;\">Defendant: ' + capName + '</div>';
                        }
                        if (item.countyName) {
                            const countyDisplay = item.countyName.toLowerCase().includes('county') ? item.countyName : item.countyName + ' County';
                            countyHtml = '<div style="color:#7f8c8d;">' + countyDisplay + '</div>';
                        }
                        // Use the proper display name instead of the filename
                        let displayTitle = item.title || 'Form';
                        if (item.formId === 'sc120' || item.formId === 'SC-120') {
                            displayTitle = 'SC-120';
                        } else if (item.formId === 'sc500' || item.formId === 'SC-500') {
                            displayTitle = 'SC-500';
                        }
                        itemsHtml +=
     '<div class="cart-item">' +
       '<div class="cart-item-info">' +
         '<div class="cart-item-title">' + displayTitle + '</div>' +
         defendantHtml +
         countyHtml +
       '</div>' +
       '<div class="cart-item-price" style="margin-right: 12px;">$' + itemPrice.toFixed(2) + '</div>' +
       '<button class="remove-item" title="Remove" data-cart-index="' + itemIndex + '">' +
         '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6l-2 14H7L5 6"></path><path d="M10 11v6"></path><path d="M14 11v6"></path><path d="M5 6V4a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2"></path></svg>' +
       '</button>' +
     '</div>';
                        itemIndex++;
                    }
                    cartItemsList.innerHTML = itemsHtml;
                    cartItemsList.style.display = 'block';
                    // Remove item event listeners
                    const removeButtons = cartItemsList.querySelectorAll('.remove-item');
                    removeButtons.forEach(btn => {
                      btn.addEventListener('click', function(e) {
                        e.preventDefault();
                        const idx = parseInt(btn.getAttribute('data-cart-index'));
                        if (!isNaN(idx)) {
                          cart.splice(idx, 1);
                          // Save updated cart
                          document.cookie = 'formwiz_cart=' + encodeURIComponent(JSON.stringify(cart)) + ';path=/;max-age=2592000';
                          localStorage.setItem('formwiz_cart', JSON.stringify(cart));
                          loadCartItems();
                        }
                      });
                    });
                    if (cartCheckoutBtn) {
                        cartCheckoutBtn.textContent = 'Checkout - $' + total.toFixed(2);
                        cartCheckoutBtn.style.display = 'block';
                        cartCheckoutBtn.onclick = function() {
                            window.location.href = '/Pages/cart.html';
                        };
                    }
                } catch (error) {
                    cartItemsList.innerHTML = '<p style="color:#e74c3c;">Error loading cart items</p>';
                    cartItemsList.style.display = 'block';
                }
            }
            // Keyboard accessibility for cart menu
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeCart();
                }
            });
        }
    });
// Helper function to create styled address input
function createAddressInput(id, label, index, type = 'text', prefill = '') {
    const inputType = type === 'number' ? 'number' : 'text';
    const placeholder = label; // Remove the index number from placeholder
    const valueAttr = prefill ? ' value="' + prefill.replace(/"/g, '&quot;') + '"' : '';
    return '<div class="address-field">' +
           '<input type="' + inputType + '" ' +
           'id="' + id + '" ' +
           'name="' + id + '" ' +
           'placeholder="' + placeholder + '" ' +
           'class="address-input"' + valueAttr + '>' +
           '</div>';
}
</script>
<!-- Debug Menu -->
<div id="debugMenu" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 99999; font-family: 'Montserrat', sans-serif;">
  <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); width: 90%; max-width: 800px; max-height: 80%; overflow: hidden; display: flex; flex-direction: column;">
    <!-- Header -->
    <div style="background: linear-gradient(90deg, #4f8cff 0%, #38d39f 100%); color: white; padding: 20px; display: flex; justify-content: space-between; align-items: center; position: relative;">
      <h2 style="margin: 0; font-size: 1.5em; font-weight: 700;">ðŸ” Form Debug Menu</h2>
      <button id="closeDebugMenu" style="position: absolute; top: 10px; right: 10px; background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; padding: 5px; border-radius: 50%; width: 35px; height: 35px; display: flex; align-items: center; justify-content: center;">&times;</button>
    </div>
    <!-- Search Bar -->
    <div style="padding: 20px; border-bottom: 1px solid #eee;">
      <input type="text" id="debugSearch" placeholder="Search inputs by name, ID, or value... (supports partial word matching)" style="width: 100%; padding: 12px 16px; border: 2px solid #e0e7ef; border-radius: 8px; font-size: 16px; box-sizing: border-box;">
      <!-- Filter Controls -->
      <div style="display: flex; gap: 15px; margin-top: 15px; align-items: center; flex-wrap: wrap;">
        <div style="flex: 1; min-width: 200px;">
          <label for="debugTypeFilter" style="display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50; font-size: 14px;">Filter by Type:</label>
          <select id="debugTypeFilter" style="width: 100%; padding: 10px 12px; border: 2px solid #e0e7ef; border-radius: 8px; font-size: 14px; background: white; cursor: pointer;">
            <option value="">All Types</option>
            <option value="text">ðŸ“ Text Inputs</option>
            <option value="email">ðŸ“§ Email Inputs</option>
            <option value="tel">ðŸ“ž Phone Inputs</option>
            <option value="number">ðŸ”¢ Number Inputs</option>
            <option value="date">ðŸ“… Date Inputs</option>
            <option value="textarea">ðŸ“„ Text Areas</option>
            <option value="checkbox">â˜‘ï¸ Checkboxes</option>
            <option value="radio">ðŸ”˜ Radio Buttons</option>
            <option value="hidden">ðŸ”’ Hidden Fields</option>
          </select>
        </div>
        <div style="flex-shrink: 0;">
        <button id="exportNamesIdsBtn" style="background: linear-gradient(90deg, #4f8cff 0%, #38d39f 100%); color: white; border: none; padding: 12px 20px; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(79, 140, 255, 0.3);">
          ðŸ“‹ Export Names/IDs
        </button>
        </div>
      </div>
    </div>
    <!-- Content -->
    <div id="debugContent" style="flex: 1; overflow-y: auto; padding: 20px;">
      <!-- Content will be populated by JavaScript -->
    </div>
  </div>
</div>
<script>
// Debug Menu Functionality
let debugMenuVisible = false;
// Show debug menu on Ctrl+Shift
document.addEventListener('keydown', function(e) {
  if (e.ctrlKey && e.shiftKey && !debugMenuVisible) {
    e.preventDefault();
    showDebugMenu();
  }
});
// Close debug menu
document.getElementById('closeDebugMenu').addEventListener('click', hideDebugMenu);
// Click-outside-to-close functionality
document.addEventListener('click', function(event) {
  const debugMenu = document.getElementById('debugMenu');
  // If debug menu is visible
  if (debugMenuVisible) {
    // Check if click is on the overlay background (not on the content area)
    if (event.target === debugMenu) {
      hideDebugMenu();
    }
  }
});
// Close on escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape' && debugMenuVisible) {
    hideDebugMenu();
  }
});
// Tab key navigation - REMOVED: This was causing unwanted form submission when users tried to tab between fields
// Tab key now works normally for navigating between form inputs
// Removed click-outside-to-close functionality - user must use X button
function showDebugMenu() {
  debugMenuVisible = true;
  document.getElementById('debugMenu').style.display = 'block';
  populateDebugContent();
  document.getElementById('debugSearch').focus();
}
function hideDebugMenu() {
  debugMenuVisible = false;
  document.getElementById('debugMenu').style.display = 'none';
}
// Add virtual checkbox entries for dropdown questions
function addVirtualDropdownCheckboxes(inputData) {
  // Find all dropdown/select elements
  const dropdowns = document.querySelectorAll('select');
  dropdowns.forEach(dropdown => {
    if (!dropdown.id) return;
    // Skip debug-related dropdowns
    if (dropdown.id.startsWith('debug')) return;
    // Check if this is a numbered dropdown
    const isNumberedDropdown = dropdown.id.startsWith('answer') && dropdown.querySelector('option[value="1"]');
    if (isNumberedDropdown) {
      // Handle numbered dropdown - generate all possible textbox label combinations
      addNumberedDropdownVirtualEntries(inputData, dropdown);
    } else {
      // Handle regular dropdown - generate checkbox combinations
      addRegularDropdownVirtualEntries(inputData, dropdown);
    }
  });
}
// Create a hidden checkbox in the DOM for virtual checkboxes that should be checked
function createHiddenCheckbox(checkboxId, checkboxName, baseName) {
  // Find the dropdown wrapper or create a container
  let wrap = document.getElementById("dropdowntext_" + baseName);
  if (!wrap) {
    // If no wrapper exists, create one
    wrap = document.createElement("div");
    wrap.id = "dropdowntext_" + baseName;
    wrap.style.display = "none";
    // Find the dropdown element and insert the wrapper after it
    const dropdown = document.getElementById(baseName);
    if (dropdown && dropdown.parentNode) {
      dropdown.parentNode.insertBefore(wrap, dropdown.nextSibling);
    } else {
      // Fallback: append to body
      document.body.appendChild(wrap);
    }
  }
  // Create the hidden checkbox
  const checkboxDiv = document.createElement("div");
  checkboxDiv.style.display = "none";
  checkboxDiv.innerHTML = "<input type='checkbox' id='" + checkboxId + "' name='" + checkboxName + "' checked>" +
                   "<label for='" + checkboxId + "'> " + checkboxName + "</label>";
  wrap.appendChild(checkboxDiv);
}
// Create real hidden checkboxes for all autofilled dropdowns
function createHiddenCheckboxesForAutofilledDropdowns() {
  // Find all dropdown/select elements
  const dropdowns = document.querySelectorAll('select');
  dropdowns.forEach(dropdown => {
    if (!dropdown.id || dropdown.id.startsWith('answer')) return; // Skip numbered dropdowns
    const baseName = dropdown.id;
    const selectedValue = dropdown.value.trim();
    if (selectedValue) {
      // Generate checkbox ID using the same pattern as dropdownMirror
      // Sanitize option value: replace all non-word characters (including spaces) with underscores
      // Use character class [^A-Za-z0-9_] instead of W to avoid backslash escaping issues in template literals
      const idSuffix = selectedValue.replace(/[^A-Za-z0-9_]+/g, "_").toLowerCase().replace(/^_+|_+$/g, '');
      // Check if baseName ends with an entry number (for numbered dropdowns)
      // Format should be: fieldName_optionValue_entryNumber (entry number last)
      const lastUnderscoreIndex = baseName.lastIndexOf('_');
      let checkboxId;
      let checkboxName;
      if (lastUnderscoreIndex !== -1) {
          // Check if the part after last underscore is a number (entry number)
          // Use [0-9] instead of d to avoid backslash escaping issues when embedded in HTML
          const potentialEntryNumber = baseName.substring(lastUnderscoreIndex + 1);
          if (/^[0-9]+$/.test(potentialEntryNumber)) {
              // It's a numbered dropdown: extract field name and entry number
              const fieldName = baseName.substring(0, lastUnderscoreIndex);
              const entryNumber = potentialEntryNumber;
              // Format: fieldName_optionValue_entryNumber (entry number last)
              checkboxId = fieldName + "_" + idSuffix + "_" + entryNumber;
              checkboxName = checkboxId;
          } else {
              // Regular dropdown: keep original format
              checkboxId = baseName + "_" + idSuffix;
              checkboxName = checkboxId;
          }
      } else {
          // No underscore, keep original format
          checkboxId = baseName + "_" + idSuffix;
          checkboxName = checkboxId;
      }
      // Clear any existing hidden checkboxes for this dropdown to prevent stale checks
      const wrap = document.getElementById("dropdowntext_" + baseName);
      if (wrap) {
        while (wrap.firstChild) wrap.removeChild(wrap.firstChild);
      }
      // Check if this checkbox already exists
      const existingCheckbox = document.getElementById(checkboxId);
      if (!existingCheckbox) {
        createHiddenCheckbox(checkboxId, checkboxName, baseName);
      } else {
      }
      // Handle custom hidden logic for this dropdown
      updateHiddenLogic(baseName, selectedValue);
    }
  });
}
// Add virtual entries for regular dropdowns (checkbox combinations)
function addRegularDropdownVirtualEntries(inputData, dropdown) {
  const baseName = dropdown.id;
  const options = dropdown.querySelectorAll('option[value]:not([value=""])');
  options.forEach(option => {
    const optionValue = option.value.trim();
    if (!optionValue) return;
    // Generate checkbox ID using the same pattern as dropdownMirror
    // Sanitize option value: replace all non-word characters (including spaces) with underscores
    // Use character class [^A-Za-z0-9_] instead of W to avoid backslash escaping issues in template literals
    const idSuffix = optionValue.replace(/[^A-Za-z0-9_]+/g, "_").toLowerCase().replace(/^_+|_+$/g, '');
    const checkboxId = baseName + "_" + idSuffix;
    const checkboxName = baseName + "_" + idSuffix;
    // Check if this virtual checkbox already exists in inputData
    const exists = inputData.some(item => item.id === checkboxId);
    if (!exists) {
      // Check if this checkbox actually exists in the DOM (user selected this option)
      const actualCheckbox = document.getElementById(checkboxId);
      // Also check if the dropdown value matches this option (for autofilled dropdowns)
      const isChecked = actualCheckbox ? actualCheckbox.checked : (dropdown.value === optionValue);
      // Add virtual checkbox entry
      inputData.push({
        id: checkboxId,
        name: checkboxName,
        value: isChecked,
        type: 'input',
        inputType: 'checkbox',
        placeholder: '',
        required: false,
        isVirtual: !actualCheckbox, // Only virtual if it doesn't exist in DOM
        dropdownSource: dropdown.id,
        optionValue: optionValue
      });
    }
  });
}
// Add virtual entries for numbered dropdowns (textbox label combinations)
function addNumberedDropdownVirtualEntries(inputData, dropdown) {
  // Extract question ID from dropdown ID (e.g., "answer123" -> "123")
  const questionId = dropdown.id.replace('answer', '');
  // Get the question's Node ID from the question text (this is the base we should use)
  const questionH3 = document.getElementById("question-container-" + questionId)?.querySelector("h3")?.textContent;
  const questionNodeId = questionH3 ? sanitizeQuestionText(questionH3) : dropdown.id;
  // Get the range from the dropdown options
  const options = dropdown.querySelectorAll('option[value]:not([value=""])');
  let maxRange = 0;
  options.forEach(option => {
    const value = parseInt(option.value);
    if (!isNaN(value) && value > maxRange) {
      maxRange = value;
    }
  });
  // Get label information from the global maps
  const labelVals = labelMap[questionId] || [];
  const labelNodeIds = window.labelNodeIdsMap && window.labelNodeIdsMap[questionId] ? window.labelNodeIdsMap[questionId] : [];
  // Generate all possible combinations
  for (let j = 1; j <= maxRange; j++) {
    // Add textbox label combinations
    for (let lblIndex = 0; lblIndex < labelVals.length; lblIndex++) {
      const lbl = labelVals[lblIndex];
      const labelNodeId = labelNodeIds[lblIndex] || "";
      // Use label node ID if provided, otherwise use question Node ID + label + number
      const id = labelNodeId ? 
        labelNodeId + "_" + j : 
        questionNodeId + "_" + j + "_" + sanitizeQuestionText(lbl);
      // Check if this virtual input already exists in inputData
      const exists = inputData.some(item => item.id === id);
      if (!exists) {
        // Check if this input actually exists in the DOM
        const actualInput = document.getElementById(id);
        const value = actualInput ? actualInput.value : '';
        // Add virtual input entry
        inputData.push({
          id: id,
          name: id,
          value: value,
          type: 'input',
          inputType: 'text',
          placeholder: lbl + ' ' + j,
          required: false,
          isVirtual: true,
          dropdownSource: dropdown.id,
          optionValue: j.toString(),
          labelText: lbl
        });
      }
    }
    // Add hidden checkbox combinations (for the numbered dropdown hidden checkboxes)
    const checkboxId = questionNodeId + "_" + j;
    const checkboxExists = inputData.some(item => item.id === checkboxId);
    if (!checkboxExists) {
      // Check if this checkbox actually exists in the DOM
      const actualCheckbox = document.getElementById(checkboxId);
      const isChecked = actualCheckbox ? actualCheckbox.checked : false;
      // Add virtual checkbox entry
      inputData.push({
        id: checkboxId,
        name: checkboxId,
        value: isChecked,
        type: 'input',
        inputType: 'checkbox',
        placeholder: '',
        required: false,
        isVirtual: true,
        dropdownSource: dropdown.id,
        optionValue: j.toString(),
        labelText: 'Hidden checkbox for option ' + j
      });
    }
  }
}
function populateDebugContent() {
  const content = document.getElementById('debugContent');
  const searchInput = document.getElementById('debugSearch');
  const searchTerm = searchInput ? searchInput.value.trim().toLowerCase() : '';
  const typeFilter = document.getElementById('debugTypeFilter').value;
  // Get all form inputs
  const inputs = document.querySelectorAll('input, select, textarea');
  const inputData = [];
  inputs.forEach(input => {
    // Include all inputs that have either an ID or a name (or both)
    // Exclude debug menu's own input fields (debugSearch, debugTypeFilter, and debugTypeFilter_* fields)
    const isDebugField = input.id === 'debugSearch' || input.id === 'debugTypeFilter' || input.id.startsWith('debugTypeFilter_');
    if ((input.id || input.name) && !isDebugField) {
      let value;
      if (input.type === 'checkbox') {
        value = input.checked;
      } else if (input.type === 'date') {
        value = formatDateForDisplay(input.value);
      } else {
        value = input.value;
      }
      const type = input.tagName.toLowerCase();
      const inputType = input.type || 'text';
      inputData.push({
        id: input.id || '',
        name: input.name || '',
        value: value,
        type: type,
        inputType: inputType,
        placeholder: input.placeholder || '',
        required: input.required
      });
    }
  });
  // Add virtual checkbox entries for dropdown questions
  addVirtualDropdownCheckboxes(inputData);
  // Filter by search term and type
  const filteredData = inputData.filter(item => {
    // First check type filter
    if (typeFilter) {
      let itemType = '';
      if (item.inputType === 'text' || item.inputType === 'email' || item.inputType === 'tel' || item.inputType === 'number' || item.inputType === 'date') {
        itemType = item.inputType;
      } else if (item.type === 'select') {
        itemType = 'text'; // Classify dropdowns as text inputs
      } else if (item.type === 'textarea') {
        itemType = 'textarea';
      } else if (item.inputType === 'checkbox') {
        itemType = 'checkbox';
      } else if (item.inputType === 'radio') {
        itemType = 'radio';
      } else if (item.inputType === 'hidden') {
        // Check if this is a state-related hidden field that should be grouped with text inputs
        if (item.id && (item.id.includes('_state') || item.id.includes('_state_short') || item.id.includes('_short_'))) {
          itemType = 'text'; // Classify state-related hidden fields as text inputs
        } else {
          itemType = 'hidden';
        }
      } else {
        itemType = 'text'; // Classify other inputs as text inputs
      }
      if (itemType !== typeFilter) {
        return false;
      }
    }
    // If no search term, return true (type filter already applied)
    if (!searchTerm || searchTerm.length === 0) {
      return true;
    }
    // Helper function to check if all search words are found in text (partial word matching)
    function matchesPartialWords(searchWords, text) {
      if (!text || !searchWords.length) return false;
      const textLower = String(text).toLowerCase();
      const normalizedText = textLower.replace(/[_s]/g, ' ');
      return searchWords.every(word => {
        const wordLower = word.toLowerCase();
        const normalizedWord = wordLower.replace(/[_s]/g, ' ');
        // Check both normalized text (spaces) and original text (underscores)
        return normalizedText.includes(normalizedWord) || textLower.includes(wordLower);
      });
    }
    // Split search term into individual words for partial matching
    // Only split on actual whitespace (spaces, tabs, newlines), not on every character
    // IMPORTANT: Use character classes instead of escape sequences to avoid regex issues in template literals
    // Use [ ] for spaces, explicit tab/newline characters, or a simple space check
    let searchWords = [];
    // First, check if the search term contains any whitespace
    // Use explicit character checks instead of regex escape sequences
    const hasWhitespace = searchTerm.includes(' ') || searchTerm.includes(String.fromCharCode(9)) || searchTerm.includes(String.fromCharCode(10)) || searchTerm.includes(String.fromCharCode(13));
    if (hasWhitespace) {
      // Only split if there's actual whitespace
      // Use character class [ ] for space, and explicit codes for tab (9), newline (10), carriage return (13)
      // Build regex pattern using character codes to avoid escape sequence issues
      const spaceChar = ' ';
      const tabChar = String.fromCharCode(9);
      const newlineChar = String.fromCharCode(10);
      const crChar = String.fromCharCode(13);
      // Create regex pattern using character class with explicit characters
      const whitespacePattern = new RegExp('[' + spaceChar + tabChar + newlineChar + crChar + ']+', 'g');
      searchWords = searchTerm.split(whitespacePattern).filter(word => word.length > 0);
    } else {
      // No whitespace, so the entire term is one word
      searchWords = [searchTerm];
    }
    // DEBUG: Log if search term is being split incorrectly
    if (searchTerm === 'test' && searchWords.length > 1) {
      // Force it to be a single word
      searchWords = [searchTerm];
    }
    // If no valid search words after splitting, show nothing
    if (searchWords.length === 0) {
      return false;
    }
    // Get all text fields to search in
    const searchableTexts = [
      item.id || '',
      item.name || '',
      String(item.value || ''),
      item.placeholder || ''
    ].filter(text => text && text.length > 0);
    // If no searchable texts, don't match
    if (searchableTexts.length === 0) {
      return false;
    }
    // DEBUG: Log search details for fields that shouldn't match
    const shouldDebug = searchTerm === 'test' && (
      item.id === 'user_state' || 
      item.id === 'user_state_hidden' || 
      item.id === 'form_county' || 
      item.id === 'current_date'
    );
    if (shouldDebug) {
    }
    // Check if all search words are found in any of the searchable texts
    const matches = searchableTexts.some(text => {
      const matched = matchesPartialWords(searchWords, text);
      if (shouldDebug) {
        if (matched) {
        }
      }
      return matched;
    });
    if (shouldDebug) {
    }
    return matches;
  });
  // Group by type
  const grouped = {
    text: [],
    email: [],
    tel: [],
    number: [],
    date: [],
    select: [],
    textarea: [],
    checkbox: [],
    radio: [],
    hidden: [],
    other: []
  };
  // First pass: collect all visible field names to identify duplicates
  const visibleFieldNames = new Set();
  filteredData.forEach(item => {
    if (item.inputType !== 'hidden' && item.type !== 'hidden') {
      visibleFieldNames.add(item.name);
    }
  });
  filteredData.forEach(item => {
    // Skip hidden fields that have a corresponding visible field with the same name
    if (item.inputType === 'hidden' && visibleFieldNames.has(item.name)) {
      return; // Skip this hidden field
    }
    // Use the same logic as the filtering to determine the final itemType
    let itemType = '';
    if (item.inputType === 'text' || item.inputType === 'email' || item.inputType === 'tel' || item.inputType === 'number' || item.inputType === 'date') {
      itemType = item.inputType;
    } else if (item.type === 'select') {
      itemType = 'text'; // Classify dropdowns as text inputs
    } else if (item.type === 'textarea') {
      itemType = 'textarea';
    } else if (item.inputType === 'checkbox') {
      itemType = 'checkbox';
    } else if (item.inputType === 'radio') {
      itemType = 'radio';
    } else if (item.inputType === 'hidden') {
      // Check if this is a state-related hidden field that should be grouped with text inputs
      if (item.id && (item.id.includes('_state') || item.id.includes('_state_short'))) {
        itemType = 'text'; // Classify state-related hidden fields as text inputs
    } else {
        itemType = 'hidden';
      }
    } else {
      itemType = 'text'; // Classify other inputs as text inputs
    }
    // Group by the final itemType
    grouped[itemType].push(item);
  });
  // Generate HTML
  let html = '';
  const typeLabels = {
    text: 'ðŸ“ Text Inputs',
    email: 'ðŸ“§ Email Inputs', 
    tel: 'ðŸ“ž Phone Inputs',
    number: 'ðŸ”¢ Number Inputs',
    date: 'ðŸ“… Date Inputs',
    select: 'ðŸ“ Text Inputs',
    textarea: 'ðŸ“„ Text Areas',
    checkbox: 'â˜‘ï¸ Checkboxes',
    radio: 'ðŸ”˜ Radio Buttons',
    hidden: 'ðŸ”’ Hidden Fields',
    other: 'ðŸ“ Text Inputs'
  };
  Object.keys(grouped).forEach(type => {
    if (grouped[type].length > 0) {
      html += '<div style="margin-bottom: 30px;">';
      html += '<h3 style="color: #2c3e50; margin-bottom: 15px; font-size: 1.2em; border-bottom: 2px solid #e0e7ef; padding-bottom: 8px;">' + typeLabels[type] + ' (' + grouped[type].length + ')</h3>';
      grouped[type].forEach(item => {
        const valueDisplay = item.value === '' ? '<em style="color: #999;">(empty)</em>' : 
                           item.value === true ? '<span style="color: #38d39f;">âœ“ checked</span>' :
                           item.value === false ? '<span style="color: #e74c3c;">âœ— unchecked</span>' :
                           '<span style="color: #2c3e50;">' + String(item.value).substring(0, 100) + (String(item.value).length > 100 ? '...' : '') + '</span>';
        const requiredBadge = item.required ? '<span style="background: #e74c3c; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; margin-left: 8px;">REQUIRED</span>' : '';
        const virtualBadge = item.isVirtual ? '<span style="background: #4f8cff; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; margin-left: 8px;">VIRTUAL</span>' : '';
        // Determine the primary identifier (ID if available, otherwise name)
        const primaryId = item.id || item.name || 'unnamed';
        const displayId = item.id || '<em style="color: #999;">(no ID)</em>';
        const displayName = item.name || '<em style="color: #999;">(no name)</em>';
        html += '<div class="debug-entry" data-id="' + primaryId + '" style="background: #f8faff; border: 1px solid #e0e7ef; border-radius: 8px; padding: 15px; margin-bottom: 10px; transition: all 0.3s ease; cursor: pointer; position: relative;">' +
          '<div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px; flex-wrap: wrap; gap: 8px;">' +
            '<div style="flex: 1; min-width: 0;">' +
              '<strong style="color: #2c3e50; font-size: 1.1em; word-break: break-all; line-height: 1.3; display: block;">' + displayId + '</strong>' +
              requiredBadge + virtualBadge +
            '</div>' +
            '<span style="background: #e0e7ef; color: #2c3e50; padding: 4px 8px; border-radius: 4px; font-size: 0.9em; flex-shrink: 0; white-space: nowrap;">' + item.inputType + '</span>' +
          '</div>' +
          '<div style="margin-bottom: 5px;">' +
            '<span style="color: #666; font-size: 0.9em;">Name: </span>' +
            '<code style="background: #f0f0f0; padding: 2px 6px; border-radius: 4px; font-size: 0.9em; word-break: break-all; display: inline-block; max-width: 100%;">' + displayName + '</code>' +
          '</div>' +
          (item.placeholder ? '<div style="margin-bottom: 5px;"><span style="color: #666; font-size: 0.9em;">Placeholder: </span><span style="color: #999;">' + item.placeholder + '</span></div>' : '') +
          (item.isVirtual && item.dropdownSource ? '<div style="margin-bottom: 5px;"><span style="color: #666; font-size: 0.9em;">From Dropdown: </span><span style="color: #4f8cff; font-weight: bold;">' + item.dropdownSource + '</span> â†’ <span style="color: #2c3e50;">' + item.optionValue + '</span></div>' : '') +
          '<div>' +
            '<span style="color: #666; font-size: 0.9em;">Value: </span>' +
            valueDisplay +
          '</div>' +
          '<div class="copy-indicator" style="position: absolute; top: 10px; right: 10px; background: #38d39f; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8em; font-weight: bold; opacity: 0; transform: scale(0.8); transition: all 0.3s ease;">COPIED!</div>' +
        '</div>';
      });
      html += '</div>';
    }
  });
  if (html === '') {
    html = '<div style="text-align: center; color: #666; padding: 40px;"><p>No inputs found matching your search.</p></div>';
  }
  content.innerHTML = html;
  // Add click event listeners to debug entries
  const debugEntries = content.querySelectorAll('.debug-entry');
  debugEntries.forEach(entry => {
    entry.addEventListener('click', function() {
      const id = this.getAttribute('data-id');
      copyToClipboard(id, this);
    });
    // Add hover effects
    entry.addEventListener('mouseenter', function() {
      this.style.background = '#f0f8ff';
      this.style.borderColor = '#4f8cff';
      this.style.transform = 'translateY(-2px)';
      this.style.boxShadow = '0 4px 12px rgba(79, 140, 255, 0.15)';
    });
    entry.addEventListener('mouseleave', function() {
      this.style.background = '#f8faff';
      this.style.borderColor = '#e0e7ef';
      this.style.transform = 'translateY(0)';
      this.style.boxShadow = 'none';
    });
  });
}
// Copy to clipboard function
function copyToClipboard(text, element) {
  // Remove any existing copy highlights
  const allEntries = document.querySelectorAll('.debug-entry');
  allEntries.forEach(entry => {
    entry.style.background = '#f8faff';
    entry.style.borderColor = '#e0e7ef';
    entry.style.borderWidth = '1px';
    const indicator = entry.querySelector('.copy-indicator');
    if (indicator) {
      indicator.style.opacity = '0';
      indicator.style.transform = 'scale(0.8)';
    }
  });
  // Highlight the clicked entry
  element.style.background = '#e8f5e8';
  element.style.borderColor = '#38d39f';
  element.style.borderWidth = '2px';
  // Show copy indicator
  const copyIndicator = element.querySelector('.copy-indicator');
  if (copyIndicator) {
    copyIndicator.style.opacity = '1';
    copyIndicator.style.transform = 'scale(1)';
  }
  // Copy to clipboard
  if (navigator.clipboard && window.isSecureContext) {
    // Use modern clipboard API
    navigator.clipboard.writeText(text).then(() => {
    }).catch(err => {
      fallbackCopyToClipboard(text);
    });
  } else {
    // Fallback for older browsers
    fallbackCopyToClipboard(text);
  }
  // Reset highlight after 2 seconds
  setTimeout(() => {
    element.style.background = '#f8faff';
    element.style.borderColor = '#e0e7ef';
    element.style.borderWidth = '1px';
    if (copyIndicator) {
      copyIndicator.style.opacity = '0';
      copyIndicator.style.transform = 'scale(0.8)';
    }
  }, 2000);
}
// Fallback copy function for older browsers
function fallbackCopyToClipboard(text) {
  const textArea = document.createElement('textarea');
  textArea.value = text;
  textArea.style.position = 'fixed';
  textArea.style.left = '-999999px';
  textArea.style.top = '-999999px';
  document.body.appendChild(textArea);
  textArea.focus();
  textArea.select();
  try {
    document.execCommand('copy');
  } catch (err) {
  }
  document.body.removeChild(textArea);
}
// Export Names/IDs function
function exportNamesAndIds() {
  // Get form name from the form name input field
  const formNameEl = document.getElementById('formNameInput');
  const formName = formNameEl && formNameEl.value.trim() ? formNameEl.value.trim() : 'Example Form';
  const formData = {
    exportDate: new Date().toISOString(),
    formName: formName,
    formTitle: document.title || 'Form Data',
    inputs: []
  };
  // Get all form inputs
  const inputs = document.querySelectorAll('input, select, textarea');
  inputs.forEach((input, index) => {
    // Only include inputs that have an ID
    if (input.id) {
      const inputData = {
        id: input.id
      };
      formData.inputs.push(inputData);
    }
  });
  // Create and download JSON file
  const jsonString = JSON.stringify(formData, null, 2);
  const blob = new Blob([jsonString], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'form-names-ids-' + new Date().toISOString().split('T')[0] + '.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  // Show success message
  const button = document.getElementById('exportNamesIdsBtn');
  const originalText = button.textContent;
  button.textContent = 'âœ… Exported!';
  button.style.background = 'linear-gradient(90deg, #38d39f 0%, #4f8cff 100%)';
  setTimeout(() => {
    button.textContent = originalText;
    button.style.background = 'linear-gradient(90deg, #4f8cff 0%, #38d39f 100%)';
  }, 2000);
}
// Search/Filter functionality (debounced to avoid heavy rescans)
function debounce(fn, delay = 150) {
  let t;
  return function(...args) {
    clearTimeout(t);
    t = setTimeout(() => fn.apply(this, args), delay);
  };
}
const debouncedPopulateDebugContent = debounce(populateDebugContent, 150);
document.getElementById('debugSearch').addEventListener('input', debouncedPopulateDebugContent);
// Type filter functionality
document.getElementById('debugTypeFilter').addEventListener('change', debouncedPopulateDebugContent);
// Export Names/IDs functionality
document.getElementById('exportNamesIdsBtn').addEventListener('click', exportNamesAndIds);
// Function to create Form Name input field (to be called from the form editor interface)
function createFormNameInput() {
  const formNameContainer = document.createElement('div');
  formNameContainer.id = 'formNameContainer';
  formNameContainer.style.cssText = 
    'background: #fff; ' +
    'border: 2px solid #2980b9; ' +
    'border-radius: 10px; ' +
    'padding: 20px; ' +
    'margin: 20px auto; ' +
    'max-width: 600px; ' +
    'box-shadow: 0 4px 12px rgba(0,0,0,0.1);';
  formNameContainer.innerHTML = 
    '<h3 style="text-align: center; margin-bottom: 15px; color: #2c3e50; font-size: 1.3em;">Form Name</h3>' +
    '<div style="text-align: center;">' +
      '<label for="formNameInput" style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">Form Name:</label>' +
      '<input type="text" id="formNameInput" name="formNameInput" ' +
             'placeholder="Enter your form name (e.g., Customer Survey, Job Application)" ' +
             'style="width: 100%; max-width: 400px; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px; text-align: center;" ' +
             'value="Example Form">' +
      '<p style="margin-top: 8px; font-size: 0.9em; color: #666; font-style: italic;">' +
        'This name will appear in the browser title and be used for the default checkbox.' +
      '</p>' +
    '</div>';
  return formNameContainer;
}
// Function to insert Form Name input above the first section
function insertFormNameInput() {
  // Check if form name input already exists
  if (document.getElementById('formNameContainer')) {
    return; // Already exists
  }
  // Find the first section or a suitable insertion point
  const firstSection = document.querySelector('[id^="sectionBlock"]');
  const formNameInput = createFormNameInput();
  if (firstSection) {
    firstSection.parentNode.insertBefore(formNameInput, firstSection);
  } else {
    // If no sections found, append to body or a container
    const container = document.querySelector('#formEditor') || document.body;
    container.insertBefore(formNameInput, container.firstChild);
  }
}
// Update content when form values change
document.addEventListener('input', function() {
  if (debugMenuVisible) {
    populateDebugContent();
  }
});
document.addEventListener('change', function() {
  if (debugMenuVisible) {
    populateDebugContent();
  }
});
// Function to update hidden state fields when dropdown selection changes
function updateStateHiddenFields(dropdown, hiddenFullId, hiddenShortId) {

    const selectedState = dropdown && dropdown.value ? dropdown.value : '';

    const fullField = hiddenFullId ? document.getElementById(hiddenFullId) : null;
    const shortField = hiddenShortId ? document.getElementById(hiddenShortId) : null;

    // State abbreviation mapping
    const stateAbbreviations = {
        'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR', 'California': 'CA', 'Colorado': 'CO',
        'Connecticut': 'CT', 'Delaware': 'DE', 'Florida': 'FL', 'Georgia': 'GA', 'Hawaii': 'HI', 'Idaho': 'ID',
        'Illinois': 'IL', 'Indiana': 'IN', 'Iowa': 'IA', 'Kansas': 'KS', 'Kentucky': 'KY', 'Louisiana': 'LA',
        'Maine': 'ME', 'Maryland': 'MD', 'Massachusetts': 'MA', 'Michigan': 'MI', 'Minnesota': 'MN', 'Mississippi': 'MS',
        'Missouri': 'MO', 'Montana': 'MT', 'Nebraska': 'NE', 'Nevada': 'NV', 'New Hampshire': 'NH', 'New Jersey': 'NJ',
        'New Mexico': 'NM', 'New York': 'NY', 'North Carolina': 'NC', 'North Dakota': 'ND', 'Ohio': 'OH', 'Oklahoma': 'OK',
        'Oregon': 'OR', 'Pennsylvania': 'PA', 'Rhode Island': 'RI', 'South Carolina': 'SC', 'South Dakota': 'SD',
        'Tennessee': 'TN', 'Texas': 'TX', 'Utah': 'UT', 'Vermont': 'VT', 'Virginia': 'VA', 'Washington': 'WA',
        'West Virginia': 'WV', 'Wisconsin': 'WI', 'Wyoming': 'WY'
    };
    const abbreviation = selectedState ? (stateAbbreviations[selectedState] || '') : '';

    if (shortField) {
        shortField.value = abbreviation;

    } else {

    }

    if (fullField && fullField.tagName !== 'SELECT') {
        fullField.value = selectedState;

    } else if (!fullField) {

    } else {

    }
}
// Function to update user full name
function updateUserFullName() {
  const firstNameField = document.getElementById('user_firstname');
  const lastNameField = document.getElementById('user_lastname');
  const fullNameField = document.getElementById('user_fullname');
  const firstName = firstNameField?.value || '';
  const lastName = lastNameField?.value || '';
  if (fullNameField) {
    // Simply combine first and last name with a space
    const fullName = (firstName + ' ' + lastName).trim();
    fullNameField.value = fullName;
    // Verify the value was set
  } else {
  }
}
// Store uploaded files for cart processing
if (!window.uploadedFiles) {
  window.uploadedFiles = {}; // questionId -> file object
}

// File upload handler functions
function handleFileUpload(questionId, input) {
  const file = input.files[0];
  if (!file) return;

  const dropzone = document.getElementById('fileUploadDropzone' + questionId);
  const preview = document.getElementById('fileUploadPreview' + questionId);
  const previewBody = document.getElementById('fileUploadPreviewBody' + questionId);

  if (!dropzone || !preview || !previewBody) return;

  // Store the uploaded file for cart processing
  if (!window.uploadedFiles) {
    window.uploadedFiles = {};
  }
  window.uploadedFiles[questionId] = file;

  // Hide dropzone and show preview
  dropzone.style.display = 'none';
  preview.style.display = 'block';

  // Clear previous preview
  previewBody.innerHTML = '';

  // PDF preview only (PDFs only)
  if (file.type === 'application/pdf') {
    const reader = new FileReader();
    reader.onload = function(e) {
      const iframe = document.createElement('iframe');
      iframe.src = e.target.result;
      iframe.title = file.name;
      previewBody.appendChild(iframe);
    };
    reader.readAsDataURL(file);
  } else {
    // Fallback for non-PDF files (shouldn't happen with accept=".pdf")
    const p = document.createElement('p');
    p.textContent = 'File uploaded: ' + file.name;
    p.style.color = '#6c757d';
    previewBody.appendChild(p);
  }

  // Refresh navigation to update button states

  if (typeof refreshNavForQ3 === 'function') {

    refreshNavForQ3();
  } else if (window.questionNavControllers) {
    const activeSection = document.querySelector('.section.active');

    if (activeSection && window.questionNavControllers[activeSection.id]) {
      const controller = window.questionNavControllers[activeSection.id];

      if (typeof controller === 'function') {
        controller();
      } else {

      }
    } else {

      // Fallback: try to find the section containing this question
      const questionContainer = document.getElementById('question-container-' + questionId);
      if (questionContainer) {
        const sectionEl = questionContainer.closest('[id^="section"]');
        if (sectionEl && window.questionNavControllers[sectionEl.id]) {

          const controller = window.questionNavControllers[sectionEl.id];
          if (typeof controller === 'function') {
            controller();
          }
        }
      }
    }
  } else {

  }
}

function removeFileUpload(questionId) {
  const dropzone = document.getElementById('fileUploadDropzone' + questionId);
  const preview = document.getElementById('fileUploadPreview' + questionId);
  const fileInput = document.getElementById('fileUpload_' + questionId);

  // Remove the file from stored uploads
  if (window.uploadedFiles && window.uploadedFiles[questionId]) {
    delete window.uploadedFiles[questionId];
  }

  if (dropzone) dropzone.style.display = 'block';
  if (preview) preview.style.display = 'none';
  if (fileInput) {
    fileInput.value = '';
    fileInput.files = null;
  }

  // Refresh navigation to update button states
  if (typeof refreshNavForQ3 === 'function') {
    refreshNavForQ3();
  } else if (window.questionNavControllers) {
    const activeSection = document.querySelector('.section.active');
    if (activeSection && window.questionNavControllers[activeSection.id]) {
      const controller = window.questionNavControllers[activeSection.id];
      if (typeof controller === 'function') {
        controller();
      }
    }
  }
}

// Function to update user address fields
function updateUserAddressFields() {
  const street = document.getElementById('user_street')?.value || '';
  const city = document.getElementById('user_city')?.value || '';
  const state = document.getElementById('user_state')?.value || '';
  const zip = document.getElementById('user_zip')?.value || '';
  const streetHidden = document.getElementById('user_street_hidden');
  const cityHidden = document.getElementById('user_city_hidden');
  const stateHidden = document.getElementById('user_state_hidden');
  const zipHidden = document.getElementById('user_zip_hidden');
  const fullAddressField = document.getElementById('user_full_address');
  const fullAddressHidden = document.getElementById('user_full_address_hidden');
  // Build full address string
  const parts = [];
  if (street) parts.push(street);
  const cityState = [city, state].filter(Boolean).join(', ').trim();
  if (cityState) parts.push(cityState);
  if (zip) {
    if (parts.length > 0) {
      parts[parts.length - 1] = parts[parts.length - 1] + (zip ? ' ' + zip : '');
    } else {
      parts.push(zip);
    }
  }
  const fullAddress = parts.join(', ').replace(/, ,/g, ',').trim();
  if (streetHidden) streetHidden.value = street;
  if (cityHidden) cityHidden.value = city;
  if (stateHidden) stateHidden.value = state;
  if (zipHidden) zipHidden.value = zip;
  if (fullAddressField) fullAddressField.value = fullAddress;
  if (fullAddressHidden) fullAddressHidden.value = fullAddress;
}
// Add event listeners for first and last name fields
document.addEventListener('DOMContentLoaded', function() {
  const firstNameField = document.getElementById('user_firstname');
  const lastNameField = document.getElementById('user_lastname');
  if (firstNameField) {
    firstNameField.addEventListener('input', updateUserFullName);
    firstNameField.addEventListener('change', updateUserFullName);
  }
  if (lastNameField) {
    lastNameField.addEventListener('input', updateUserFullName);
    lastNameField.addEventListener('change', updateUserFullName);
  }
  // Add event listeners for address fields
  const streetField = document.getElementById('user_street');
  const cityField = document.getElementById('user_city');
  const stateField = document.getElementById('user_state');
  const zipField = document.getElementById('user_zip');
  if (streetField) {
    streetField.addEventListener('input', updateUserAddressFields);
    streetField.addEventListener('change', updateUserAddressFields);
  }
  if (cityField) {
    cityField.addEventListener('input', updateUserAddressFields);
    cityField.addEventListener('change', updateUserAddressFields);
  }
  if (stateField) {
    stateField.addEventListener('input', updateUserAddressFields);
    stateField.addEventListener('change', updateUserAddressFields);
  }
  if (zipField) {
    zipField.addEventListener('input', updateUserAddressFields);
    zipField.addEventListener('change', updateUserAddressFields);
  }
  // Set user_fullname and address fields 2 seconds after page loads to ensure all autopopulation is complete
  setTimeout(() => {
    updateUserFullName();
    updateUserAddressFields();
  }, 2000);
});
</script>

  <script>
  // Helper functions for trigger checkbox radio button behavior
  function createHiddenCheckboxForRadio(radioId, radioName, radioValue) {
    // Remove any existing hidden checkbox with the same ID
    removeHiddenCheckbox(radioId);
    // Find the hidden fields container
    let hiddenContainer = document.getElementById('hidden_pdf_fields');
    if (!hiddenContainer) {
      // Create the hidden fields container if it doesn't exist
      hiddenContainer = document.createElement('div');
      hiddenContainer.id = 'hidden_pdf_fields';
      hiddenContainer.style.display = 'none';
      // Find the form and append the hidden container
      const form = document.querySelector('form') || document.body;
      form.appendChild(hiddenContainer);
    }
    // Create the hidden checkbox
    const hiddenCheckbox = document.createElement('input');
    hiddenCheckbox.type = 'checkbox';
    hiddenCheckbox.id = radioId;
    hiddenCheckbox.name = radioId; // Use the same name as the radio button ID
    hiddenCheckbox.value = radioValue;
    hiddenCheckbox.checked = true;
    hiddenCheckbox.style.display = 'none';
    // Add to hidden container
    hiddenContainer.appendChild(hiddenCheckbox);
  }
  function removeHiddenCheckbox(radioId) {
    const selector = '#' + ((window.CSS && CSS.escape) ? CSS.escape(radioId) : radioId);
    const nodes = document.querySelectorAll(selector);

    nodes.forEach(node => {
      if (node.type === 'checkbox' && node.style && node.style.display === 'none') {
        node.remove();
      }
    });
    if (typeof window.updateAllLinkedCheckboxes === 'function') {

      window.updateAllLinkedCheckboxes();
    }
  }
  // Note: createTriggerFieldsContainer is already defined earlier in the script
  </script>
  <!-- Sign-in Required Modal -->
  <div id="signinRequiredModal" class="signin-modal-overlay">
    <div class="signin-modal">
      <h2>Sign In Required</h2>
      <p>You need to sign up before you can finish filling out the form. Please sign in to continue.</p>
      <button type="button" class="signin-modal-button" onclick="window.location.href='https://www.form-star.com/Pages/account.html'">Sign In</button>
    </div>
  </div>
</body>
</html>
